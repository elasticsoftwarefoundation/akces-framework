This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix. The content has been processed where comments have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.java, **/*.xml, **/*.properties, **/*.proto, **/*.imports, **/*.yaml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types

Additional Info:
----------------

================================================================
Directory Structure
================================================================
crypto-trading/
  aggregates/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                aggregates/
                  account/
                    commands/
                      CreateAccountCommand.java
                    events/
                      AccountCreatedEvent.java
                    Account.java
                    AccountState.java
                  cryptomarket/
                    commands/
                      CreateCryptoMarketCommand.java
                      PlaceMarketOrderCommand.java
                    events/
                      CryptoMarketCreatedEvent.java
                      MarketOrderFilledEvent.java
                      MarketOrderPlacedEvent.java
                      MarketOrderRejectedErrorEvent.java
                    CoinbaseService.java
                    CryptoMarket.java
                    CryptoMarketState.java
                    Order.java
                    Product.java
                    Side.java
                    Ticker.java
                  orders/
                    commands/
                      PlaceBuyOrderCommand.java
                      RejectOrderCommand.java
                    events/
                      BuyOrderCreatedEvent.java
                      BuyOrderPlacedEvent.java
                      BuyOrderRejectedEvent.java
                      UserOrderProcessesCreatedEvent.java
                    BuyOrderProcess.java
                    CryptoMarket.java
                    OrderProcess.java
                    OrderProcessManager.java
                    OrderProcessManagerState.java
                  wallet/
                    commands/
                      CreateBalanceCommand.java
                      CreateWalletCommand.java
                      CreditWalletCommand.java
                      ReserveAmountCommand.java
                    events/
                      AmountReservedEvent.java
                      BalanceAlreadyExistsErrorEvent.java
                      BalanceCreatedEvent.java
                      InsufficientFundsErrorEvent.java
                      InvalidAmountErrorEvent.java
                      InvalidCryptoCurrencyErrorEvent.java
                      WalletCreatedEvent.java
                      WalletCreditedEvent.java
                    Wallet.java
                    WalletState.java
                AggregateConfig.java
        resources/
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CoinbaseMarketDataTest.java
                CoinbaseServiceTest.java
                CryptoTradingApplicationTest.java
                TestUtils.java
        resources/
          akces-client.properties
          logback-test.xml
    pom.xml
  commands/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                web/
                  dto/
                    AccountInput.java
                    AccountOutput.java
                    BalanceOutput.java
                    CreateBalanceInput.java
                    CreditWalletInput.java
                    OrderInput.java
                  errors/
                    ErrorEventException.java
                    ErrorEventResponse.java
                    GlobalExceptionHandler.java
                  AccountCommandController.java
                  OrdersCommandController.java
                  WalletCommandController.java
                ClientConfig.java
        resources/
          akces-framework.properties
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CryptoTradingCommandApiTest.java
                TestUtils.java
        resources/
          logback-test.xml
    pom.xml
  queries/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                query/
                  AccountQueryModel.java
                  AccountQueryModelState.java
                  WalletQueryModel.java
                  WalletQueryModelState.java
                web/
                  AccountQueryController.java
                  WalletQueryController.java
                ClientConfig.java
        resources/
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CryptoTradingE2ETests.java
                CryptoTradingQueryApiTest.java
                TestUtils.java
        resources/
          application-test.properties
          logback-test.xml
    pom.xml
  pom.xml
pom.xml

================================================================
Files
================================================================

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/commands/CreateAccountCommand.java
================
) implements Command {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/events/AccountCreatedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/Account.java
================
public final class Account implements Aggregate<AccountState> {
    public String getName() {
    public Class<AccountState> getStateClass() {
    public Stream<AccountCreatedEvent> create(CreateAccountCommand cmd, AccountState isNull) {
        return Stream.of(new AccountCreatedEvent(cmd.userId(), cmd.country(), cmd.firstName(), cmd.lastName(), cmd.email()));
    public AccountState create(@NotNull AccountCreatedEvent event, AccountState isNull) {
        return new AccountState(event.userId(), event.country(), event.firstName(), event.lastName(), event.email());

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/AccountState.java
================
                           @NotNull @PIIData String email) implements AggregateState {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/CreateCryptoMarketCommand.java
================
) implements Command {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/PlaceMarketOrderCommand.java
================
                                      BigDecimal size) implements Command {
    public String getAggregateId() {
        return marketId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/CryptoMarketCreatedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderFilledEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return marketId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderPlacedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return marketId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderRejectedErrorEvent.java
================
                                            @NotNull String rejectionReason) implements ErrorEvent {
    public String getAggregateId() {
        return marketId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CoinbaseService.java
================
public class CoinbaseService {
    public Ticker getTicker(String productId) {
        return webClient.get()
                .uri("/products/{productId}/ticker", productId)
                .retrieve()
                .bodyToMono(Ticker.class)
                .block();
    public Product getProduct(String productId) {
                .uri("/products/{productId}", productId)
                .bodyToMono(Product.class)
    public List<Product> getProducts() {
                .uri("/products")
                .bodyToFlux(Product.class)
                .collectList()

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarket.java
================
public class CryptoMarket implements Aggregate<CryptoMarketState> {
    private final MathContext mathContext = new MathContext(8);
    public String getName() {
    public Class<CryptoMarketState> getStateClass() {
    public @NotNull Stream<DomainEvent> handle(@NotNull CreateCryptoMarketCommand command, CryptoMarketState isNull) {
        return Stream.of(new CryptoMarketCreatedEvent(command.id(),
                command.baseCurrency(),
                command.quoteCurrency(),
                command.baseIncrement(),
                command.quoteIncrement(),
                command.defaultCounterPartyId()));
    public @NotNull Stream<DomainEvent> handle(@NotNull PlaceMarketOrderCommand command, CryptoMarketState currentState) {
        if (command.side().equals(Side.BUY) && command.funds() == null) {
            return Stream.of(new MarketOrderRejectedErrorEvent(command.marketId(),
                    command.orderId(),
                    command.ownerId(),
        } else if (command.side().equals(Side.SELL) && command.size() == null) {
            Ticker currentTicker = coinbaseService.getTicker(currentState.id());
            BigDecimal price = command.side().equals(Side.BUY) ? new BigDecimal(currentTicker.ask()) : new BigDecimal(currentTicker.bid());
            BigDecimal quantity = command.side().equals(Side.BUY) ? command.funds().divide(price, mathContext) : command.size();
            MarketOrderFilledEvent marketOrderFilledEvent = new MarketOrderFilledEvent(command.marketId(),
                    currentState.defaultCounterPartyId(),
                    command.side(),
                    currentState.baseCrypto(),
                    currentState.quoteCrypto(),
            MarketOrderPlacedEvent marketOrderPlacedEvent = new MarketOrderPlacedEvent(command.marketId(),
                    command.funds(),
                    command.size());
            return Stream.of(marketOrderPlacedEvent, marketOrderFilledEvent);
    public @NotNull CryptoMarketState apply(@NotNull CryptoMarketCreatedEvent event, CryptoMarketState isNull) {
        return new CryptoMarketState(event.id(),
                event.baseCrypto(),
                event.quoteCrypto(),
                event.baseIncrement(),
                event.quoteIncrement(),
                event.defaultCounterPartyId());
    public @NotNull CryptoMarketState apply(@NotNull MarketOrderPlacedEvent event, CryptoMarketState currentState) {
    public @NotNull CryptoMarketState apply(@NotNull MarketOrderFilledEvent event, CryptoMarketState currentState) {

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarketState.java
================
) implements AggregateState {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Order.java
================


================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Product.java
================


================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Side.java
================


================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Ticker.java
================


================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/PlaceBuyOrderCommand.java
================
) implements Command {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/RejectOrderCommand.java
================
) implements Command {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderCreatedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return orderId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderPlacedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return orderId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderRejectedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/UserOrderProcessesCreatedEvent.java
================
public record UserOrderProcessesCreatedEvent(@NotNull @AggregateIdentifier String userId) implements DomainEvent {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/BuyOrderProcess.java
================
) implements OrderProcess {
    public String getProcessId() {
        return orderId();
    public BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error) {
        return new BuyOrderRejectedEvent(error.walletId(), orderId(), clientReference());
    public BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error) {
    public BuyOrderRejectedEvent handle(RejectOrderCommand command) {
        return new BuyOrderRejectedEvent(command.userId(), orderId(), clientReference());

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/CryptoMarket.java
================


================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcess.java
================
public sealed interface OrderProcess extends AkcesProcess permits BuyOrderProcess {
    String orderId();
    CryptoMarket market();
    BigDecimal size();
    BigDecimal amount();
    String clientReference();
    BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error);
    BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error);
    BuyOrderRejectedEvent handle(RejectOrderCommand command);

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManager.java
================
public class OrderProcessManager implements Aggregate<OrderProcessManagerState> {
    public String getName() {
    public Class<OrderProcessManagerState> getStateClass() {
    public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
        return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
    public OrderProcessManagerState create(UserOrderProcessesCreatedEvent event, OrderProcessManagerState isNull) {
        return new OrderProcessManagerState(event.userId());
    public OrderProcessManagerState handle(BuyOrderCreatedEvent event, OrderProcessManagerState state) {
        return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
            add(new BuyOrderProcess(
                    event.orderId(),
                    event.market(),
                    event.amount(),
                    event.clientReference()));
    public OrderProcessManagerState handle(BuyOrderRejectedEvent event, OrderProcessManagerState state) {
            removeIf(process -> process.orderId().equals(event.orderId()));
    public OrderProcessManagerState handle(BuyOrderPlacedEvent event, OrderProcessManagerState state) {
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
        String orderId = UUID.randomUUID().toString();
        getCommandBus().send(new ReserveAmountCommand(
                state.userId(),
                command.market().quoteCrypto(),
                command.amount(),
        return Stream.of(new BuyOrderCreatedEvent(
                command.market(),
                command.clientReference()));
    public Stream<BuyOrderRejectedEvent> rejectOrder(RejectOrderCommand command, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(command.orderId())) {
            return Stream.of(state.getAkcesProcess(command.orderId()).handle(command));
            return Stream.empty();
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
        OrderProcess orderProcess = state.getAkcesProcess(event.referenceId());
            getCommandBus().send(new PlaceMarketOrderCommand(
                    orderProcess.market().id(),
                    orderProcess.orderId(),
                    orderProcess.amount(),
            return Stream.of(new BuyOrderPlacedEvent(state.userId(), orderProcess.orderId(), orderProcess.market(), orderProcess.amount(), null));
    public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(errorEvent.referenceId())) {
            return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
    public Stream<DomainEvent> handle(InvalidCryptoCurrencyErrorEvent errorEvent, OrderProcessManagerState state) {
    public Stream<DomainEvent> handle(MarketOrderRejectedErrorEvent errorEvent, OrderProcessManagerState state) {
        getCommandBus().send(new RejectOrderCommand(state.userId(), errorEvent.orderId()));

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManagerState.java
================
        this(userId, List.of());
    public String getAggregateId() {
        return userId();
    public OrderProcess getAkcesProcess(String processId) {
        return runningProcesses.stream().filter(p -> p.orderId().equals(processId)).findFirst()
                .orElseThrow(() -> new UnknownAkcesProcessException("OrderProcessManager", userId(), processId));
    public boolean hasAkcesProcess(String processId) {
        return runningProcesses.stream().anyMatch(p -> p.orderId().equals(processId));

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateBalanceCommand.java
================
) implements Command {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateWalletCommand.java
================
) implements Command {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreditWalletCommand.java
================
) implements Command {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/ReserveAmountCommand.java
================
) implements Command {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/AmountReservedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return userId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceAlreadyExistsErrorEvent.java
================
                                             @NotNull String currency) implements ErrorEvent {
    public String getAggregateId() {
        return walletId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceCreatedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InsufficientFundsErrorEvent.java
================
) implements ErrorEvent {
    public @NotNull String getAggregateId() {
        return walletId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidAmountErrorEvent.java
================
) implements ErrorEvent {
    public @NotNull String getAggregateId() {
        return walletId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidCryptoCurrencyErrorEvent.java
================
) implements ErrorEvent {
    public String getAggregateId() {
        return walletId();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreatedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreditedEvent.java
================
) implements DomainEvent {
    public String getAggregateId() {
        return id();

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/Wallet.java
================
public final class Wallet implements Aggregate<WalletState> {
    public String getName() {
    public Class<WalletState> getStateClass() {
    public @NotNull Stream<DomainEvent> create(@NotNull CreateWalletCommand cmd, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(cmd.id()), new BalanceCreatedEvent(cmd.id(), cmd.currency()));
    public @NotNull Stream<DomainEvent> create(@NotNull AccountCreatedEvent event, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(event.getAggregateId()), new BalanceCreatedEvent(event.getAggregateId(), "EUR"));
    public Stream<DomainEvent> credit(@NotNull CreditWalletCommand cmd, @NotNull WalletState currentState) {
        WalletState.Balance balance = currentState.balances().stream().filter(b -> b.currency().equals(cmd.currency())).findFirst().orElse(null);
            return Stream.of(new InvalidCryptoCurrencyErrorEvent(cmd.id(), cmd.currency()));
        if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {
            return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
        return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), cmd.amount(), balance.amount().add(cmd.amount())));
    public Stream<DomainEvent> makeReservation(ReserveAmountCommand command, WalletState state) {
        WalletState.Balance balance = state.balances().stream().filter(b -> b.currency().equals(command.currency())).findFirst().orElse(null);
            return Stream.of(new InvalidCryptoCurrencyErrorEvent(command.userId(), command.currency(), command.referenceId()));
        if (command.amount().compareTo(BigDecimal.ZERO) < 0) {
            return Stream.of(new InvalidAmountErrorEvent(command.userId(), command.currency()));
        if (balance.getAvailableAmount().compareTo(command.amount()) >= 0) {
            return Stream.of(new AmountReservedEvent(command.userId(), command.currency(), command.amount(), command.referenceId()));
            return Stream.of(new InsufficientFundsErrorEvent(command.userId(), command.currency(), balance.getAvailableAmount(), command.amount(), command.referenceId()));
    public @NotNull WalletState create(@NotNull WalletCreatedEvent event, WalletState isNull) {
        return new WalletState(event.id(), new ArrayList<>());
    public @NotNull WalletState createBalance(@NotNull BalanceCreatedEvent event, WalletState state) {
        List<WalletState.Balance> balances = new ArrayList<>(state.balances());
        balances.add(new WalletState.Balance(event.currency(), BigDecimal.ZERO));
        return new WalletState(state.id(), balances);
    public @NotNull WalletState credit(@NotNull WalletCreditedEvent event, @NotNull WalletState state) {
        return new WalletState(state.id(), state.balances().stream().map(b -> {
            if (b.currency().equals(event.currency())) {
                return new WalletState.Balance(b.currency(), b.amount().add(event.amount()));
        }).toList());
    public @NotNull WalletState reserveAmount(@NotNull AmountReservedEvent event, @NotNull WalletState state) {
                return new WalletState.Balance(b.currency(), b.amount(), b.reservedAmount().add(event.amount()));
    public @NotNull Stream<DomainEvent> createBalance(@NotNull CreateBalanceCommand cmd, @NotNull WalletState currentState) {
        boolean balanceExists = currentState.balances().stream()
                .anyMatch(balance -> balance.currency().equals(cmd.currency()));
            return Stream.of(new BalanceAlreadyExistsErrorEvent(cmd.id(), cmd.currency()));
        return Stream.of(new BalanceCreatedEvent(cmd.id(), cmd.currency()));

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/WalletState.java
================
) implements AggregateState {
    public String getAggregateId() {
        return id();
        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/AggregateConfig.java
================
public class AggregateConfig {
    public WebClient coinbaseWebClient() {
        return WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

================
File: crypto-trading/aggregates/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading Command Service
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseMarketDataTest.java
================
public class CoinbaseMarketDataTest {
    void testCoinbaseGetProducts() {
        WebClient webClient = WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
        String response = webClient.get()
                .uri("/products")
                .retrieve()
                .bodyToMono(String.class)
                .block();
        System.out.println(response);
    void testCoinbaseGetSingleProduct() {
                .uri("/products/BTC-EUR")
    void testGetCoinbaseTicker() {
                .uri("/products/BTC-EUR/ticker")

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseServiceTest.java
================
public class CoinbaseServiceTest {
    public void testGetProductById() {
        Product product = coinbaseService.getProduct(productId);
        assertNotNull(product, "Product should not be null");
    public void testGetTickerById() {
        Ticker ticker = coinbaseService.getTicker(productId);
        assertNotNull(ticker, "Ticker should not be null");
    public void testGetProducts() {
        List<Product> products = coinbaseService.getProducts();
        assertNotNull(products, "Products should not be null");
        products.forEach(product -> {
            System.out.println(product.id());

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingApplicationTest.java
================
public class CryptoTradingApplicationTest {
    private static final Network network = Network.newNetwork();
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {
            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    void healthLivenessEndpointShouldBeEnabled() {
                .uri("/actuator/health/liveness")
    void contextLoads() throws IOException {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        try (Consumer<String, AkcesControlRecord> controlConsumer = controlConsumerFactory.createConsumer("Test-AkcesControl", "test-akces-control")) {
            TopicPartition controlPartition = new TopicPartition("Akces-Control", 0);
            controlConsumer.assign(List.of(controlPartition));
            controlConsumer.seekToBeginning(controlConsumer.assignment());
            Map<TopicPartition, Long> endOffsets = controlConsumer.endOffsets(controlConsumer.assignment());
            while (endOffsets.getOrDefault(controlPartition, 0L) > controlConsumer.position(controlPartition)) {
                ConsumerRecords<String, AkcesControlRecord> controlRecords = controlConsumer.poll(Duration.ofMillis(1000));
                if (!controlRecords.isEmpty()) {
                    for (ConsumerRecord<String, AkcesControlRecord> record : controlRecords.records(controlPartition)) {
                        if (record.value() instanceof AggregateServiceRecord aggregateServiceRecord) {
                            System.out.println(objectMapper.writeValueAsString(aggregateServiceRecord));
                            serviceRecords.put(record.key(), aggregateServiceRecord);
            Assertions.assertEquals(4, serviceRecords.size());
    void testCreateAllEURMarketsAndMakeATrade() {
        akcesClientController.sendAndForget("TEST",
                new CreateAccountCommand(counterPartyId,
        Product product = coinbaseService.getProduct("BTC-EUR");
        akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
                product.id(),
                product.baseCurrency(),
                product.quoteCurrency(),
                product.baseIncrement(),
                product.quoteIncrement(),
        Mono.fromCompletionStage(akcesClientController.send("TEST", new CreateAccountCommand(accountId,
                "john.doe@example.com"))).block();
        Mono.fromCompletionStage(akcesClientController.send("TEST",
                new CreateBalanceCommand(accountId, "BTC"))).block();
                new CreditWalletCommand(accountId,
                        new BigDecimal("1000")))).block();
                new PlaceBuyOrderCommand(accountId,
                        new CryptoMarket("BTC-EUR", "BTC", "EUR"),
                        new BigDecimal("250"),
                        clientOrderId))).block();
                Consumer<String, ProtocolRecord> testConsumer = consumerFactory.createConsumer("Test", "test")
            testConsumer.subscribe(Pattern.compile(".*-DomainEvents$"), new ConsumerRebalanceListener() {
                public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                    testConsumer.seekToBeginning(partitions);
                for (ConsumerRecord<String, ProtocolRecord> record : testConsumer.poll(Duration.ofMillis(100))) {
                    System.out.println(record.topic() + " : " + record.value().name() + "=" + new String(record.value().payload()));
    public static class Initializer
        public void initialize(ConfigurableApplicationContext applicationContext) {
            prepareKafka(kafka.getBootstrapServers());
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
                throw new RuntimeException(e);
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "retention.ms", Long.toString(retentionMs),
    private static NewTopic createCompactedTopic(String name, int numPartitions) {
    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            controlProducer.commitTransaction();

================
File: crypto-trading/aggregates/src/test/resources/akces-client.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/aggregates/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/aggregates/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.0-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-aggregates</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Aggregates</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-runtime</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>


    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <id>process-aot</id>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.AggregateConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>






                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.4.2</version>
                <executions>
                    <execution>
                        <id>commands-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>commands</classifier>
                            <includes>
                                <include>**/commands/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>events-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>events</classifier>
                            <includes>
                                <include>**/events/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>






        </plugins>
    </build>

</project>

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountInput.java
================
    public CreateAccountCommand toCommand(String userId) {
        return new CreateAccountCommand(userId, country(), firstName(), lastName(), email());

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountOutput.java
================


================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BalanceOutput.java
================
    public static BalanceOutput from(WalletCreditedEvent event) {
        return new BalanceOutput(event.id(), event.currency(), event.amount(), event.balance());
    public static BalanceOutput from(BalanceCreatedEvent event) {
        return new BalanceOutput(event.id(), event.currency(), BigDecimal.ZERO, BigDecimal.ZERO);

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreateBalanceInput.java
================
    public CreateBalanceCommand toCommand(String walletId) {
        return new CreateBalanceCommand(walletId, this.currency);

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreditWalletInput.java
================
    public CreditWalletCommand toCommand(String userId, String currency) {
        return new CreditWalletCommand(userId, currency, amount);

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderInput.java
================


================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventException.java
================
public class ErrorEventException extends RuntimeException {
    public ErrorEvent getErrorEvent() {

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventResponse.java
================


================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/GlobalExceptionHandler.java
================
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    protected ResponseEntity<ErrorEventResponse> handleErrorEvent(ErrorEventException ex) {
        ErrorEvent errorEvent = ex.getErrorEvent();
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorEventResponse(errorEvent.getClass().getAnnotation(DomainEventInfo.class).type()));

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/AccountCommandController.java
================
public class AccountCommandController {
    public Mono<ResponseEntity<AccountOutput>> createAccount(@RequestBody AccountInput input) {
        String userId = UUID.randomUUID().toString();
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(userId)))
                .map(List::getFirst)
                .map(domainEvent -> {
                    AccountOutput output = new AccountOutput(event.userId(), input.country(), input.firstName(), input.lastName(), input.email());
                    return ResponseEntity.ok(output);

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/OrdersCommandController.java
================
public class OrdersCommandController {

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/WalletCommandController.java
================
public class WalletCommandController {
    public Mono<ResponseEntity<BalanceOutput>> creditBalance(@PathVariable("walletId") String walletId,
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId, currency)))
                .map(List::getFirst)
                .handle((domainEvent, sink) -> {
                        sink.next(ResponseEntity.ok(BalanceOutput.from((WalletCreditedEvent) domainEvent)));
                        sink.error(new ErrorEventException((ErrorEvent) domainEvent));
    public Mono<ResponseEntity<BalanceOutput>> createBalance(@PathVariable("walletId") String walletId, @RequestBody CreateBalanceInput input) {
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId)))
                        sink.next(ResponseEntity.ok(BalanceOutput.from(balanceCreatedEvent)));

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {

================
File: crypto-trading/commands/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/commands/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingCommandApiTest.java
================
public class CryptoTradingCommandApiTest {
    private static final Network network = Network.newNetwork();
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {
            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
    void contextLoads() {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();
        assertThat(accountWebController).isNotNull();
        assertThat(walletWebController).isNotNull();
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    void healthLivenessEndpointShouldBeEnabled() {
                .uri("/actuator/health/liveness")
    void testCreateAccount() {
        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
    void testCreateAccountAndCreditWallet() {
                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
                            .bodyValue(creditInput)
                            .expectBody(BalanceOutput.class)
                            .value(creditOutput -> {
                                assertThat(creditOutput).isNotNull();
                                assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
                                assertThat(creditOutput.currency()).isEqualTo("EUR");
    void testCreateAccountAndCreditWalletWithoutBalance() {
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
                            .expectStatus().is4xxClientError()
                            .expectBody(ErrorEventResponse.class)
                            .value(response -> {
                                assertThat(response).isNotNull();
                                assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
    void testCreateAccountAndAddBtcBalance() {
                    CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances")
                            .bodyValue(createBalanceInput)
                            .expectStatus().is2xxSuccessful();
    void testInvalidApiVersion() {
                .uri("/v13/accounts/invalid-id")
                .expectStatus().isNotFound();
    public static class Initializer
        public void initialize(ConfigurableApplicationContext applicationContext) {
            prepareKafka(kafka.getBootstrapServers());
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
                throw new RuntimeException(e);
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "retention.ms", Long.toString(retentionMs),
    private static NewTopic createCompactedTopic(String name, int numPartitions) {
    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            controlProducer.commitTransaction();

================
File: crypto-trading/commands/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/commands/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.0-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-commands</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Command Service</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>provided</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.4.2</version>
                <executions>
                    <execution>
                        <id>shared-web-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>shared-web</classifier>
                            <includes>
                                <include>**/dto/*</include>
                                <include>**/errors/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModel.java
================
public class AccountQueryModel implements QueryModel<AccountQueryModelState> {
    public String getName() {
    public Class<AccountQueryModelState> getStateClass() {
    public String getIndexName() {
    public AccountQueryModelState create(AccountCreatedEvent event, AccountQueryModelState isNull) {
        return new AccountQueryModelState(
                event.userId(),
                event.country(),
                event.firstName(),
                event.lastName(),
                event.email());

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModelState.java
================
                                     @NotNull @PIIData String email) implements QueryModelState {
    public String getIndexKey() {
        return accountId();

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModel.java
================
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    public String getName() {
    public Class<WalletQueryModelState> getStateClass() {
    public String getIndexName() {
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        return new WalletQueryModelState(event.id(), List.of());
    public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState currentState) {
        WalletQueryModelState.Balance balance = new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO);
        List<WalletQueryModelState.Balance> balances = new ArrayList<>(currentState.balances());
        balances.add(balance);
        return new WalletQueryModelState(currentState.walletId(), balances);
    public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState currentState) {
        return new WalletQueryModelState(
                currentState.walletId(),
                currentState.balances().stream().map(balance -> {
                    if (balance.currency().equals(event.currency())) {
                                balance.currency(),
                                balance.amount().add(event.amount()),
                                balance.reservedAmount()
                }).toList());

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModelState.java
================
public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
    public String getIndexKey() {
        return walletId();
        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/AccountQueryController.java
================
public class AccountQueryController {
    Mono<ResponseEntity<AccountOutput>> getAccount(@PathVariable("accountId") String accountId) {
        return Mono.fromCompletionStage(queryModels.getHydratedState(AccountQueryModel.class, accountId))
            .map(state -> ResponseEntity.ok(new AccountOutput(state.accountId(),
                    state.country(),
                    state.firstName(),
                    state.lastName(),
                    state.email()))).onErrorResume(throwable -> {
                            return Mono.just(ResponseEntity.notFound().build());
                            return Mono.just(ResponseEntity.internalServerError().build());

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/WalletQueryController.java
================
public class WalletQueryController {
    Mono<ResponseEntity<WalletQueryModelState>> getWallet(@PathVariable("walletId") String walletId) {
        return Mono.fromCompletionStage(queryModels.getHydratedState(WalletQueryModel.class, walletId))
            .map(ResponseEntity::ok)
            .onErrorResume(throwable -> {
                    return Mono.just(ResponseEntity.notFound().build());
                    return Mono.just(ResponseEntity.internalServerError().build());

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {

================
File: crypto-trading/queries/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingE2ETests.java
================
public class CryptoTradingE2ETests {
    private final WebTestClient e2eTestClient = WebTestClient.bindToServer()
            .baseUrl(System.getenv("AKCES_CRYPTO_TRADING_BASE_URL"))
            .build();
    public void testCreateAndReadAccount() {
        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        String userId = e2eTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
                }).returnResult().getResponseBody().userId();
        System.out.println("Created account with userId: " + userId);
        e2eTestClient.get()
                .uri("/v1/accounts/" + userId)
                .value(retrievedAccount -> {
                    assertThat(retrievedAccount).isNotNull();
                    assertThat(retrievedAccount.userId()).isEqualTo(userId);
                    assertThat(retrievedAccount.country()).isEqualTo("NL");
                    assertThat(retrievedAccount.firstName()).isEqualTo("John");
                    assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
                    assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
    public void testBuyCrypto() {
        AccountInput accountInput = new AccountInput("NL", "Some", "CryptoTrader", "some.cryptotrader@example.com");
        e2eTestClient.post()
                .uri("/v1/wallets/{userId}/balances", userId)
                .bodyValue(new CreateBalanceInput("ETH"))
                .expectBody(BalanceOutput.class)
                .value(balanceOutput -> {
                    assertThat(balanceOutput).isNotNull();
                    assertThat(balanceOutput.currency()).isEqualTo("ETH");
                    assertThat(balanceOutput.amount()).isEqualTo(BigDecimal.ZERO);
                .uri("/v1/wallets/{userId}/balances/EUR/credit", userId)
                .bodyValue(new CreditWalletInput(new BigDecimal("1000.00")))
                    assertThat(balanceOutput.currency()).isEqualTo("EUR");
                    assertThat(balanceOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
                    assertThat(balanceOutput.balance()).isEqualTo(new BigDecimal("1000.00"));

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingQueryApiTest.java
================
public class CryptoTradingQueryApiTest {
    private static final Network network = Network.newNetwork();
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {
            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
    void contextLoads() {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();
        assertThat(accountWebController).isNotNull();
        assertThat(walletWebController).isNotNull();
        assertThat(accountQueryController).isNotNull();
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    void healthLivenessEndpointShouldBeEnabled() {
                .uri("/actuator/health/liveness")
    void testCreateAccount() {
        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
    void testCreateAccountAndCreditWallet() {
                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
                            .bodyValue(creditInput)
                            .expectBody(BalanceOutput.class)
                            .value(creditOutput -> {
                                assertThat(creditOutput).isNotNull();
                                assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
                                assertThat(creditOutput.currency()).isEqualTo("EUR");
    void testCreateAccountAndCreditWalletWithoutBalance() {
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
                            .expectStatus().is4xxClientError()
                            .expectBody(ErrorEventResponse.class)
                            .value(response -> {
                                assertThat(response).isNotNull();
                                assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
    void testCreateAccountAndAddBtcBalance() {
                    CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances")
                            .bodyValue(createBalanceInput)
                            .expectStatus().is2xxSuccessful();
    void testGetAccount() {
        AccountInput accountInput = new AccountInput("US", "John", "Doe", "john.doe@example.com");
                            .uri("/v1/accounts/" + accountOutput.userId())
                            .value(retrievedAccount -> {
                                assertThat(retrievedAccount).isNotNull();
                                assertThat(retrievedAccount.userId()).isEqualTo(accountOutput.userId());
                                assertThat(retrievedAccount.country()).isEqualTo("US");
                                assertThat(retrievedAccount.firstName()).isEqualTo("John");
                                assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
                                assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
    void testInvalidApiVersion() {
                .uri("/v13/accounts/invalid-id")
                .expectStatus().isNotFound();
    public static class Initializer
        public void initialize(ConfigurableApplicationContext applicationContext) {
            prepareKafka(kafka.getBootstrapServers());
            prepareDomainEventSchemas(
                    "http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
                    List.of(AccountCreatedEvent.class,
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
                throw new RuntimeException(e);
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "retention.ms", Long.toString(retentionMs),
    private static NewTopic createCompactedTopic(String name, int numPartitions) {
    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            controlProducer.commitTransaction();
    public static void prepareDomainEventSchemas(String url, List<Class<? extends DomainEvent>> domainEventClasses) {
        SchemaRegistryClient src = new CachedSchemaRegistryClient(url, 100);
        Jackson2ObjectMapperBuilder objectMapperBuilder = new Jackson2ObjectMapperBuilder();
        objectMapperBuilder.modulesToInstall(new AkcesGDPRModule());
        objectMapperBuilder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        SchemaGeneratorConfigBuilder configBuilder = new SchemaGeneratorConfigBuilder(objectMapperBuilder.build(),
        configBuilder.with(new JakartaValidationModule(JakartaValidationOption.INCLUDE_PATTERN_EXPRESSIONS,
        configBuilder.with(new JacksonModule());
        configBuilder.with(Option.FORBIDDEN_ADDITIONAL_PROPERTIES_BY_DEFAULT);
        configBuilder.with(Option.NULLABLE_FIELDS_BY_DEFAULT);
        configBuilder.with(Option.NULLABLE_METHOD_RETURN_VALUES_BY_DEFAULT);
        configBuilder.forTypesInGeneral().withTypeAttributeOverride((collectedTypeAttributes, scope, context) -> {
            if (scope.getType().getTypeName().equals("java.math.BigDecimal")) {
                JsonNode typeNode = collectedTypeAttributes.get("type");
                if (typeNode.isArray()) {
                    ((ArrayNode) collectedTypeAttributes.get("type")).set(0, "string");
                    collectedTypeAttributes.put("type", "string");
        SchemaGeneratorConfig config = configBuilder.build();
        SchemaGenerator jsonSchemaGenerator = new SchemaGenerator(config);
                DomainEventInfo info = domainEventClass.getAnnotation(DomainEventInfo.class);
                src.register("domainevents." + info.type(),
                        new JsonSchema(jsonSchemaGenerator.generateSchema(domainEventClass), List.of(), Map.of(), info.version()),
                        info.version(),
            throw new ApplicationContextException("Problem populating SchemaRegistry", e);

================
File: crypto-trading/queries/src/test/resources/application-test.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/queries/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/queries/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.0-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-queries</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Query Service</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-query-support</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <classifier>shared-web</classifier>
            <version>${project.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.elasticsoftwarefoundation.akces</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: crypto-trading/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-test-apps</artifactId>
        <version>0.8.0-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-parent</artifactId>
    <packaging>pom</packaging>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <modules>
        <module>aggregates</module>
        <module>commands</module>
        <module>queries</module>
    </modules>

    <build>
        <plugins>

        </plugins>
    </build>

</project>

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-parent</artifactId>
        <version>0.8.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>akces-framework-test-apps</artifactId>
    <packaging>pom</packaging>

    <name>Elastic Software Foundation :: Akces :: Test Apps</name>
    <url>https://github.com/elasticsoftwarefoundation/akces-framework</url>

    <properties>
        <akces-framework.version>${project.version}</akces-framework.version>
    </properties>

    <repositories>
        <repository>
            <id>github</id>
            <name>Akces Github Packages Repository</name>
            <url>https://github.com/elasticsoftwarefoundation/akces-framework/packages</url>
        </repository>
        <repository>
            <id>central</id>
            <name>Maven Central</name>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
    </repositories>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-api</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-shared</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-runtime</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-client</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-query-support</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava-bom</artifactId>
                <version>${guava.version}</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>com.github.ben-manes.caffeine</groupId>
                <artifactId>caffeine</artifactId>
                <version>${caffeine.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>com.google.errorprone</groupId>
                        <artifactId>error_prone_annotations</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <modules>
        <module>crypto-trading</module>
    </modules>
    <build>
        <plugins>
            <plugin>

                <artifactId>maven-deploy-plugin</artifactId>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <profile>
            <id>maven-release</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <configuration>
                            <docker>
                                <publishRegistry>
                                    <username>${env.GITHUB_ACTOR}</username>
                                    <password>${env.GITHUB_TOKEN}</password>
                                    <url>docker://ghcr.io</url>
                                </publishRegistry>
                            </docker>
                            <image>
                                <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}</name>
                                <publish>true</publish>
                                <env>
                                    <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                    <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    <BP_SPRING_AOT_ENABLED>true</BP_SPRING_AOT_ENABLED>
                                    <BP_JVM_CDS_ENABLED>true</BP_JVM_CDS_ENABLED>
                                    <JAVA_TOOL_OPTIONS>-XX:+UseZGC -XX:+ZGenerational</JAVA_TOOL_OPTIONS>
                                </env>
                                <buildpacks>
                                    <buildpack>gcr.io/paketo-buildpacks/ca-certificates</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/adoptium:latest</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/syft</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/executable-jar</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/spring-boot</buildpack>
                                </buildpacks>
                            </image>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>process-aot</goal>
                                </goals>
                                <configuration>

                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>native</id>
            <build>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-jar-plugin</artifactId>
                            <configuration>
                                <archive>
                                    <manifestEntries>
                                        <Spring-Boot-Native-Processed>true</Spring-Boot-Native-Processed>
                                    </manifestEntries>
                                </archive>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                            <executions>
                                <execution>
                                    <id>process-aot</id>
                                    <goals>
                                        <goal>process-aot</goal>
                                    </goals>
                                </execution>
                            </executions>
                            <configuration>
                                <docker>
                                    <publishRegistry>
                                        <username>${env.GITHUB_ACTOR}</username>
                                        <password>${env.GITHUB_TOKEN}</password>
                                        <url>docker://ghcr.io</url>
                                    </publishRegistry>
                                </docker>
                                <image>
                                    <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                    <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                    <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}
                                    </name>
                                    <publish>true</publish>
                                    <env>
                                        <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                        <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    </env>
                                </image>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.graalvm.buildtools</groupId>
                            <artifactId>native-maven-plugin</artifactId>
                            <configuration>
                                <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                                <requiredVersion>22.3</requiredVersion>
                            </configuration>
                            <executions>
                                <execution>
                                    <id>add-reachability-metadata</id>
                                    <goals>
                                        <goal>add-reachability-metadata</goal>
                                    </goals>
                                </execution>
                                <execution>
                                    <id>build-native</id>
                                    <goals>
                                        <goal>compile-no-fork</goal>
                                    </goals>
                                    <phase>package</phase>
                                </execution>
                            </executions>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
        <profile>
            <id>nativeTest</id>
            <dependencies>
                <dependency>
                    <groupId>org.junit.platform</groupId>
                    <artifactId>junit-platform-launcher</artifactId>
                    <scope>test</scope>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>process-test-aot</id>
                                <goals>
                                    <goal>process-test-aot</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <configuration>
                            <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                            <requiredVersion>22.3</requiredVersion>
                        </configuration>
                        <executions>
                            <execution>
                                <id>native-test</id>
                                <goals>
                                    <goal>test</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>



================================================================
End of Codebase
================================================================
