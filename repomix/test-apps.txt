This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where comments have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.md, test-apps/**/*.java, test-apps/**/*.xml, test-apps/**/*.properties, test-apps/**/*.proto, test-apps/**/*.imports, test-apps/**/*.yaml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
test-apps/
  crypto-trading/
    aggregates/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  aggregates/
                    account/
                      commands/
                        CreateAccountCommand.java
                      events/
                        AccountCreatedEvent.java
                      Account.java
                      AccountState.java
                    cryptomarket/
                      commands/
                        CreateCryptoMarketCommand.java
                        PlaceMarketOrderCommand.java
                      data/
                        Side.java
                      events/
                        CryptoMarketCreatedEvent.java
                        MarketOrderFilledEvent.java
                        MarketOrderPlacedEvent.java
                        MarketOrderRejectedErrorEvent.java
                      CryptoMarket.java
                      CryptoMarketState.java
                    orders/
                      commands/
                        FillBuyOrderCommand.java
                        PlaceBuyOrderCommand.java
                        RejectOrderCommand.java
                      data/
                        CryptoMarket.java
                      events/
                        BuyOrderCreatedEvent.java
                        BuyOrderFilledEvent.java
                        BuyOrderPlacedEvent.java
                        BuyOrderRejectedEvent.java
                        UserOrderProcessesCreatedEvent.java
                      BuyOrderProcess.java
                      OrderProcess.java
                      OrderProcessManager.java
                      OrderProcessManagerState.java
                      OrderProcessState.java
                    wallet/
                      commands/
                        CancelReservationCommand.java
                        CreateBalanceCommand.java
                        CreateWalletCommand.java
                        CreditWalletCommand.java
                        DebitWalletCommand.java
                        ReserveAmountCommand.java
                      events/
                        AmountReservedEvent.java
                        BalanceAlreadyExistsErrorEvent.java
                        BalanceCreatedEvent.java
                        InsufficientFundsErrorEvent.java
                        InvalidAmountErrorEvent.java
                        InvalidCryptoCurrencyErrorEvent.java
                        ReservationCancelledEvent.java
                        ReservationNotFoundErrorEvent.java
                        WalletCreatedEvent.java
                        WalletCreditedEvent.java
                        WalletDebitedEvent.java
                      Wallet.java
                      WalletState.java
                      WalletStateV2.java
                  services/
                    coinbase/
                      CoinbaseService.java
                      Order.java
                      Product.java
                      Ticker.java
                  AggregateConfig.java
          resources/
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CoinbaseMarketDataTest.java
                  CoinbaseServiceTest.java
                  CryptoTradingApplicationTest.java
                  TestUtils.java
          resources/
            akces-client.properties
            logback-test.xml
      pom.xml
    commands/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  web/
                    dto/
                      AccountInput.java
                      AccountOutput.java
                      BalanceOutput.java
                      BuyOrderInput.java
                      CreateBalanceInput.java
                      CreditWalletInput.java
                      OrderInput.java
                      OrderOutput.java
                    errors/
                      ErrorEventException.java
                      ErrorEventResponse.java
                      GlobalExceptionHandler.java
                    AccountCommandController.java
                    OrdersCommandController.java
                    WalletCommandController.java
                  ClientConfig.java
          resources/
            akces-framework.properties
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CryptoTradingCommandApiTest.java
                  TestUtils.java
          resources/
            logback-test.xml
      pom.xml
    eventcatalog/
      domains/
        Accounts/
          services/
            AccountApiService/
              openapi.yaml
    queries/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  query/
                    jdbc/
                      CryptoMarket.java
                      CryptoMarketRepository.java
                    AccountQueryModel.java
                    AccountQueryModelState.java
                    CryptoMarketModel.java
                    WalletQueryModel.java
                    WalletQueryModelState.java
                  services/
                    CryptoMarketsService.java
                  web/
                    AccountQueryController.java
                    CryptoMarketsQueryController.java
                    WalletQueryController.java
                  ClientConfig.java
          resources/
            db/
              changelog/
                db.changelog-master.xml
            akces-framework.properties
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CryptoTradingE2ETests.java
                  CryptoTradingQueryApiTest.java
                  TestUtils.java
          resources/
            application-test.properties
            logback-test.xml
      pom.xml
    pom.xml
  pom.xml
FRAMEWORK_OVERVIEW.md
README.md
RELEASE.md
SERVICES.md
TEST-APPS.md

================================================================
Files
================================================================

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/AccountState.java
================
@NotNull @PIIData String email) implements AggregateState {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/CryptoMarketCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderRejectedErrorEvent.java
================
@NotNull String rejectionReason) implements ErrorEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarketState.java
================
) implements AggregateState {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/RejectOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderRejectedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/UserOrderProcessesCreatedEvent.java
================
public record UserOrderProcessesCreatedEvent(@NotNull @AggregateIdentifier String userId) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateBalanceCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateWalletCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreditWalletCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/ReserveAmountCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/AmountReservedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceAlreadyExistsErrorEvent.java
================
@NotNull String currency) implements ErrorEvent {
⋮----
public String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InsufficientFundsErrorEvent.java
================
) implements ErrorEvent {
⋮----
public @NotNull String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidAmountErrorEvent.java
================
) implements ErrorEvent {
⋮----
public @NotNull String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidCryptoCurrencyErrorEvent.java
================
) implements ErrorEvent {
⋮----
public String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreditedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/WalletState.java
================
) implements AggregateState {
⋮----
public String getAggregateId() {
return id();
⋮----
public BigDecimal getAvailableAmount() {
return amount.subtract(reservedAmount);

================
File: test-apps/crypto-trading/aggregates/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading Command Service
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseMarketDataTest.java
================
public class CoinbaseMarketDataTest {
⋮----
void testCoinbaseGetProducts() {
WebClient webClient = WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();
⋮----
String response = webClient.get()
.uri("/products")
.retrieve()
.bodyToMono(String.class)
.block();
⋮----
System.out.println(response);
⋮----
void testCoinbaseGetSingleProduct() {
⋮----
.uri("/products/BTC-EUR")
⋮----
void testGetCoinbaseTicker() {
⋮----
.uri("/products/BTC-EUR/ticker")

================
File: test-apps/crypto-trading/aggregates/src/test/resources/akces-client.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/aggregates/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountInput.java
================
public CreateAccountCommand toCommand(String userId) {
return new CreateAccountCommand(userId, country(), firstName(), lastName(), email());

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountOutput.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreateBalanceInput.java
================
public CreateBalanceCommand toCommand(String walletId) {
return new CreateBalanceCommand(walletId, this.currency);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreditWalletInput.java
================
public CreditWalletCommand toCommand(String userId, String currency) {
return new CreditWalletCommand(userId, currency, amount);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventException.java
================
public class ErrorEventException extends RuntimeException {
⋮----
public ErrorEvent getErrorEvent() {

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventResponse.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/GlobalExceptionHandler.java
================
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
⋮----
protected ResponseEntity<ErrorEventResponse> handleErrorEvent(ErrorEventException ex) {
ErrorEvent errorEvent = ex.getErrorEvent();
return ResponseEntity.status(HttpStatus.BAD_REQUEST)
.body(new ErrorEventResponse(errorEvent.getClass().getAnnotation(DomainEventInfo.class).type()));

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/AccountCommandController.java
================
public class AccountCommandController {
⋮----
public Mono<ResponseEntity<AccountOutput>> createAccount(@RequestBody AccountInput input) {
String userId = UUID.randomUUID().toString();
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(userId)))
.map(List::getFirst)
.map(domainEvent -> {
⋮----
AccountOutput output = new AccountOutput(event.userId(), input.country(), input.firstName(), input.lastName(), input.email());
return ResponseEntity.ok(output);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {

================
File: test-apps/crypto-trading/commands/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/commands/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: test-apps/crypto-trading/commands/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModel.java
================
public class AccountQueryModel implements QueryModel<AccountQueryModelState> {
⋮----
public String getName() {
⋮----
public Class<AccountQueryModelState> getStateClass() {
⋮----
public String getIndexName() {
⋮----
public AccountQueryModelState create(AccountCreatedEvent event, AccountQueryModelState isNull) {
return new AccountQueryModelState(
event.userId(),
event.country(),
event.firstName(),
event.lastName(),
event.email());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModelState.java
================
@NotNull @PIIData String email) implements QueryModelState {
⋮----
public String getIndexKey() {
return accountId();

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/AccountQueryController.java
================
public class AccountQueryController {
⋮----
Mono<ResponseEntity<AccountOutput>> getAccount(@PathVariable("accountId") String accountId) {
return Mono.fromCompletionStage(queryModels.getHydratedState(AccountQueryModel.class, accountId))
.map(state -> ResponseEntity.ok(new AccountOutput(state.accountId(),
state.country(),
state.firstName(),
state.lastName(),
state.email()))).onErrorResume(throwable -> {
⋮----
return Mono.just(ResponseEntity.notFound().build());
⋮----
return Mono.just(ResponseEntity.internalServerError().build());

================
File: test-apps/crypto-trading/queries/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/commands/CreateAccountCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/events/AccountCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/Account.java
================
public final class Account implements Aggregate<AccountState> {
⋮----
public String getName() {
⋮----
public Class<AccountState> getStateClass() {
⋮----
public Stream<AccountCreatedEvent> create(CreateAccountCommand cmd, AccountState isNull) {
return Stream.of(new AccountCreatedEvent(cmd.userId(), cmd.country(), cmd.firstName(), cmd.lastName(), cmd.email()));
⋮----
public AccountState create(@NotNull AccountCreatedEvent event, AccountState isNull) {
return new AccountState(event.userId(), event.country(), event.firstName(), event.lastName(), event.email());

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/CreateCryptoMarketCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/data/Side.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/FillBuyOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/PlaceBuyOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/data/CryptoMarket.java
================
public static CryptoMarket fromId(String id) {
String[] split = id.split("-");
return new CryptoMarket(id, split[0], split[1]);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return orderId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderFilledEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessState.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CancelReservationCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/DebitWalletCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/ReservationCancelledEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/ReservationNotFoundErrorEvent.java
================
) implements ErrorEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletDebitedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/WalletStateV2.java
================
) implements AggregateState {
⋮----
public String getAggregateId() {
return id();
⋮----
this(currency, BigDecimal.ZERO, List.of());
⋮----
this(currency, amount, List.of());
⋮----
public BigDecimal getAvailableAmount() {
return amount.subtract(reservations().stream().map(Reservation::amount).reduce(BigDecimal.ZERO, BigDecimal::add));
⋮----
if (amount.compareTo(BigDecimal.ZERO) <= 0) {
throw new IllegalArgumentException("Reservation amount must be positive");

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/CoinbaseService.java
================
public class CoinbaseService {
⋮----
public Ticker getTicker(String productId) {
return webClient.get()
.uri("/products/{productId}/ticker", productId)
.retrieve()
.bodyToMono(Ticker.class)
.block();
⋮----
public Product getProduct(String productId) {
⋮----
.uri("/products/{productId}", productId)
⋮----
.bodyToMono(Product.class)
⋮----
public List<Product> getProducts() {
⋮----
.uri("/products")
⋮----
.bodyToFlux(Product.class)
.collectList()

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Order.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Product.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Ticker.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/AggregateConfig.java
================
public class AggregateConfig {
⋮----
public WebClient coinbaseWebClient() {
return WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseServiceTest.java
================
public class CoinbaseServiceTest {
⋮----
public void testGetProductById() {
⋮----
Product product = coinbaseService.getProduct(productId);
assertNotNull(product, "Product should not be null");
⋮----
public void testGetTickerById() {
⋮----
Ticker ticker = coinbaseService.getTicker(productId);
assertNotNull(ticker, "Ticker should not be null");
⋮----
public void testGetProducts() {
List<Product> products = coinbaseService.getProducts();
assertNotNull(products, "Products should not be null");
products.forEach(product -> {
System.out.println(product.id());

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BalanceOutput.java
================
public static BalanceOutput from(WalletCreditedEvent event) {
return new BalanceOutput(event.id(), event.currency(), event.amount(), event.balance());
⋮----
public static BalanceOutput from(BalanceCreatedEvent event) {
return new BalanceOutput(event.id(), event.currency(), BigDecimal.ZERO, BigDecimal.ZERO);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/WalletCommandController.java
================
public class WalletCommandController {
⋮----
public Mono<ResponseEntity<BalanceOutput>> creditBalance(@PathVariable("walletId") String walletId,
⋮----
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId, currency)))
.map(List::getFirst)
.handle((domainEvent, sink) -> {
⋮----
sink.next(ResponseEntity.ok(BalanceOutput.from((WalletCreditedEvent) domainEvent)));
⋮----
sink.error(new ErrorEventException((ErrorEvent) domainEvent));
⋮----
public Mono<ResponseEntity<BalanceOutput>> createBalance(@PathVariable("walletId") String walletId, @RequestBody CreateBalanceInput input) {
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId)))
⋮----
sink.next(ResponseEntity.ok(BalanceOutput.from(balanceCreatedEvent)));

================
File: test-apps/crypto-trading/eventcatalog/domains/Accounts/services/AccountApiService/openapi.yaml
================
openapi: 3.1.0
info:
  title: Account API
  description: API for managing accounts and retrieving account information
  version: 1.0.0
  contact:
    name: Elastic Software Foundation
servers:
  - url: /v1
    description: Version 1 API
paths:
  /accounts:
    post:
      summary: Create a new account
      description: Creates a new user account with the provided information
      operationId: createAccount
      tags:
        - accounts
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AccountInput'
      responses:
        '200':
          description: Account created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AccountOutput'
        '400':
          description: Invalid request parameters
        '500':
          description: Internal server error
  /accounts/{accountId}:
    get:
      summary: Get account details
      description: Retrieves the details of a specific account by its ID
      operationId: getAccount
      tags:
        - accounts
      parameters:
        - name: accountId
          in: path
          required: true
          description: The unique identifier of the account
          schema:
            type: string
      responses:
        '200':
          description: Account details retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AccountOutput'
        '404':
          description: Account not found
        '500':
          description: Internal server error
components:
  schemas:
    AccountInput:
      type: object
      properties:
        country:
          type: string
          description: The country code for the user's location
          example: "US"
        firstName:
          type: string
          description: The user's first name
          example: "John"
        lastName:
          type: string
          description: The user's last name
          example: "Doe"
        email:
          type: string
          format: email
          description: The user's email address
          example: "john.doe@example.com"
      required:
        - country
        - firstName
        - lastName
        - email
    AccountOutput:
      type: object
      properties:
        accountId:
          type: string
          description: The unique identifier of the account
          example: "123e4567-e89b-12d3-a456-426614174000"
        country:
          type: string
          description: The country code for the user's location
          example: "US"
        firstName:
          type: string
          description: The user's first name
          example: "John"
        lastName:
          type: string
          description: The user's last name
          example: "Doe"
        email:
          type: string
          format: email
          description: The user's email address
          example: "john.doe@example.com"
      required:
        - accountId
        - country
        - firstName
        - lastName
        - email

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/jdbc/CryptoMarketRepository.java
================
public interface CryptoMarketRepository extends ListCrudRepository<CryptoMarket,String> {

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModel.java
================
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
⋮----
public String getName() {
⋮----
public Class<WalletQueryModelState> getStateClass() {
⋮----
public String getIndexName() {
⋮----
public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
return new WalletQueryModelState(event.id(), List.of());
⋮----
public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState currentState) {
WalletQueryModelState.Balance balance = new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO);
List<WalletQueryModelState.Balance> balances = new ArrayList<>(currentState.balances());
balances.add(balance);
return new WalletQueryModelState(currentState.walletId(), balances);
⋮----
public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState currentState) {
return new WalletQueryModelState(
currentState.walletId(),
currentState.balances().stream().map(balance -> {
if (balance.currency().equals(event.currency())) {
⋮----
balance.currency(),
balance.amount().add(event.amount()),
balance.reservedAmount()
⋮----
}).toList());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModelState.java
================
public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
⋮----
public String getIndexKey() {
return walletId();
⋮----
public BigDecimal getAvailableAmount() {
return amount.subtract(reservedAmount);

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/CryptoMarketsQueryController.java
================
public class CryptoMarketsQueryController {
⋮----
public Flux<CryptoMarket> getAllMarkets() {
return Flux.fromIterable(cryptoMarketsService.getAllMarkets());
⋮----
public Mono<ResponseEntity<CryptoMarket>> getMarketById(@PathVariable String marketId) {
return Mono.justOrEmpty(cryptoMarketsService.getMarketById(marketId))
.map(ResponseEntity::ok)
.defaultIfEmpty(ResponseEntity.notFound().build());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/WalletQueryController.java
================
public class WalletQueryController {
⋮----
Mono<ResponseEntity<WalletQueryModelState>> getWallet(@PathVariable("walletId") String walletId) {
return Mono.fromCompletionStage(queryModels.getHydratedState(WalletQueryModel.class, walletId))
.map(ResponseEntity::ok)
.onErrorResume(throwable -> {
⋮----
return Mono.just(ResponseEntity.notFound().build());
⋮----
return Mono.just(ResponseEntity.internalServerError().build());

================
File: test-apps/crypto-trading/queries/src/main/resources/db/changelog/db.changelog-master.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

    <changeSet id="create-partition-offsets-table" author="jwijgerd">
        <createTable tableName="partition_offsets">
            <column name="partition_id" type="varchar(255)">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="record_offset" type="bigint">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <rollback>
            <dropTable tableName="partition_offsets"/>
        </rollback>
    </changeSet>

    <changeSet id="1" author="jwijgerd">
        <createTable tableName="crypto_markets">
            <column name="id" type="varchar(255)">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="base_crypto" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="quote_crypto" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="base_increment" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="quote_increment" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="default_counter_party_id" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

</databaseChangeLog>

================
File: test-apps/crypto-trading/queries/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/queries/src/test/resources/application-test.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates
spring.main.allow-bean-definition-overriding=true

================
File: RELEASE.md
================
## Release process

This project uses the Maven Release Plugin and GitHub Actions to create releases.\
Just run `mvn release:prepare release:perform && git push` in the root to select the version to be released and create a
VCS tag.

GitHub Actions will
start [the build process](https://github.com/elasticsoftwarefoundation/akces-framework/actions/workflows/maven-publish.yml).

If successful, the build will be automatically published
to [Github Packages](https://maven.pkg.github.com/elasticsoftwarefoundation/akces-framework/).

================
File: SERVICES.md
================
# Akces Framework Services

## Overview

The Akces Framework provides a set of specialized services that implement the CQRS (Command Query Responsibility Segregation) and Event Sourcing patterns using Apache Kafka as the underlying infrastructure. This document describes the main services in the framework and how they interact to form a complete event-driven architecture.

## Core Services Architecture

The Akces Framework consists of three main service types that work together:

1. **Command Services** - Handle commands and validate business logic
2. **Aggregate Services** - Maintain event-sourced state for domain entities
3. **Query Services** - Provide optimized read models for client applications

These services are managed by the Akces Operator, a Kubernetes operator that automates the deployment, scaling, and management of the Akces services in a Kubernetes environment.

## Akces Operator

The Akces Operator is a Kubernetes operator built using the Java Operator SDK that manages the lifecycle of Akces Framework services in a Kubernetes cluster.

### Features

- Automated deployment of Command, Aggregate, and Query services
- Kafka topic management (creation and configuration)
- State management for deployed services
- Resource scaling based on workload
- Configuration management

### Custom Resources

The operator defines three Custom Resource Definitions (CRDs):

#### 1. Aggregate

The Aggregate custom resource defines an Aggregate service that maintains the state of domain entities using event sourcing.

```yaml
apiVersion: akces.elasticsoftware.org/v1
kind: Aggregate
metadata:
  name: account-aggregate
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-aggregate-service:0.9.0
  aggregateNames:
    - Account
    - OrderProcessManager
    - Wallet
  applicationName: "Akces Account Aggregate Service"
  enableSchemaOverwrites: false
  args:
    - "--spring.profiles.active=prod"
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
```

#### 2. CommandService

The CommandService custom resource defines a Command service that validates and processes commands before sending them to the appropriate aggregate.

```yaml
apiVersion: akces.elasticsoftware.org/v1
kind: CommandService
metadata:
  name: account-command
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-command-service:0.9.0
  applicationName: "Akces Account Command Service"
  args:
    - "--spring.profiles.active=prod"
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
```

#### 3. QueryService

The QueryService custom resource defines a Query service that provides optimized read models for client applications.

```yaml
apiVersion: akces.elasticsoftware.org/v1
kind: QueryService
metadata:
  name: account-query
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-query-service:0.9.0
  applicationName: "Akces Account Query Service"
  args:
    - "--spring.profiles.active=prod"
  env:
    - name: DB_HOST
      value: "postgres.default"
    - name: DB_PORT
      value: "5432"
  applicationProperties: |
    # Custom application properties
    spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/accounts
    spring.datasource.username=${DB_USER}
    spring.datasource.password=${DB_PASSWORD}
    spring.jpa.hibernate.ddl-auto=validate
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
```

### Reconciliation Process

For each custom resource, the operator:

1. Creates a ConfigMap with the service configuration
2. Deploys a StatefulSet to run the service instances
3. Creates a Service for network access
4. Manages Kafka topics required by the service
5. Updates the status of the resource based on the StatefulSet's status

## Service Details

### Aggregate Service

The Aggregate Service is responsible for:

- Processing commands received from the Command Service
- Maintaining the event-sourced state of domain aggregates
- Applying business logic through command handlers
- Emitting domain events to Kafka topics
- Storing state snapshots for efficient recovery

Key characteristics:
- Stateful service (requires persistent storage)
- Uses RocksDB for state storage
- Consumes and produces to Kafka topics
- Processes events in a strictly ordered fashion per aggregate

Configuration:
- Deployed with a PersistentVolumeClaim for state storage
- Configured with Kafka connection details
- Uses ZGC for efficient memory management
- Exposes health endpoints for monitoring

### Command Service

The Command Service is responsible for:

- Receiving commands from client applications
- Validating command structure and content
- Routing commands to the appropriate aggregate
- Managing command response handling
- Implementing schema validation using JSON Schema

Key characteristics:
- Stateless service
- Acts as the entry point for write operations
- Handles command validation and routing
- Provides synchronous and asynchronous APIs for clients

Configuration:
- Deployed without persistent storage
- Configured with Kafka connection details
- Exposes HTTP endpoints for client requests

### Query Service

The Query Service is responsible for:

- Building and maintaining read models from domain events
- Providing optimized views of domain data
- Serving queries from client applications
- Updating read models based on domain events

Key characteristics:
- Stateful service (requires persistent storage)
- Consumes domain events from Kafka topics
- Maintains query-optimized state
- Can integrate with traditional databases (SQL, NoSQL)

Configuration:
- Deployed with a PersistentVolumeClaim for state storage
- Can be configured with custom application properties
- Supports custom environment variables for database connections
- Exposes HTTP endpoints for client queries

## Kafka Topic Structure

The operator manages the following Kafka topics for each aggregate:

- `<AggregateName>-Commands` - Commands sent to the aggregate
- `<AggregateName>-DomainEvents` - Domain events emitted by the aggregate
- `<AggregateName>-AggregateState` - Compacted topic storing the latest state of each aggregate instance

Additionally, the framework uses the following system topics:

- `Akces-Control` - Control messages and metadata
- `Akces-CommandResponses` - Responses to commands (for client notification)
- `Akces-GDPRKeys` - Encryption keys for GDPR-protected data

## Deployment Patterns

The Akces services can be deployed in various patterns:

1. **Monolithic Deployment** - All three service types deployed together for simple applications
2. **Microservice Deployment** - Each aggregate type gets its own set of services
3. **Hybrid Deployment** - Command services handle multiple aggregates, while query services are specialized

## Configuration and Integration

### Spring Boot Integration

All Akces services are built on Spring Boot and provide:

- Health endpoints for monitoring
- Graceful shutdown
- Structured logging with Logback
- Support for configuration via properties files or environment variables

### Customization Options

Each service type can be customized:

- Custom application properties
- Environment variables
- Resource limits and requests
- Replica count for scaling
- Custom Docker images for domain-specific logic

### High Availability

The operator deploys services with:

- Multiple replicas for redundancy
- Affinity rules for distributing across nodes
- Probes for health checking
- Graceful shutdown handling

## Usage Examples

### Deploying a Complete CQRS System

To deploy a complete CQRS system for a domain, create instances of all three CRDs:

```yaml
# 1. Create the Aggregate Service
apiVersion: akces.elasticsoftware.org/v1
kind: Aggregate
metadata:
  name: wallet-aggregate
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-aggregate-service:0.9.0
  aggregateNames:
    - Wallet
  applicationName: "Wallet Aggregate Service"
  enableSchemaOverwrites: false

---
# 2. Create the Command Service
apiVersion: akces.elasticsoftware.org/v1
kind: CommandService
metadata:
  name: wallet-command
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-command-service:0.9.0
  applicationName: "Wallet Command Service"

---
# 3. Create the Query Service
apiVersion: akces.elasticsoftware.org/v1
kind: QueryService
metadata:
  name: wallet-query
spec:
  replicas: 3
  image: ghcr.io/elasticsoftwarefoundation/akces-query-service:0.9.0
  applicationName: "Wallet Query Service"
  applicationProperties: |
    spring.application.name=Wallet Query Service
    akces.querymodels.enabled=true
    akces.querymodels.packages=com.example.wallet.query
```

### Scaling Services

To scale a service, update the `replicas` field:

```yaml
apiVersion: akces.elasticsoftware.org/v1
kind: Aggregate
metadata:
  name: wallet-aggregate
spec:
  replicas: 5  # Increased from 3 to 5
  # other fields remain the same
```

### Accessing Service Information

The operator updates the status of each resource with information about the running service:

```bash
kubectl get aggregate wallet-aggregate -o yaml
```

Example output:
```yaml
apiVersion: akces.elasticsoftware.org/v1
kind: Aggregate
metadata:
  name: wallet-aggregate
spec:
  # [...]
status:
  readyReplicas: 3
```

## Best Practices

1. **Resource Planning**
   - Size CPU and memory resources based on the expected load
   - Monitor resource usage to adjust as needed

2. **Persistence**
   - Use SSDs or high-performance disks for state storage
   - In GCP, consider using Hyperdisk Balanced for optimal performance

3. **Scaling**
   - Horizontally scale services to match workload
   - Ensure Kafka partitions match or exceed service replica count

4. **Monitoring**
   - Set up monitoring for the health endpoints
   - Monitor Kafka lag to detect processing delays

5. **Backup**
   - Regular backups of Kafka topics are recommended
   - Implement disaster recovery plans for data safety

## Troubleshooting

Common issues and solutions:

1. **Service Not Starting**
   - Check ConfigMap exists and has correct format
   - Verify image pull secrets are configured
   - Check resource constraints

2. **Command Processing Issues**
   - Verify Kafka topics exist and are accessible
   - Check schema compatibility in Schema Registry
   - Review service logs for validation errors

3. **Query Service Not Updating**
   - Check Kafka consumer lag
   - Verify event handlers are correctly implemented
   - Check database connectivity if using external databases

4. **Performance Issues**
   - Tune Kafka parameters for performance
   - Adjust JVM settings via environment variables
   - Scale up resources or increase replicas

5. **Operator Issues**
   - Check operator logs for reconciliation errors
   - Verify RBAC permissions for the operator

## Conclusion

The Akces Framework services provide a complete implementation of CQRS and Event Sourcing patterns using Kafka as the backbone infrastructure. The Kubernetes operator simplifies the deployment and management of these services, allowing teams to focus on domain-specific implementations rather than infrastructure concerns.

By separating commands, aggregates, and queries into distinct services, the framework provides flexibility, scalability, and resilience while maintaining the integrity of the event-sourced data model.

================
File: TEST-APPS.md
================
# Akces Framework Test Applications

This document provides an overview of the test applications included in the Akces Framework repository. These applications demonstrate real-world usage patterns and implementation examples of the Akces Framework's CQRS (Command Query Responsibility Segregation) and Event Sourcing capabilities.

## Crypto Trading Application

The primary test application is a Crypto Trading platform that showcases how to build a distributed, event-driven system using the Akces Framework.

### Overview

The Crypto Trading application simulates a cryptocurrency trading platform where users can:

- Create accounts
- Manage crypto wallets with various currency balances
- Place market orders to buy cryptocurrencies
- View market information from exchanges (via Coinbase API integration)

The application demonstrates the full CQRS pattern with clear separation between commands (write operations) and queries (read operations), as well as event sourcing for maintaining complete audit trails and state reconstruction.

### Architecture

The application follows a modular architecture split into three main components:

1. **Aggregates Module** (`crypto-trading/aggregates`): Contains domain models, commands, events, and business logic
2. **Commands Module** (`crypto-trading/commands`): Provides API endpoints for write operations
3. **Queries Module** (`crypto-trading/queries`): Provides API endpoints for read operations and maintains query-optimized data models

### Key Aggregates

The application defines several key aggregates that demonstrate different aspects of domain modeling with Akces:

#### Account Aggregate

Represents a user account in the trading system:

- Creates new user accounts
- Stores basic user information including PII (Personally Identifiable Information) that is automatically protected through Akces's GDPR compliance features

```java
public final class Account implements Aggregate<AccountState> {
    public Stream<AccountCreatedEvent> create(CreateAccountCommand cmd, AccountState isNull) {
        return Stream.of(new AccountCreatedEvent(cmd.userId(), cmd.country(), 
                                               cmd.firstName(), cmd.lastName(), cmd.email()));
    }
}
```

#### Wallet Aggregate

Manages a user's cryptocurrency holdings:

- Creates wallets automatically when accounts are created
- Supports multiple currency balances within a wallet
- Handles crediting and debiting operations
- Implements reservation system for pending transactions
- Demonstrates state versioning/migration with `WalletState` and `WalletStateV2`

```java
public final class Wallet implements Aggregate<WalletStateV2> {
    public Stream<DomainEvent> credit(CreditWalletCommand cmd, WalletStateV2 currentState) {
        // Validation and business logic
        return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), 
                                               cmd.amount(), balance.amount().add(cmd.amount())));
    }
}
```

#### CryptoMarket Aggregate

Represents a trading market for a specific cryptocurrency pair:

- Creates market definitions with base and quote currencies
- Processes market orders
- Integrates with external Coinbase API for pricing
- Demonstrates external service integration

```java
public class CryptoMarket implements Aggregate<CryptoMarketState> {
    public Stream<DomainEvent> handle(PlaceMarketOrderCommand command, CryptoMarketState currentState) {
        // Market order processing logic with external API integration
        Ticker currentTicker = coinbaseService.getTicker(currentState.id());
        // Further processing...
    }
}
```

#### OrderProcessManager Aggregate

Demonstrates the Process Manager pattern for coordinating complex workflows:

- Orchestrates the full lifecycle of buy orders across multiple aggregates
- Reacts to events from different aggregates to advance the process
- Handles compensating transactions for failures
- Shows how to implement saga patterns with Akces

```java
public class OrderProcessManager implements Aggregate<OrderProcessManagerState> {
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
        // Reserve funds first
        getCommandBus().send(new ReserveAmountCommand(/*...*/));
        // Create the order
        return Stream.of(new BuyOrderCreatedEvent(/*...*/));
    }
    
    // Event handlers to advance the process based on events from other aggregates
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
        // Place the market order now that funds are reserved
        getCommandBus().send(new PlaceMarketOrderCommand(/*...*/));
        return Stream.of(new BuyOrderPlacedEvent(/*...*/));
    }
}
```

### Commands and Events

The application defines a rich set of commands and events that demonstrate best practices:

#### Commands

- `CreateAccountCommand`: Creates a new user account
- `CreateWalletCommand`: Creates a new wallet
- `CreateBalanceCommand`: Adds a new currency balance to a wallet
- `CreditWalletCommand`: Adds funds to a wallet balance
- `DebitWalletCommand`: Removes funds from a wallet balance
- `ReserveAmountCommand`: Reserves funds for a pending transaction
- `PlaceBuyOrderCommand`: Initiates a buy order process
- `PlaceMarketOrderCommand`: Places an order on a market

#### Events

- `AccountCreatedEvent`: Signals account creation
- `WalletCreatedEvent`: Signals wallet creation
- `BalanceCreatedEvent`: Signals addition of a new balance
- `WalletCreditedEvent`: Signals successful crediting of funds
- `WalletDebitedEvent`: Signals successful debiting of funds
- `AmountReservedEvent`: Signals successful fund reservation
- `BuyOrderCreatedEvent`: Signals creation of a buy order
- `MarketOrderFilledEvent`: Signals successful execution of a market order

#### Error Events

The application handles errors through specialized error events:

- `InvalidAmountErrorEvent`: Signals an invalid amount in a command
- `InsufficientFundsErrorEvent`: Signals insufficient funds for an operation
- `InvalidCryptoCurrencyErrorEvent`: Signals an unknown cryptocurrency
- `MarketOrderRejectedErrorEvent`: Signals rejection of a market order

### Query Models

The application defines query models that are optimized for read operations:

- `AccountQueryModel`: Provides efficient access to account information
- `WalletQueryModel`: Provides efficient access to wallet balances
- `CryptoMarketModel`: Provides access to market information

These models are kept up-to-date by subscribing to domain events and are stored in formats optimized for queries.

### Database Integration

The application demonstrates database integration for query models:

- Uses JDBC for database access
- Implements Liquibase for database migrations
- Shows how to map domain events to database operations

```java
public class CryptoMarketModel extends JdbcDatabaseModel {
    public void handle(CryptoMarketCreatedEvent event) {
        cryptoMarketRepository.save(CryptoMarket.createNew(
            event.id(),
            event.baseCrypto(),
            event.quoteCrypto(),
            // Other properties...
        ));
    }
}
```

### REST API

The application exposes REST endpoints for both commands and queries:

#### Command Endpoints

- `POST /v1/accounts`: Create a new account
- `POST /v1/wallets/{walletId}/balances`: Add a new balance to a wallet
- `POST /v1/wallets/{walletId}/balances/{currency}/credit`: Credit funds to a wallet
- `POST /v1/accounts/{accountId}/orders/buy`: Place a buy order

#### Query Endpoints

- `GET /v1/accounts/{accountId}`: Get account information
- `GET /v1/wallets/{walletId}`: Get wallet information
- `GET /v1/markets`: Get all markets
- `GET /v1/markets/{marketId}`: Get specific market information

### Testing

The application includes comprehensive tests that demonstrate testing strategies for CQRS and Event Sourcing:

- Unit tests for individual aggregates
- Integration tests for command processing
- End-to-end tests for full workflows
- Tests that verify temporal queries and event replay

The tests use TestContainers to set up Kafka, Schema Registry, and PostgreSQL for realistic testing environments.

## Technical Highlights

### Event Sourcing Implementation

- All state changes are captured as immutable events
- State is reconstructed by replaying events
- Events are stored in Kafka topics, partitioned by aggregate ID
- Snapshots are maintained in RocksDB for efficient access

### CQRS Pattern

- Clear separation between command and query responsibilities
- Command endpoints focusing on write operations
- Query endpoints optimized for read operations
- Different data models for writes and reads

### GDPR Compliance

- PII data (like names and emails) is automatically protected
- Uses `@PIIData` annotation to mark sensitive fields
- Transparent encryption during serialization

### Schema Management

- Integration with Confluent Schema Registry
- Command and event validation using JSON Schema
- Schema evolution with version tracking

### Process Management

- Complex workflows coordinated across multiple aggregates
- Stateful process tracking
- Event-driven process advancement

## Conclusion

The Crypto Trading application serves as a comprehensive demonstration of building distributed, event-driven systems with the Akces Framework. It showcases best practices for implementing CQRS and Event Sourcing patterns and demonstrates how to solve common challenges in distributed systems.

This application can be used as a reference implementation when building your own applications with the Akces Framework, offering patterns and solutions for common requirements in enterprise applications.

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderFilledEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderPlacedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManagerState.java
================
this(userId, List.of());
⋮----
public String getAggregateId() {
return userId();
⋮----
public OrderProcess getAkcesProcess(String processId) {
return runningProcesses.stream().filter(p -> p.orderId().equals(processId)).findFirst()
.orElseThrow(() -> new UnknownAkcesProcessException("OrderProcessManager", userId(), processId));
⋮----
public boolean hasAkcesProcess(String processId) {
return runningProcesses.stream().anyMatch(p -> p.orderId().equals(processId));

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/Wallet.java
================
public final class Wallet implements Aggregate<WalletStateV2> {
⋮----
public String getName() {
⋮----
public Class<WalletStateV2> getStateClass() {
⋮----
public WalletStateV2 upcast(WalletState state) {
⋮----
return new WalletStateV2(state.id(), state.balances().stream().map(
balance -> balance.reservedAmount().compareTo(BigDecimal.ZERO) > 0 ?
new WalletStateV2.Balance(balance.currency(), balance.amount(), List.of(new WalletStateV2.Reservation("v1-reservedAmount", balance.reservedAmount()))) :
new WalletStateV2.Balance(balance.currency(), balance.amount())).toList());
⋮----
public @NotNull Stream<DomainEvent> create(@NotNull AccountCreatedEvent event, WalletStateV2 isNull) {
return Stream.of(new WalletCreatedEvent(event.getAggregateId()), new BalanceCreatedEvent(event.getAggregateId(), "EUR"));
⋮----
public @NotNull Stream<DomainEvent> create(@NotNull CreateWalletCommand cmd, WalletStateV2 isNull) {
return Stream.of(new WalletCreatedEvent(cmd.id()), new BalanceCreatedEvent(cmd.id(), cmd.currency()));
⋮----
public @NotNull Stream<DomainEvent> createBalance(@NotNull CreateBalanceCommand cmd, @NotNull WalletStateV2 currentState) {
boolean balanceExists = currentState.balances().stream()
.anyMatch(balance -> balance.currency().equals(cmd.currency()));
⋮----
return Stream.of(new BalanceAlreadyExistsErrorEvent(cmd.id(), cmd.currency()));
⋮----
return Stream.of(new BalanceCreatedEvent(cmd.id(), cmd.currency()));
⋮----
public Stream<DomainEvent> credit(@NotNull CreditWalletCommand cmd, @NotNull WalletStateV2 currentState) {
WalletStateV2.Balance balance = currentState.balances().stream().filter(b -> b.currency().equals(cmd.currency())).findFirst().orElse(null);
⋮----
return Stream.of(new InvalidCryptoCurrencyErrorEvent(cmd.id(), cmd.currency()));
⋮----
if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {
⋮----
return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
⋮----
return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), cmd.amount(), balance.amount().add(cmd.amount())));
⋮----
public Stream<DomainEvent> debit(@NotNull DebitWalletCommand cmd, @NotNull WalletStateV2 currentState) {
WalletStateV2.Balance balance = currentState.balances().stream()
.filter(b -> b.currency().equals(cmd.currency()))
.findFirst()
.orElse(null);
⋮----
if (cmd.amount().compareTo(BigDecimal.ZERO) <= 0) {
⋮----
if (balance.getAvailableAmount().compareTo(cmd.amount()) < 0) {
return Stream.of(new InsufficientFundsErrorEvent(
cmd.id(),
cmd.currency(),
balance.getAvailableAmount(),
cmd.amount(),
⋮----
return Stream.of(new WalletDebitedEvent(
currentState.id(),
⋮----
balance.amount().subtract(cmd.amount())
⋮----
public Stream<DomainEvent> makeReservation(ReserveAmountCommand command, WalletStateV2 state) {
WalletStateV2.Balance balance = state.balances().stream().filter(b -> b.currency().equals(command.currency())).findFirst().orElse(null);
⋮----
return Stream.of(new InvalidCryptoCurrencyErrorEvent(command.userId(), command.currency(), command.referenceId()));
⋮----
if (command.amount().compareTo(BigDecimal.ZERO) < 0) {
⋮----
return Stream.of(new InvalidAmountErrorEvent(command.userId(), command.currency()));
⋮----
if (balance.getAvailableAmount().compareTo(command.amount()) >= 0) {
return Stream.of(new AmountReservedEvent(command.userId(), command.currency(), command.amount(), command.referenceId()));
⋮----
return Stream.of(new InsufficientFundsErrorEvent(command.userId(), command.currency(), balance.getAvailableAmount(), command.amount(), command.referenceId()));
⋮----
public Stream<DomainEvent> cancelReservation(CancelReservationCommand command, WalletStateV2 state) {
WalletStateV2.Balance balance = state.balances().stream()
.filter(b -> b.currency().equals(command.currency()))
⋮----
boolean reservationExists = balance.reservations().stream()
.anyMatch(r -> r.referenceId().equals(command.referenceId()));
⋮----
return Stream.of(new ReservationNotFoundErrorEvent(command.userId(), command.currency(), command.referenceId()));
⋮----
return Stream.of(new ReservationCancelledEvent(command.userId(), command.currency(), command.referenceId()));
⋮----
public @NotNull WalletStateV2 create(@NotNull WalletCreatedEvent event, WalletStateV2 isNull) {
return new WalletStateV2(event.id(), new ArrayList<>());
⋮----
public @NotNull WalletStateV2 createBalance(@NotNull BalanceCreatedEvent event, WalletStateV2 state) {
List<WalletStateV2.Balance> balances = new ArrayList<>(state.balances());
balances.add(new WalletStateV2.Balance(event.currency(), BigDecimal.ZERO));
return new WalletStateV2(state.id(), balances);
⋮----
public @NotNull WalletStateV2 credit(@NotNull WalletCreditedEvent event, @NotNull WalletStateV2 state) {
return new WalletStateV2(state.id(), state.balances().stream().map(b -> {
if (b.currency().equals(event.currency())) {
return new WalletStateV2.Balance(b.currency(), b.amount().add(event.amount()));
⋮----
}).toList());
⋮----
public @NotNull WalletStateV2 debit(@NotNull WalletDebitedEvent event, @NotNull WalletStateV2 state) {
⋮----
return new WalletStateV2.Balance(b.currency(), event.newBalance(), b.reservations());
⋮----
public @NotNull WalletStateV2 reserveAmount(@NotNull AmountReservedEvent event, @NotNull WalletStateV2 state) {
⋮----
List<WalletStateV2.Reservation> reservations = new ArrayList<>(b.reservations());
reservations.add(new WalletStateV2.Reservation(event.referenceId(), b.amount()));
return new WalletStateV2.Balance(b.currency(), b.amount(), reservations);
⋮----
public @NotNull WalletStateV2 cancelReservation(@NotNull ReservationCancelledEvent event, @NotNull WalletStateV2 state) {
⋮----
List<WalletStateV2.Reservation> reservations = b.reservations().stream()
.filter(r -> !r.referenceId().equals(event.referenceId()))
.toList();

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"}],\"consumedEvents\":[{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"CancelReservation\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CancelReservation\"},{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"DebitWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.DebitWallet\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"ReservationNotFoundError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationNotFoundError\"},{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"WalletDebited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletDebited\"},{\"typeName\":\"ReservationCancelled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationCancelled\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderInput.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderOutput.java
================


================
File: test-apps/crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"}],\"consumedEvents\":[{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"CancelReservation\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CancelReservation\"},{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"DebitWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.DebitWallet\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"ReservationNotFoundError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationNotFoundError\"},{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"WalletDebited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletDebited\"},{\"typeName\":\"ReservationCancelled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationCancelled\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/jdbc/CryptoMarket.java
================
public static CryptoMarket createNew(@NotNull String id,
⋮----
return new CryptoMarket(id, baseCrypto, quoteCrypto, baseIncrement, quoteIncrement, defaultCounterPartyId, true);
⋮----
public String getId() {
return id();
⋮----
public boolean createNew() {
⋮----
public boolean isNew() {

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/CryptoMarketModel.java
================
public class CryptoMarketModel extends JdbcDatabaseModel {
⋮----
public void handle(CryptoMarketCreatedEvent event) {
cryptoMarketRepository.save(CryptoMarket.createNew(
event.id(),
event.baseCrypto(),
event.quoteCrypto(),
event.baseIncrement(),
event.quoteIncrement(),
event.defaultCounterPartyId()

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/services/CryptoMarketsService.java
================
public class CryptoMarketsService {
⋮----
public void init() {
coinbaseService.getProducts().stream()
.filter(product -> !cryptoMarketRepository.existsById(product.id()))
.forEach(product -> akcesClient.sendAndForget(new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
public List<CryptoMarket> getAllMarkets() {
return cryptoMarketRepository.findAll();
⋮----
public Optional<CryptoMarket> getMarketById(String id) {
return cryptoMarketRepository.findById(id);

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {
⋮----
public WebClient coinbaseWebClient() {
return WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();

================
File: test-apps/crypto-trading/queries/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
spring.datasource.url=jdbc:postgresql://akces-postgresql:5432/akces
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true
akces.cryptotrading.counterPartyId=Coinbase
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration
spring.liquibase.change-log=classpath:/db/changelog/db.changelog-master.xml

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/PlaceMarketOrderCommand.java
================
BigDecimal size) implements Command {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderPlacedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return orderId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/BuyOrderProcess.java
================
) implements OrderProcess {
⋮----
public String getProcessId() {
return orderId();
⋮----
public BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error) {
return new BuyOrderRejectedEvent(error.walletId(), orderId(), clientReference());
⋮----
public BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error) {
⋮----
public BuyOrderRejectedEvent handle(RejectOrderCommand command) {
return new BuyOrderRejectedEvent(command.userId(), orderId(), clientReference());
⋮----
public OrderProcess withState(OrderProcessState state) {
return new BuyOrderProcess(orderId(), market, size(), amount(), clientReference(), state);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcess.java
================
public sealed interface OrderProcess extends AkcesProcess permits BuyOrderProcess {
String orderId();
⋮----
CryptoMarket market();
⋮----
BigDecimal size();
⋮----
BigDecimal amount();
⋮----
String clientReference();
⋮----
OrderProcessState state();
⋮----
BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error);
⋮----
BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error);
⋮----
BuyOrderRejectedEvent handle(RejectOrderCommand command);
⋮----
OrderProcess withState(OrderProcessState state);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BuyOrderInput.java
================
public PlaceBuyOrderCommand toCommand(String accountId) {
return new PlaceBuyOrderCommand(
⋮----
CryptoMarket.fromId(marketId),

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"}],\"consumedEvents\":[{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"CancelReservation\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CancelReservation\"},{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"DebitWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.DebitWallet\"}],\"producedEvents\":[{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"ReservationNotFoundError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationNotFoundError\"},{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"WalletDebited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletDebited\"},{\"typeName\":\"ReservationCancelled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.ReservationCancelled\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();
⋮----
public static void prepareDomainEventSchemas(String url, List<Class<? extends DomainEvent>> domainEventClasses) {
SchemaRegistryClient src = new CachedSchemaRegistryClient(url, 100);
Jackson2ObjectMapperBuilder objectMapperBuilder = new Jackson2ObjectMapperBuilder();
objectMapperBuilder.modulesToInstall(new AkcesGDPRModule());
objectMapperBuilder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
SchemaGeneratorConfigBuilder configBuilder = new SchemaGeneratorConfigBuilder(objectMapperBuilder.build(),
⋮----
configBuilder.with(new JakartaValidationModule(JakartaValidationOption.INCLUDE_PATTERN_EXPRESSIONS,
⋮----
configBuilder.with(new JacksonModule());
configBuilder.with(Option.FORBIDDEN_ADDITIONAL_PROPERTIES_BY_DEFAULT);
configBuilder.with(Option.NULLABLE_FIELDS_BY_DEFAULT);
configBuilder.with(Option.NULLABLE_METHOD_RETURN_VALUES_BY_DEFAULT);
⋮----
configBuilder.forTypesInGeneral().withTypeAttributeOverride((collectedTypeAttributes, scope, context) -> {
if (scope.getType().getTypeName().equals("java.math.BigDecimal")) {
JsonNode typeNode = collectedTypeAttributes.get("type");
if (typeNode.isArray()) {
((ArrayNode) collectedTypeAttributes.get("type")).set(0, "string");
⋮----
collectedTypeAttributes.put("type", "string");
⋮----
SchemaGeneratorConfig config = configBuilder.build();
SchemaGenerator jsonSchemaGenerator = new SchemaGenerator(config);
⋮----
DomainEventInfo info = domainEventClass.getAnnotation(DomainEventInfo.class);
src.register("domainevents." + info.type(),
new JsonSchema(jsonSchemaGenerator.generateSchema(domainEventClass), List.of(), Map.of(), info.version()),
info.version(),
⋮----
throw new ApplicationContextException("Problem populating SchemaRegistry", e);
⋮----
public static <C extends Command> void prepareCommandSchemas(String url, List<Class<C>> commandClasses) {
⋮----
CommandInfo info = commandClass.getAnnotation(CommandInfo.class);
src.register("commands." + info.type(),
new JsonSchema(jsonSchemaGenerator.generateSchema(commandClass), List.of(), Map.of(), info.version()),

================
File: test-apps/crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingCommandApiTest.java
================
public class CryptoTradingCommandApiTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withEnv("SCHEMA_REGISTRY_SCHEMA_COMPATIBILITY_LEVEL","none")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void contextLoads() {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(prderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
assertThat(accountWebController).isNotNull();
assertThat(walletWebController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!prderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void testCreateAccount() {
⋮----
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
webTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
⋮----
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
⋮----
void testCreateAccountAndCreditWallet() {
⋮----
CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
.bodyValue(creditInput)
⋮----
.expectBody(BalanceOutput.class)
.value(creditOutput -> {
assertThat(creditOutput).isNotNull();
assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
assertThat(creditOutput.currency()).isEqualTo("EUR");
⋮----
void testCreateAccountAndCreditWalletWithoutBalance() {
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
⋮----
.expectStatus().is4xxClientError()
.expectBody(ErrorEventResponse.class)
.value(response -> {
assertThat(response).isNotNull();
assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
⋮----
void testCreateAccountAndAddBtcBalance() {
⋮----
CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances")
.bodyValue(createBalanceInput)
⋮----
.expectStatus().is2xxSuccessful();
⋮----
void testInvalidApiVersion() {
⋮----
.uri("/v13/accounts/invalid-id")
⋮----
.expectStatus().isNotFound();
⋮----
void testPlaceBuyOrder() {
⋮----
Product product = coinbaseService.getProduct("BTC-EUR");
akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
AccountOutput accountOutput = webTestClient.post()
⋮----
.returnResult()
.getResponseBody();
⋮----
String userId = accountOutput.userId();
⋮----
.uri("/v1/wallets/" + userId + "/balances/EUR/credit")
.bodyValue(new CreditWalletInput(new BigDecimal("10000.0")))
⋮----
.uri("/v1/wallets/" + userId + "/balances")
.bodyValue(new CreateBalanceInput("BTC"))
⋮----
BuyOrderInput buyOrderInput = new BuyOrderInput("BTC-EUR", new BigDecimal("1000"), "client-ref-1");
⋮----
.uri("/v1/accounts/" + userId + "/orders/buy")
.bodyValue(buyOrderInput)
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingE2ETests.java
================
public class CryptoTradingE2ETests {
private final WebTestClient e2eTestClient = WebTestClient.bindToServer()
.baseUrl(System.getenv("AKCES_CRYPTO_TRADING_BASE_URL"))
.build();
⋮----
public void testCreateAndReadAccount() {
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
String userId = e2eTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
.exchange()
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
}).returnResult().getResponseBody().userId();
⋮----
System.out.println("Created account with userId: " + userId);
⋮----
e2eTestClient.get()
.uri("/v1/accounts/" + userId)
⋮----
.value(retrievedAccount -> {
assertThat(retrievedAccount).isNotNull();
assertThat(retrievedAccount.userId()).isEqualTo(userId);
assertThat(retrievedAccount.country()).isEqualTo("NL");
assertThat(retrievedAccount.firstName()).isEqualTo("John");
assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
⋮----
public void testBuyCrypto() {
AccountInput accountInput = new AccountInput("NL", "Some", "CryptoTrader", "some.cryptotrader@example.com");
⋮----
e2eTestClient.post()
.uri("/v1/wallets/{userId}/balances", userId)
.bodyValue(new CreateBalanceInput("ETH"))
⋮----
.expectBody(BalanceOutput.class)
.value(balanceOutput -> {
assertThat(balanceOutput).isNotNull();
assertThat(balanceOutput.currency()).isEqualTo("ETH");
assertThat(balanceOutput.amount()).isEqualTo(BigDecimal.ZERO);
⋮----
.uri("/v1/wallets/{userId}/balances/EUR/credit", userId)
.bodyValue(new CreditWalletInput(new BigDecimal("1000.00")))
⋮----
assertThat(balanceOutput.currency()).isEqualTo("EUR");
assertThat(balanceOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
assertThat(balanceOutput.balance()).isEqualTo(new BigDecimal("1000.00"));
⋮----
.uri("/v1/accounts/{userId}/orders/buy", userId)
.bodyValue(new BuyOrderInput("ETH-EUR", new BigDecimal("1000.00"), "buy-eth-eur"))
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
assertThat(orderOutput.market()).isNotNull();
assertThat(orderOutput.market().id()).isEqualTo("ETH-EUR");
assertThat(orderOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
assertThat(orderOutput.clientReference()).isEqualTo("buy-eth-eur");
⋮----
Thread.sleep(10000);
⋮----
.uri("/v1/wallets/{userId}", userId)
⋮----
.expectBody(WalletQueryModelState.class)
.value(wallet -> {
assertThat(wallet).isNotNull();
assertThat(wallet.balances()).hasSize(2);
⋮----
var eurBalance = wallet.balances().stream()
.filter(b -> "EUR".equals(b.currency()))
.findFirst().orElseThrow();
assertThat(eurBalance.amount()).isEqualTo(new BigDecimal("0.00"));
⋮----
var ethBalance = wallet.balances().stream()
.filter(b -> "ETH".equals(b.currency()))
⋮----
assertThat(ethBalance.amount()).isNotEqualTo(BigDecimal.ZERO);
⋮----
public void testBtcEurMarket() {
⋮----
.uri("/v1/markets/BTC-EUR")
⋮----
.expectBody()
.jsonPath("$.id").isEqualTo("BTC-EUR")
.jsonPath("$.baseCrypto").isEqualTo("BTC")
.jsonPath("$.quoteCrypto").isEqualTo("EUR")
.jsonPath("$.baseIncrement").exists()
.jsonPath("$.quoteIncrement").exists()
.jsonPath("$.defaultCounterPartyId").exists();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarket.java
================
public class CryptoMarket implements Aggregate<CryptoMarketState> {
⋮----
private final MathContext mathContext = new MathContext(8);
⋮----
public String getName() {
⋮----
public Class<CryptoMarketState> getStateClass() {
⋮----
public @NotNull Stream<DomainEvent> handle(@NotNull CreateCryptoMarketCommand command, CryptoMarketState isNull) {
return Stream.of(new CryptoMarketCreatedEvent(command.id(),
command.baseCurrency(),
command.quoteCurrency(),
command.baseIncrement(),
command.quoteIncrement(),
command.defaultCounterPartyId()));
⋮----
public @NotNull Stream<DomainEvent> handle(@NotNull PlaceMarketOrderCommand command, CryptoMarketState currentState) {
if (command.side().equals(Side.BUY) && command.funds() == null) {
return Stream.of(new MarketOrderRejectedErrorEvent(command.marketId(),
command.orderId(),
command.ownerId(),
⋮----
} else if (command.side().equals(Side.SELL) && command.size() == null) {
⋮----
Ticker currentTicker = coinbaseService.getTicker(currentState.id());
⋮----
BigDecimal price = command.side().equals(Side.BUY) ? new BigDecimal(currentTicker.ask()) : new BigDecimal(currentTicker.bid());
⋮----
BigDecimal quantity = command.side().equals(Side.BUY) ? command.funds().divide(price, mathContext) : command.size();
MarketOrderFilledEvent marketOrderFilledEvent = new MarketOrderFilledEvent(command.marketId(),
⋮----
currentState.defaultCounterPartyId(),
command.side(),
currentState.baseCrypto(),
currentState.quoteCrypto(),
⋮----
MarketOrderPlacedEvent marketOrderPlacedEvent = new MarketOrderPlacedEvent(command.marketId(),
⋮----
command.funds(),
command.size());
return Stream.of(marketOrderPlacedEvent, marketOrderFilledEvent);
⋮----
public @NotNull CryptoMarketState apply(@NotNull CryptoMarketCreatedEvent event, CryptoMarketState isNull) {
return new CryptoMarketState(event.id(),
event.baseCrypto(),
event.quoteCrypto(),
event.baseIncrement(),
event.quoteIncrement(),
event.defaultCounterPartyId());
⋮----
public @NotNull CryptoMarketState apply(@NotNull MarketOrderPlacedEvent event, CryptoMarketState currentState) {
⋮----
public @NotNull CryptoMarketState apply(@NotNull MarketOrderFilledEvent event, CryptoMarketState currentState) {

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManager.java
================
public class OrderProcessManager implements Aggregate<OrderProcessManagerState> {
⋮----
public String getName() {
⋮----
public Class<OrderProcessManagerState> getStateClass() {
⋮----
public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
⋮----
public OrderProcessManagerState create(UserOrderProcessesCreatedEvent event, OrderProcessManagerState isNull) {
return new OrderProcessManagerState(event.userId());
⋮----
public OrderProcessManagerState handle(BuyOrderCreatedEvent event, OrderProcessManagerState state) {
return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
add(new BuyOrderProcess(
event.orderId(),
event.market(),
event.amount(),
event.clientReference()));
⋮----
public OrderProcessManagerState handle(BuyOrderRejectedEvent event, OrderProcessManagerState state) {
⋮----
removeIf(process -> process.orderId().equals(event.orderId()));
⋮----
public OrderProcessManagerState handle(BuyOrderPlacedEvent event, OrderProcessManagerState state) {
⋮----
replaceAll(process -> process.orderId().equals(event.orderId())
? process.withState(OrderProcessState.PLACED)
⋮----
public OrderProcessManagerState handle(BuyOrderFilledEvent event, OrderProcessManagerState state) {
⋮----
public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
⋮----
String orderId = UUID.randomUUID().toString();
⋮----
getCommandBus().send(new ReserveAmountCommand(
state.userId(),
command.market().quoteCrypto(),
command.amount(),
⋮----
return Stream.of(new BuyOrderCreatedEvent(
⋮----
command.market(),
⋮----
command.clientReference()));
⋮----
public Stream<BuyOrderRejectedEvent> rejectOrder(RejectOrderCommand command, OrderProcessManagerState state) {
if (state.hasAkcesProcess(command.orderId())) {
return Stream.of(state.getAkcesProcess(command.orderId()).handle(command));
⋮----
return Stream.empty();
⋮----
public Stream<BuyOrderFilledEvent> fillOrder(FillBuyOrderCommand command, OrderProcessManagerState state) {
⋮----
getCommandBus().send(new CancelReservationCommand(
⋮----
command.quoteCurrency(),
command.orderId()));
⋮----
BigDecimal quoteAmount = command.price().multiply(command.quantity());
getCommandBus().send(new DebitWalletCommand(
command.userId(),
⋮----
getCommandBus().send(new CreditWalletCommand(
⋮----
command.baseCurrency(),
command.quantity()));
⋮----
return Stream.of(new BuyOrderFilledEvent(
⋮----
command.orderId(),
command.counterpartyId(),
command.price(),
command.quantity(),
⋮----
command.quoteCurrency()
⋮----
public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
⋮----
OrderProcess orderProcess = state.getAkcesProcess(event.referenceId());
⋮----
getCommandBus().send(new PlaceMarketOrderCommand(
orderProcess.market().id(),
orderProcess.orderId(),
⋮----
orderProcess.amount(),
⋮----
return Stream.of(new BuyOrderPlacedEvent(state.userId(), orderProcess.orderId(), orderProcess.market(), orderProcess.amount(), null));
⋮----
public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
if (state.hasAkcesProcess(errorEvent.referenceId())) {
return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
⋮----
public Stream<DomainEvent> handle(InvalidCryptoCurrencyErrorEvent errorEvent, OrderProcessManagerState state) {
⋮----
public void handle(MarketOrderRejectedErrorEvent errorEvent, CommandBus commandBus) {
⋮----
commandBus.send(new RejectOrderCommand(errorEvent.ownerId(), errorEvent.orderId()));
⋮----
public void handle(MarketOrderFilledEvent event, CommandBus commandBus) {
switch (event.side()) {
⋮----
commandBus.send(new FillBuyOrderCommand(
event.ownerId(),
⋮----
event.counterpartyId(),
event.price(),
event.quantity(),
event.baseCurrency(),
event.quoteCurrency()

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/OrdersCommandController.java
================
public class OrdersCommandController {
⋮----
public Mono<ResponseEntity<OrderOutput>> placeBuyOrder(
⋮----
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(accountId)))
.map(List::getFirst)
.map(domainEvent -> {
⋮----
OrderOutput output = new OrderOutput(
event.orderId(),
event.market(),
⋮----
event.amount(),
event.clientReference()
⋮----
return ResponseEntity.ok(output);

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingApplicationTest.java
================
public class CryptoTradingApplicationTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withEnv("SCHEMA_REGISTRY_SCHEMA_COMPATIBILITY_LEVEL","none")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void contextLoads() throws IOException {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(prderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!prderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
try (Consumer<String, AkcesControlRecord> controlConsumer = controlConsumerFactory.createConsumer("Test-AkcesControl", "test-akces-control")) {
TopicPartition controlPartition = new TopicPartition("Akces-Control", 0);
controlConsumer.assign(List.of(controlPartition));
controlConsumer.seekToBeginning(controlConsumer.assignment());
Map<TopicPartition, Long> endOffsets = controlConsumer.endOffsets(controlConsumer.assignment());
⋮----
while (endOffsets.getOrDefault(controlPartition, 0L) > controlConsumer.position(controlPartition)) {
ConsumerRecords<String, AkcesControlRecord> controlRecords = controlConsumer.poll(Duration.ofMillis(1000));
if (!controlRecords.isEmpty()) {
for (ConsumerRecord<String, AkcesControlRecord> record : controlRecords.records(controlPartition)) {
if (record.value() instanceof AggregateServiceRecord aggregateServiceRecord) {
System.out.println(objectMapper.writeValueAsString(aggregateServiceRecord));
serviceRecords.put(record.key(), aggregateServiceRecord);
⋮----
Assertions.assertEquals(4, serviceRecords.size());
⋮----
void testCreateBTCEURMarketAndMakeATrade() {
⋮----
akcesClientController.sendAndForget("TEST",
new CreateAccountCommand(counterPartyId,
⋮----
Product product = coinbaseService.getProduct("BTC-EUR");
akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
Mono.fromCompletionStage(akcesClientController.send("TEST", new CreateAccountCommand(accountId,
⋮----
"john.doe@example.com"))).block();
⋮----
Mono.fromCompletionStage(akcesClientController.send("TEST",
new CreateBalanceCommand(accountId, "BTC"))).block();
⋮----
new CreditWalletCommand(accountId,
⋮----
new BigDecimal("1000")))).block();
⋮----
new PlaceBuyOrderCommand(accountId,
new CryptoMarket("BTC-EUR", "BTC", "EUR"),
new BigDecimal("250"),
clientOrderId))).block();
⋮----
Consumer<String, ProtocolRecord> testConsumer = consumerFactory.createConsumer("Test", "test")
⋮----
testConsumer.subscribe(Pattern.compile(".*-DomainEvents$"), new ConsumerRebalanceListener() {
⋮----
public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
⋮----
public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
testConsumer.seekToBeginning(partitions);
⋮----
for (ConsumerRecord<String, ProtocolRecord> record : testConsumer.poll(Duration.ofMillis(100))) {
actualEventTypes.add(record.value().name());
⋮----
Assertions.assertEquals(expectedEventTypes.length, actualEventTypes.size());
⋮----
Assertions.assertTrue(actualEventTypes.contains(expectedEventType));
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: FRAMEWORK_OVERVIEW.md
================
# Comprehensive Analysis of the Akces Framework - Updated Overview

## Introduction

The Akces Framework is a sophisticated event sourcing and CQRS (Command Query Responsibility Segregation) implementation built on Apache Kafka. It provides a comprehensive infrastructure for building distributed, event-driven applications with a clear separation between write and read concerns.

## Core Purpose and Values

Akces addresses several key challenges in distributed systems:

1. **Event Sourcing Implementation**: Provides a complete event sourcing framework where all changes to application state are captured as an immutable sequence of events.

2. **CQRS Architecture**: Enforces clean separation between command (write) and query (read) responsibilities for better scalability and performance.

3. **Partition-Based Scalability**: Leverages Kafka's partitioning for horizontal scaling of aggregates, allowing applications to scale with increasing load.

4. **Privacy By Design**: Built-in GDPR compliance through transparent encryption of personally identifiable information (PII).

5. **Schema Evolution**: Sophisticated schema management with backward compatibility checks to support evolving domain models.

6. **Process Management**: First-class support for process managers to orchestrate multi-step business processes across aggregates.

## Architecture Overview

Akces is organized into five main modules, each with distinct responsibilities:

### 1. API Module (`akces-api`)
Defines the core interfaces and annotations that make up the programming model:
- `Aggregate` and `AggregateState` interfaces
- Command and event interfaces with marker annotations
- Handler annotations (`@CommandHandler`, `@EventHandler`, etc.)
- Query model interfaces and annotations

### 2. Shared Module (`akces-shared`)
Contains common utilities and shared functionality:
- Protocol record definitions for Kafka communication
- GDPR compliance utilities with encryption/decryption
- Schema registry integration for JSON schema validation
- Serialization/deserialization support with Protocol Buffers
- RocksDB utilities for efficient state management

### 3. Runtime Module (`akces-runtime`)
Implements the core event sourcing infrastructure:
- Aggregate runtime for processing commands and events
- State repositories (RocksDB-based and in-memory)
- Command handling pipeline with validation
- Event sourcing mechanics for state reconstruction
- Kafka partition management for distributed processing

### 4. Client Module (`akces-client`)
Provides client-side functionality for command submission:
- Command sending with synchronous and asynchronous APIs
- Service discovery for routing commands to the correct aggregate
- Schema validation and compatibility checking
- Command response handling

### 5. Query Support Module (`akces-query-support`)
Implements the query side of CQRS:
- Query model runtime for maintaining read models
- Database model support (JDBC, JPA) for persistence
- Event handling for updating query models
- State hydration for efficient retrieval
- Caching for improved read performance

## Key Components and Patterns

### Aggregate Pattern

At the core of Akces is the concept of aggregates, which are domain entities that:
- Encapsulate business logic within consistency boundaries
- Respond to commands by validating and processing them
- Emit domain events representing facts that have occurred
- Maintain state through event sourcing mechanisms

```java
@AggregateInfo(value = "Wallet", version = 1)
public final class Wallet implements Aggregate<WalletState> {
    @CommandHandler(create = true)
    public Stream<DomainEvent> create(CreateWalletCommand cmd, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(cmd.id()));
    }
    
    @EventSourcingHandler(create = true)
    public WalletState create(WalletCreatedEvent event, WalletState isNull) {
        return new WalletState(event.id(), new ArrayList<>());
    }
}
```

### Command Handling

Commands are processed through a pipeline that:
1. Validates the command structure using JSON Schema
2. Routes the command to the appropriate aggregate partition
3. Processes the command to produce domain events
4. Applies those events to update the aggregate state
5. Persists both events and updated state to Kafka topics

```java
@CommandInfo(type = "CreateWallet", version = 1)
public record CreateWalletCommand(@AggregateIdentifier String id, String currency) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Event Sourcing

The event sourcing mechanism:
1. Captures all state changes as immutable events in Kafka
2. Stores events in partitioned topics for efficient processing
3. Rebuilds aggregate state by replaying events
4. Uses RocksDB to maintain efficient state snapshots
5. Handles event upcasting for schema evolution

```java
@DomainEventInfo(type = "WalletCreated", version = 1)
public record WalletCreatedEvent(@AggregateIdentifier String id) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### GDPR Compliance

Akces provides sophisticated GDPR compliance through:
1. `@PIIData` annotation to mark sensitive fields
2. Transparent encryption/decryption during serialization
3. Key management through dedicated Kafka topics
4. Context-based encryption to secure personal data
5. Separation of encryption keys from data for better security

```java
public record AccountState(
    @AggregateIdentifier String userId,
    String country,
    @PIIData String firstName,
    @PIIData String lastName,
    @PIIData String email
) implements AggregateState {
    @Override
    public String getAggregateId() {
        return userId();
    }
}
```

### Query Models

For efficient reads, Akces implements:
1. Query models updated via domain events
2. State hydration from event streams
3. Caching mechanisms for efficient access
4. Projection-based read models optimized for specific query patterns

```java
@QueryModelInfo(value = "WalletQuery", version = 1, indexName = "Wallets")
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    @QueryModelEventHandler(create = true)
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        return new WalletQueryModelState(event.id(), List.of());
    }
    
    @QueryModelEventHandler
    public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState state) {
        return new WalletQueryModelState(
            state.walletId(),
            state.balances().stream()
                .map(balance -> {
                    if (balance.currency().equals(event.currency())) {
                        return new WalletQueryModelState.Balance(
                            balance.currency(),
                            balance.amount().add(event.amount()),
                            balance.reservedAmount()
                        );
                    }
                    return balance;
                })
                .toList()
        );
    }
}
```

### Database Models

For integration with traditional databases:
1. Database models updated from domain events
2. Support for JDBC and JPA persistence
3. Transactional updates with exactly-once semantics
4. Partition-aware offset tracking for reliable processing

```java
@DatabaseModelInfo(value = "WalletDatabase", version = 1)
public class WalletDatabaseModel extends JdbcDatabaseModel {
    @DatabaseModelEventHandler
    public void handle(WalletCreatedEvent event) {
        jdbcTemplate.update("INSERT INTO wallets (wallet_id) VALUES (?)", event.id());
    }
    
    @DatabaseModelEventHandler
    public void handle(WalletCreditedEvent event) {
        jdbcTemplate.update(
            "UPDATE wallet_balances SET amount = ? WHERE wallet_id = ? AND currency = ?",
            event.newBalance(),
            event.id(),
            event.currency()
        );
    }
}
```

### Process Managers

For coordinating complex workflows:
1. Process managers to orchestrate multi-step processes
2. Process state tracking to maintain workflow state
3. Event-driven process advancement
4. Error handling and compensation logic

```java
@AggregateInfo(value = "OrderProcessManager", version = 1)
public class OrderProcessManager implements ProcessManager<OrderProcessManagerState, OrderProcess> {
    @CommandHandler
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
        String orderId = UUID.randomUUID().toString();
        
        // Reserve funds first - send command to Wallet aggregate
        getCommandBus().send(new ReserveAmountCommand(
            state.userId(),
            command.market().quoteCurrency(),
            command.quantity().multiply(command.limitPrice()),
            orderId
        ));
        
        return Stream.of(new BuyOrderCreatedEvent(
            state.userId(),
            orderId,
            command.market(),
            command.quantity(),
            command.limitPrice(),
            command.clientReference()
        ));
    }
    
    @EventHandler
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(event.referenceId())) {
            OrderProcess process = state.getAkcesProcess(event.referenceId());
            return Stream.of(new BuyOrderPlacedEvent(
                state.userId(),
                process.orderId(),
                process.market(),
                process.quantity(),
                process.limitPrice()
            ));
        }
        return Stream.empty();
    }
}
```

## Technical Implementation Details

### Partition-Based Processing

Akces utilizes Kafka's partitioning for scalability:
- Aggregates are distributed across partitions based on their ID
- Each partition is processed independently by a dedicated thread
- Partitions can be rebalanced across nodes dynamically
- State is maintained efficiently per partition using RocksDB

### Transactional Processing

Commands are processed transactionally:
- Kafka transactions ensure atomic updates
- State updates are coordinated with event publishing
- Exactly-once semantics are preserved
- Failures result in transaction rollbacks
- Consistent offset management for reliable processing

### Schema Management

Schema evolution is handled through:
- Schema registry integration (Confluent Schema Registry)
- JSON Schema validation for commands and events
- Automatic schema compatibility checks
- Version management for backward compatibility
- Support for upcasting to handle schema changes

### State Management

Aggregate state is managed efficiently:
- RocksDB for persistent state storage with high performance
- Transactional state updates with rollback capability
- Optimistic concurrency control
- In-memory caching for performance
- State snapshots to avoid full event replay

## Key Innovations

1. **Integrated GDPR Compliance**: Built-in support for handling personal data with transparent encryption, making compliance easier.

2. **Event Indexing**: Automatic indexing of events for efficient temporal queries and state reconstruction across aggregates.

3. **Flexible Deployment Models**: Support for different deployment topologies from monolithic to fully distributed microservices.

4. **RocksDB Integration**: Efficient state storage using RocksDB for high performance with durability.

5. **Process Manager Support**: First-class support for process managers to handle complex workflows across aggregate boundaries.

6. **Schema Evolution**: Sophisticated handling of schema changes with backward compatibility checks and upcasting.

7. **Annotation-Based Programming Model**: Intuitive, declarative programming model that reduces boilerplate code.

## Advantages Over Similar Frameworks

Compared to other event sourcing frameworks like Axon or EventStore:

1. **Kafka Foundation**: Built on Kafka for enterprise-grade scalability, reliability, and throughput.

2. **Privacy by Design**: First-class GDPR compliance baked into the core rather than as an afterthought.

3. **Schema Evolution**: Sophisticated schema management with backward compatibility checks and automatic validation.

4. **Programming Model**: Clean, annotation-based programming model that minimizes boilerplate and follows domain-driven design principles.

5. **Complete CQRS Stack**: Full support for both command and query sides with multiple implementation options.

6. **Partition-Based Scalability**: Leverages Kafka's partitioning for horizontal scaling without complex configuration.

## Usage Scenarios

Akces is well-suited for:

1. **Financial Systems**: Where audit trails, transaction integrity, and high throughput are critical requirements.

2. **Customer Data Platforms**: Where GDPR compliance is essential and personal data needs protection.

3. **Distributed Commerce Systems**: With complex workflows across services and high scalability needs.

4. **High-Scale Event-Driven Systems**: Requiring reliable, high-throughput event processing.

5. **Systems with Complex Temporal Requirements**: Needing historical state reconstruction and time-based queries.

6. **Microservice Architectures**: Where clear boundaries and eventual consistency are appropriate design choices.

## Limitations and Considerations

1. **Kafka Dependency**: Requires a well-configured Kafka cluster, which adds operational complexity.

2. **Learning Curve**: Event sourcing and CQRS patterns require a mindset shift for teams used to traditional CRUD.

3. **Eventual Consistency**: Query models may lag behind command processing, requiring careful design for user experience.

4. **Infrastructure Complexity**: Requires Schema Registry and additional components for full functionality.

5. **Performance Considerations**: Event replaying can be resource-intensive for aggregates with many events.

## Production Readiness

The framework includes several features that make it production-ready:

1. **Resilience**: Automatic recovery from failures through Kafka's reliability mechanisms.

2. **Observability**: Comprehensive logging and metrics for monitoring system behavior.

3. **Configuration Flexibility**: Extensive configuration options for tuning performance.

4. **Testing Support**: Built-in utilities for testing aggregates and command handlers.

5. **Deployment Options**: Support for containerized deployment in modern cloud environments.

## Conclusion

The Akces Framework provides a comprehensive solution for building event-sourced, CQRS-based applications with a focus on scalability, privacy, and developer experience. Its clean programming model, combined with sophisticated runtime components, addresses many common challenges in distributed systems development.

The framework's integration with Kafka provides a reliable foundation for high-throughput event processing, while its schema management and GDPR compliance features address important enterprise concerns. The partition-based processing model enables horizontal scaling, making it suitable for applications with demanding performance requirements.

By providing a complete implementation of event sourcing and CQRS patterns, Akces enables developers to focus on domain logic rather than infrastructure concerns, ultimately leading to more maintainable, scalable, and secure distributed applications.

================
File: README.md
================
# Akces Framework

## Overview

Akces is a powerful CQRS (Command Query Responsibility Segregation) and Event Sourcing framework built on Apache Kafka. It provides a comprehensive infrastructure for building distributed, event-driven applications with a clear separation between write operations (commands) and read operations (queries).

The framework implements the full event sourcing pattern, capturing all changes to application state as a sequence of events. These events serve as the system of record and can be replayed to reconstruct the state at any point in time, providing a complete audit trail and enabling temporal queries.

Akces leverages Kafka's distributed architecture for reliable event storage and processing, making it highly scalable and resilient. It also provides built-in support for privacy protection (GDPR compliance), schema evolution, and efficient state management.

## Core Concepts

- **Aggregates**: Domain entities that encapsulate business logic and maintain consistency boundaries
- **Commands**: Requests to perform actions that change the state of an aggregate
- **Domain Events**: Immutable records of facts that have occurred, representing state changes
- **Command Handlers**: Process commands and produce events 
- **Event Sourcing Handlers**: Apply events to update aggregate state
- **Query Models**: Read-optimized projections of aggregate state
- **Database Models**: Persistent storage of aggregate data optimized for queries
- **Process Managers**: Coordinate workflows across multiple aggregates

## Key Features

### Command Processing

- **Command Bus**: Distribute commands to appropriate aggregates
- **Command Validation**: Automatic schema-based validation using JSON Schema
- **Command Routing**: Intelligent routing based on aggregate IDs
- **Transactional Processing**: Atomic processing with Kafka transactions

### Event Sourcing

- **Event Store**: Kafka-based storage for all domain events
- **State Reconstruction**: Rebuild aggregate state by replaying events
- **Event Handlers**: React to events to trigger additional processes
- **Event Bridging**: Connect events from one aggregate to commands on another

### Aggregate Management

- **Partition-Based Processing**: Scale horizontally through Kafka partitioning
- **State Snapshots**: Efficient state storage using RocksDB
- **Aggregate Lifecycle**: Manage aggregate creation and updates
- **Event Indexing**: Index events for efficient retrieval

### Query Support

- **Query Models**: Build specialized read models from events
- **State Hydration**: Efficiently load and cache query model state
- **Database Integration**: Support for both JDBC and JPA database models
- **Event-Driven Updates**: Keep read models in sync with write models

### Privacy & GDPR

- **PII Data Protection**: Automatic encryption of personal data
- **Transparent Handling**: Annotation-based marking of sensitive fields
- **Key Management**: Secure handling of encryption keys
- **Context-Aware Processing**: Apply encryption based on context

### Schema Management

- **Schema Registry Integration**: Work with Confluent Schema Registry
- **Schema Evolution**: Support versioning and evolution of schemas
- **Compatibility Checking**: Ensure backward compatibility
- **Automatic Generation**: Generate JSON schemas from command and event classes

### Process Managers

- **Orchestration**: Manage complex workflows across multiple aggregates
- **Stateful Processing**: Maintain process state through events
- **Event-Driven Flow**: React to events to advance processes
- **Error Handling**: Built-in compensation logic for failures

## Architecture

Akces is organized into several Maven modules:

- **api**: Core interfaces and annotations defining the programming model
- **runtime**: Implementation of event sourcing and command handling
- **shared**: Common utilities, serialization, and GDPR functionality
- **client**: Client library for sending commands and processing responses
- **query-support**: Support for query models and database models

## Getting Started

### Prerequisites

- Java 21 or higher
- Apache Kafka 3.x with KRaft mode enabled
- Confluent Schema Registry
- Maven 3.6 or higher

### Maven Dependencies

Add the following to your `pom.xml`:

```xml
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-api</artifactId>
    <version>0.9.0</version>
</dependency>

<!-- For command senders -->
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-client</artifactId>
    <version>0.9.0</version>
</dependency>

<!-- For aggregate services -->
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-runtime</artifactId>
    <version>0.9.0</version>
</dependency>

<!-- For query models and database models -->
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-query-support</artifactId>
    <version>0.9.0</version>
</dependency>
```

### Configuration

Configure the framework in your `application.yaml`:

```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      enable-auto-commit: false
      isolation-level: read_committed
      max-poll-records: 500
      heartbeat-interval: 2000
      auto-offset-reset: latest
      properties:
        max.poll.interval.ms: 10000
        session.timeout.ms: 30000
        partition.assignment.strategy: org.apache.kafka.clients.consumer.CooperativeStickyAssignor
    producer:
      acks: all
      retries: 2147483647
      properties:
        linger.ms: 0
        retry.backoff.ms: 0
        enable.idempotence: true
        max.in.flight.requests.per.connection: 1

akces:
  schemaregistry:
    url: http://localhost:8081
  rocksdb:
    baseDir: /tmp/akces
```

## Usage Examples

### Defining an Aggregate

```java
@AggregateInfo(value = "Wallet", version = 1, indexed = true, indexName = "Wallets")
public final class Wallet implements Aggregate<WalletState> {
    @Override
    public Class<WalletState> getStateClass() {
        return WalletState.class;
    }

    @CommandHandler(create = true, produces = {WalletCreatedEvent.class, BalanceCreatedEvent.class})
    public Stream<DomainEvent> create(CreateWalletCommand cmd, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(cmd.id()), 
                         new BalanceCreatedEvent(cmd.id(), cmd.currency()));
    }

    @EventSourcingHandler(create = true)
    public WalletState create(WalletCreatedEvent event, WalletState isNull) {
        return new WalletState(event.id(), new ArrayList<>());
    }
    
    @EventSourcingHandler
    public WalletState createBalance(BalanceCreatedEvent event, WalletState state) {
        List<WalletState.Balance> balances = new ArrayList<>(state.balances());
        balances.add(new WalletState.Balance(event.currency(), BigDecimal.ZERO));
        return new WalletState(state.id(), balances);
    }
    
    @CommandHandler(produces = {WalletCreditedEvent.class})
    public Stream<DomainEvent> credit(CreditWalletCommand cmd, WalletState currentState) {
        WalletState.Balance balance = currentState.balances().stream()
                .filter(b -> b.currency().equals(cmd.currency()))
                .findFirst()
                .orElse(null);
                
        if (balance == null) {
            return Stream.of(new InvalidCurrencyErrorEvent(cmd.id(), cmd.currency()));
        }
        
        if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {
            return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
        }
        
        return Stream.of(new WalletCreditedEvent(currentState.id(), 
                                               cmd.currency(), 
                                               cmd.amount(), 
                                               balance.amount().add(cmd.amount())));
    }
}
```

### Defining the Aggregate State

```java
public record WalletState(String id, List<Balance> balances) implements AggregateState {
    @Override
    public String getAggregateId() {
        return id();
    }

    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(String currency, BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }

        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}
```

### Creating Commands

```java
@CommandInfo(type = "CreateWallet", version = 1)
public record CreateWalletCommand(
    @AggregateIdentifier 
    @NotNull String id, 
    
    @NotNull String currency
) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@CommandInfo(type = "CreditWallet", version = 1)
public record CreditWalletCommand(
    @AggregateIdentifier 
    @NotNull String id,
    
    @NotNull String currency,
    
    @NotNull BigDecimal amount
) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Creating Events

```java
@DomainEventInfo(type = "WalletCreated", version = 1)
public record WalletCreatedEvent(
    @AggregateIdentifier 
    @NotNull String id
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@DomainEventInfo(type = "BalanceCreated", version = 1)
public record BalanceCreatedEvent(
    @AggregateIdentifier 
    @NotNull String id, 
    
    @NotNull String currency
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@DomainEventInfo(type = "WalletCredited", version = 1)
public record WalletCreditedEvent(
    @AggregateIdentifier 
    @NotNull String id,
    
    @NotNull String currency,
    
    @NotNull BigDecimal amount,
    
    @NotNull BigDecimal newBalance
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Error Events

```java
@DomainEventInfo(type = "InvalidCurrencyError", version = 1)
public record InvalidCurrencyErrorEvent(
    @AggregateIdentifier 
    @NotNull String walletId,
    
    @NotNull String currency
) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return walletId();
    }
}

@DomainEventInfo(type = "InvalidAmountError", version = 1)
public record InvalidAmountErrorEvent(
    @AggregateIdentifier 
    @NotNull String walletId,
    
    @NotNull String currency
) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return walletId();
    }
}
```

### Sending Commands

```java
@Service
public class WalletService {
    private final AkcesClient akcesClient;
    
    @Autowired
    public WalletService(AkcesClient akcesClient) {
        this.akcesClient = akcesClient;
    }
    
    public String createWallet(String currency) {
        String walletId = UUID.randomUUID().toString();
        CreateWalletCommand command = new CreateWalletCommand(walletId, currency);
        
        // Send command and wait for response
        List<DomainEvent> events = akcesClient.send("DEFAULT_TENANT", command)
            .toCompletableFuture()
            .join();
            
        // Check for success
        if (events.stream().anyMatch(e -> e instanceof ErrorEvent)) {
            throw new RuntimeException("Failed to create wallet");
        }
        
        return walletId;
    }
    
    public void creditWallet(String walletId, String currency, BigDecimal amount) {
        CreditWalletCommand command = new CreditWalletCommand(walletId, currency, amount);
        
        try {
            // Send command without waiting for response
            akcesClient.sendAndForget("DEFAULT_TENANT", command);
        } catch (CommandRefusedException e) {
            // Handle specific command exceptions
            throw new RuntimeException("Command refused: " + e.getMessage());
        } catch (CommandValidationException e) {
            throw new RuntimeException("Invalid command: " + e.getMessage());
        }
    }
}
```

### Creating a Query Model

```java
@QueryModelInfo(value = "WalletQuery", version = 1, indexName = "Wallets")
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    @Override
    public Class<WalletQueryModelState> getStateClass() {
        return WalletQueryModelState.class;
    }
    
    @Override
    public String getIndexName() {
        return "Wallets";
    }

    @QueryModelEventHandler(create = true)
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        return new WalletQueryModelState(event.id(), List.of());
    }
    
    @QueryModelEventHandler
    public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState state) {
        List<WalletQueryModelState.Balance> balances = new ArrayList<>(state.balances());
        balances.add(new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO));
        return new WalletQueryModelState(state.walletId(), balances);
    }
    
    @QueryModelEventHandler
    public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState state) {
        return new WalletQueryModelState(
            state.walletId(),
            state.balances().stream()
                .map(balance -> {
                    if (balance.currency().equals(event.currency())) {
                        return new WalletQueryModelState.Balance(
                            balance.currency(),
                            balance.amount().add(event.amount()),
                            balance.reservedAmount()
                        );
                    }
                    return balance;
                })
                .toList()
        );
    }
}

public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
    @Override
    public String getIndexKey() {
        return walletId();
    }
    
    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(String currency, BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }
        
        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}
```

### Querying a Model

```java
@RestController
@RequestMapping("/wallets")
public class WalletController {
    private final QueryModels queryModels;
    
    @Autowired
    public WalletController(QueryModels queryModels) {
        this.queryModels = queryModels;
    }
    
    @GetMapping("/{walletId}")
    public ResponseEntity<WalletQueryModelState> getWallet(@PathVariable String walletId) {
        try {
            WalletQueryModelState wallet = queryModels.getHydratedState(WalletQueryModel.class, walletId)
                .toCompletableFuture()
                .get(5, TimeUnit.SECONDS);
                
            return ResponseEntity.ok(wallet);
        } catch (QueryModelIdNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(500).build();
        }
    }
}
```

### Creating a Database Model

```java
@DatabaseModelInfo(value = "WalletDB", version = 1)
public class WalletDatabaseModel extends JdbcDatabaseModel {

    @Autowired
    public WalletDatabaseModel(JdbcTemplate jdbcTemplate, PlatformTransactionManager transactionManager) {
        super(jdbcTemplate, transactionManager);
    }
    
    @DatabaseModelEventHandler
    public void handle(WalletCreatedEvent event) {
        jdbcTemplate.update(
            "INSERT INTO wallets (wallet_id, created_at) VALUES (?, NOW())",
            event.id()
        );
    }
    
    @DatabaseModelEventHandler
    public void handle(BalanceCreatedEvent event) {
        jdbcTemplate.update(
            "INSERT INTO wallet_balances (wallet_id, currency, amount, reserved_amount) VALUES (?, ?, 0, 0)",
            event.id(),
            event.currency()
        );
    }
    
    @DatabaseModelEventHandler
    public void handle(WalletCreditedEvent event) {
        jdbcTemplate.update(
            "UPDATE wallet_balances SET amount = ? WHERE wallet_id = ? AND currency = ?",
            event.newBalance(),
            event.id(),
            event.currency()
        );
    }
}
```

### GDPR and PII Data

Akces provides built-in support for handling personal identifiable information (PII):

```java
@AggregateStateInfo(value = "UserState", version = 1)
public record UserState(
    @AggregateIdentifier 
    String userId,
    
    String country,
    
    @PIIData 
    String firstName,
    
    @PIIData 
    String lastName,
    
    @PIIData 
    String email
) implements AggregateState {
    @Override
    public String getAggregateId() {
        return userId();
    }
}
```

With this annotation, the framework automatically:
- Encrypts PII data before storing it
- Decrypts PII data when loading it
- Manages encryption keys securely
- Ensures only authorized access to decrypted data

### Process Managers

For coordinating complex workflows across multiple aggregates:

```java
@AggregateInfo(value = "OrderProcessManager", version = 1)
public class OrderProcessManager implements ProcessManager<OrderProcessManagerState, OrderProcess> {
    
    @Override
    public Class<OrderProcessManagerState> getStateClass() {
        return OrderProcessManagerState.class;
    }
    
    @EventHandler(create = true)
    public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
        return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
    }
    
    @EventSourcingHandler(create = true)
    public OrderProcessManagerState create(UserOrderProcessesCreatedEvent event, OrderProcessManagerState isNull) {
        return new OrderProcessManagerState(event.userId());
    }
    
    @CommandHandler
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
        String orderId = UUID.randomUUID().toString();
        
        // Reserve funds first - send command to Wallet aggregate
        getCommandBus().send(new ReserveAmountCommand(
            state.userId(),
            command.market().quoteCurrency(),
            command.quantity().multiply(command.limitPrice()),
            orderId
        ));
        
        // Create order record
        return Stream.of(new BuyOrderCreatedEvent(
            state.userId(),
            orderId,
            command.market(),
            command.quantity(),
            command.limitPrice(),
            command.clientReference()
        ));
    }
    
    @EventHandler
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(event.referenceId())) {
            OrderProcess process = state.getAkcesProcess(event.referenceId());
            return Stream.of(new BuyOrderPlacedEvent(
                state.userId(),
                process.orderId(),
                process.market(),
                process.quantity(),
                process.limitPrice()
            ));
        }
        return Stream.empty();
    }
    
    @EventHandler
    public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(errorEvent.referenceId())) {
            return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
        }
        return Stream.empty();
    }
}
```

## Schema Evolution

Akces supports evolving your domain model over time:

```java
// Original version
@DomainEventInfo(type = "AccountCreated", version = 1)
public record AccountCreatedEvent(
    @AggregateIdentifier String userId,
    String country,
    String firstName,
    String lastName,
    String email
) implements DomainEvent { 
    @Override
    public String getAggregateId() {
        return userId();
    }
}

// New version with additional field
@DomainEventInfo(type = "AccountCreated", version = 2)
public record AccountCreatedEventV2(
    @AggregateIdentifier String userId,
    String country,
    String firstName,
    String lastName,
    String email,
    Boolean twoFactorEnabled
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

// The upcasting handler
@UpcastingHandler
public AccountCreatedEventV2 cast(AccountCreatedEvent event) {
    return new AccountCreatedEventV2(
        event.userId(), 
        event.country(), 
        event.firstName(), 
        event.lastName(), 
        event.email(), 
        false // Default value for new field
    );
}
```

## Running the Framework

### Aggregate Service

```java
@SpringBootApplication
public class AggregateServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AggregateServiceApplication.class, args);
    }
}
```

### Query Service

```java
@SpringBootApplication
public class QueryServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(QueryServiceApplication.class, args);
    }
}
```

### Client Application

```java
@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}
```

## Benefits of Using Akces

- **Scalability**: Built on Kafka for horizontal scaling across multiple nodes
- **Reliability**: Event sourcing ensures data integrity and complete audit trails
- **Flexibility**: Clean separation of commands and queries with CQRS
- **Performance**: Efficient state management with RocksDB and optimized query models
- **Security**: Built-in GDPR compliance with transparent PII handling
- **Evolution**: Schema evolution with backward compatibility checks
- **Developer Experience**: Intuitive annotation-based programming model
- **Observability**: Complete visibility into all commands and events

## License

Apache License 2.0

## Release Process

This project uses the Maven Release Plugin and GitHub Actions to create releases.
Run `mvn release:prepare release:perform && git push` to select the version to be released and create a VCS tag.

GitHub Actions will start [the build process](https://github.com/elasticsoftwarefoundation/akces-framework/actions/workflows/maven-publish.yml).

If successful, the build will be automatically published to [Github Packages](https://maven.pkg.github.com/elasticsoftwarefoundation/akces-framework/).

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingQueryApiTest.java
================
public class CryptoTradingQueryApiTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withEnv("SCHEMA_REGISTRY_SCHEMA_COMPATIBILITY_LEVEL","none")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
.withDatabaseName("cryptotrading")
.withUsername("akces")
.withPassword("akces")
⋮----
.withNetworkAliases("postgresql");
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void contextLoads() {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(orderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
assertThat(accountWebController).isNotNull();
assertThat(walletWebController).isNotNull();
assertThat(accountQueryController).isNotNull();
assertThat(cryptoMarketsQueryController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!orderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void testCreateAccount() {
⋮----
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
webTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
⋮----
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
⋮----
void testCreateAccountAndCreditWallet() {
⋮----
CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
.bodyValue(creditInput)
⋮----
.expectBody(BalanceOutput.class)
.value(creditOutput -> {
assertThat(creditOutput).isNotNull();
assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
assertThat(creditOutput.currency()).isEqualTo("EUR");
⋮----
void testCreateAccountAndCreditWalletWithoutBalance() {
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
⋮----
.expectStatus().is4xxClientError()
.expectBody(ErrorEventResponse.class)
.value(response -> {
assertThat(response).isNotNull();
assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
⋮----
void testCreateAccountAndAddBtcBalance() {
⋮----
CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances")
.bodyValue(createBalanceInput)
⋮----
.expectStatus().is2xxSuccessful();
⋮----
void testGetAccount() {
⋮----
AccountInput accountInput = new AccountInput("US", "John", "Doe", "john.doe@example.com");
⋮----
.uri("/v1/accounts/" + accountOutput.userId())
⋮----
.value(retrievedAccount -> {
assertThat(retrievedAccount).isNotNull();
assertThat(retrievedAccount.userId()).isEqualTo(accountOutput.userId());
assertThat(retrievedAccount.country()).isEqualTo("US");
assertThat(retrievedAccount.firstName()).isEqualTo("John");
assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
⋮----
void testInvalidApiVersion() {
⋮----
.uri("/v13/accounts/invalid-id")
⋮----
.expectStatus().isNotFound();
⋮----
void testCryptoMarkets() {
⋮----
while(cryptoMarketRepository.count() == 0) {
⋮----
assertNotNull(cryptoMarketRepository.findById("BTC-EUR").orElse(null));
⋮----
void testCryptoMarket() {
⋮----
.uri("/v1/markets/BTC-EUR")
⋮----
.expectBody()
.jsonPath("$.id").isEqualTo("BTC-EUR")
.jsonPath("$.baseCrypto").isEqualTo("BTC")
.jsonPath("$.quoteCrypto").isEqualTo("EUR");
⋮----
void testPlaceBuyOrder() {
⋮----
AccountOutput accountOutput = webTestClient.post()
⋮----
.returnResult()
.getResponseBody();
⋮----
String userId = accountOutput.userId();
⋮----
.uri("/v1/wallets/" + userId + "/balances/EUR/credit")
.bodyValue(new CreditWalletInput(new BigDecimal("10000.0")))
⋮----
.uri("/v1/wallets/" + userId + "/balances")
.bodyValue(new CreateBalanceInput("BTC"))
⋮----
BuyOrderInput buyOrderInput = new BuyOrderInput("BTC-EUR", new BigDecimal("1000"), "client-ref-1");
⋮----
.uri("/v1/accounts/" + userId + "/orders/buy")
.bodyValue(buyOrderInput)
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
prepareDomainEventSchemas(
"http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
List.of(
⋮----
prepareCommandSchemas("http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
"spring.datasource.url=" + postgresql.getJdbcUrl(),

================
File: test-apps/crypto-trading/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-test-apps</artifactId>
        <version>0.9.1-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-parent</artifactId>
    <packaging>pom</packaging>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <modules>
        <module>aggregates</module>
        <module>commands</module>
        <module>queries</module>
    </modules>

    <build>
        <plugins>
        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/commands/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.9.1-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-commands</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Command Services</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>provided</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <executions>
                    <execution>
                        <id>shared-web-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>shared-web</classifier>
                            <includes>
                                <include>**/dto/*</include>
                                <include>**/errors/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/queries/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.9.1-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-queries</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Query Services</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-query-support</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>services</classifier>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <classifier>shared-web</classifier>
            <version>${project.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.elasticsoftwarefoundation.akces</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jdbc</artifactId>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>

        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/aggregates/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.9.1-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-aggregates</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Aggregates</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-runtime</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-eventcatalog</artifactId>
            <scope>provided</scope>
        </dependency>


    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <compilerArgs>
                        <arg>-Aeventcatalog.repositoryBaseUrl=https://github.com/elasticsoftwarefoundation/akces-framework/tree/main/test-apps/crypto-trading/aggregates/src/main/java</arg>
                        <arg>-Aeventcatalog.owners=framework-developers</arg>
                        <arg>-Aeventcatalog.schemaDomain=crypto-trading</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <id>process-aot</id>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.AggregateConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>






                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <executions>
                    <execution>
                        <id>commands-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>commands</classifier>
                            <includes>
                                <include>**/commands/*</include>
                                <include>**/data/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>events-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>events</classifier>
                            <includes>
                                <include>**/events/*</include>
                                <include>**/data/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>services-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>services</classifier>
                            <includes>
                                <include>**/services/**</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>






        </plugins>
    </build>

</project>

================
File: test-apps/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-parent</artifactId>
        <version>0.9.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>akces-framework-test-apps</artifactId>
    <packaging>pom</packaging>

    <name>Elastic Software Foundation :: Akces :: Test Apps</name>
    <url>https://github.com/elasticsoftwarefoundation/akces-framework</url>

    <properties>
        <akces-framework.version>${project.version}</akces-framework.version>
    </properties>

    <repositories>
        <repository>
            <id>github</id>
            <name>Akces Github Packages Repository</name>
            <url>https://github.com/elasticsoftwarefoundation/akces-framework/packages</url>
        </repository>
        <repository>
            <id>central</id>
            <name>Maven Central</name>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
    </repositories>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-api</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-shared</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-runtime</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-client</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-query-support</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-eventcatalog</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.checkerframework</groupId>
                <artifactId>checker-qual</artifactId>
                <version>3.49.1</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-text</artifactId>
                <version>1.12.0</version>
            </dependency>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava-bom</artifactId>
                <version>${guava.version}</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>com.github.ben-manes.caffeine</groupId>
                <artifactId>caffeine</artifactId>
                <version>${caffeine.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>com.google.errorprone</groupId>
                        <artifactId>error_prone_annotations</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <modules>
        <module>crypto-trading</module>
    </modules>
    <build>
        <plugins>
            <plugin>

                <artifactId>maven-deploy-plugin</artifactId>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <profile>
            <id>maven-release</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <configuration>
                            <docker>
                                <publishRegistry>
                                    <username>${env.GITHUB_ACTOR}</username>
                                    <password>${env.GITHUB_TOKEN}</password>
                                    <url>docker://ghcr.io</url>
                                </publishRegistry>
                            </docker>
                            <image>
                                <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}</name>
                                <publish>true</publish>
                                <env>
                                    <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                    <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    <BP_SPRING_AOT_ENABLED>true</BP_SPRING_AOT_ENABLED>
                                    <BP_JVM_CDS_ENABLED>false</BP_JVM_CDS_ENABLED>
                                    <JAVA_TOOL_OPTIONS>-XX:+UseZGC -XX:+ZGenerational</JAVA_TOOL_OPTIONS>
                                </env>
                                <buildpacks>
                                    <buildpack>gcr.io/paketo-buildpacks/ca-certificates</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/adoptium:latest</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/syft</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/executable-jar</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/spring-boot</buildpack>
                                </buildpacks>
                            </image>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>process-aot</goal>
                                </goals>
                                <configuration>

                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>native</id>
            <build>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-jar-plugin</artifactId>
                            <configuration>
                                <archive>
                                    <manifestEntries>
                                        <Spring-Boot-Native-Processed>true</Spring-Boot-Native-Processed>
                                    </manifestEntries>
                                </archive>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                            <executions>
                                <execution>
                                    <id>process-aot</id>
                                    <goals>
                                        <goal>process-aot</goal>
                                    </goals>
                                </execution>
                            </executions>
                            <configuration>
                                <docker>
                                    <publishRegistry>
                                        <username>${env.GITHUB_ACTOR}</username>
                                        <password>${env.GITHUB_TOKEN}</password>
                                        <url>docker://ghcr.io</url>
                                    </publishRegistry>
                                </docker>
                                <image>
                                    <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                    <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                    <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}
                                    </name>
                                    <publish>true</publish>
                                    <env>
                                        <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                        <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    </env>
                                </image>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.graalvm.buildtools</groupId>
                            <artifactId>native-maven-plugin</artifactId>
                            <configuration>
                                <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                                <requiredVersion>22.3</requiredVersion>
                            </configuration>
                            <executions>
                                <execution>
                                    <id>add-reachability-metadata</id>
                                    <goals>
                                        <goal>add-reachability-metadata</goal>
                                    </goals>
                                </execution>
                                <execution>
                                    <id>build-native</id>
                                    <goals>
                                        <goal>compile-no-fork</goal>
                                    </goals>
                                    <phase>package</phase>
                                </execution>
                            </executions>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
        <profile>
            <id>nativeTest</id>
            <dependencies>
                <dependency>
                    <groupId>org.junit.platform</groupId>
                    <artifactId>junit-platform-launcher</artifactId>
                    <scope>test</scope>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>process-test-aot</id>
                                <goals>
                                    <goal>process-test-aot</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <configuration>
                            <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                            <requiredVersion>22.3</requiredVersion>
                        </configuration>
                        <executions>
                            <execution>
                                <id>native-test</id>
                                <goals>
                                    <goal>test</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>



================================================================
End of Codebase
================================================================
