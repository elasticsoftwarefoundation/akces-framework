This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where comments have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.md, test-apps/**/*.java, test-apps/**/*.xml, test-apps/**/*.properties, test-apps/**/*.proto, test-apps/**/*.imports, test-apps/**/*.yaml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Content has been compressed - code blocks are separated by ⋮---- delimiter

Additional Info:
----------------

================================================================
Directory Structure
================================================================
test-apps/
  crypto-trading/
    aggregates/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  aggregates/
                    account/
                      commands/
                        CreateAccountCommand.java
                      events/
                        AccountCreatedEvent.java
                      Account.java
                      AccountState.java
                    cryptomarket/
                      commands/
                        CreateCryptoMarketCommand.java
                        PlaceMarketOrderCommand.java
                      data/
                        Side.java
                      events/
                        CryptoMarketCreatedEvent.java
                        MarketOrderFilledEvent.java
                        MarketOrderPlacedEvent.java
                        MarketOrderRejectedErrorEvent.java
                      CryptoMarket.java
                      CryptoMarketState.java
                    orders/
                      commands/
                        FillBuyOrderCommand.java
                        PlaceBuyOrderCommand.java
                        RejectOrderCommand.java
                      data/
                        CryptoMarket.java
                      events/
                        BuyOrderCreatedEvent.java
                        BuyOrderFilledEvent.java
                        BuyOrderPlacedEvent.java
                        BuyOrderRejectedEvent.java
                        UserOrderProcessesCreatedEvent.java
                      BuyOrderProcess.java
                      OrderProcess.java
                      OrderProcessManager.java
                      OrderProcessManagerState.java
                      OrderProcessState.java
                    wallet/
                      commands/
                        CreateBalanceCommand.java
                        CreateWalletCommand.java
                        CreditWalletCommand.java
                        ReserveAmountCommand.java
                      events/
                        AmountReservedEvent.java
                        BalanceAlreadyExistsErrorEvent.java
                        BalanceCreatedEvent.java
                        InsufficientFundsErrorEvent.java
                        InvalidAmountErrorEvent.java
                        InvalidCryptoCurrencyErrorEvent.java
                        WalletCreatedEvent.java
                        WalletCreditedEvent.java
                      Wallet.java
                      WalletState.java
                  services/
                    coinbase/
                      CoinbaseService.java
                      Order.java
                      Product.java
                      Ticker.java
                  AggregateConfig.java
          resources/
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CoinbaseMarketDataTest.java
                  CoinbaseServiceTest.java
                  CryptoTradingApplicationTest.java
                  TestUtils.java
          resources/
            akces-client.properties
            logback-test.xml
      pom.xml
    commands/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  web/
                    dto/
                      AccountInput.java
                      AccountOutput.java
                      BalanceOutput.java
                      BuyOrderInput.java
                      CreateBalanceInput.java
                      CreditWalletInput.java
                      OrderInput.java
                      OrderOutput.java
                    errors/
                      ErrorEventException.java
                      ErrorEventResponse.java
                      GlobalExceptionHandler.java
                    AccountCommandController.java
                    OrdersCommandController.java
                    WalletCommandController.java
                  ClientConfig.java
          resources/
            akces-framework.properties
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CryptoTradingCommandApiTest.java
                  TestUtils.java
          resources/
            logback-test.xml
      pom.xml
    queries/
      src/
        main/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  query/
                    jdbc/
                      CryptoMarket.java
                      CryptoMarketRepository.java
                    AccountQueryModel.java
                    AccountQueryModelState.java
                    CryptoMarketModel.java
                    WalletQueryModel.java
                    WalletQueryModelState.java
                  services/
                    CryptoMarketsService.java
                  web/
                    AccountQueryController.java
                    CryptoMarketsQueryController.java
                    WalletQueryController.java
                  ClientConfig.java
          resources/
            db/
              changelog/
                db.changelog-master.xml
            akces-framework.properties
            application.properties
        test/
          java/
            org/
              elasticsoftware/
                cryptotrading/
                  CryptoTradingE2ETests.java
                  CryptoTradingQueryApiTest.java
                  TestUtils.java
          resources/
            application-test.properties
            logback-test.xml
      pom.xml
    pom.xml
  pom.xml
FRAMEWORK_OVERVIEW.md
README.md
RELEASE.md

================================================================
Files
================================================================

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/commands/CreateAccountCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/events/AccountCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/Account.java
================
public final class Account implements Aggregate<AccountState> {
⋮----
public String getName() {
⋮----
public Class<AccountState> getStateClass() {
⋮----
public Stream<AccountCreatedEvent> create(CreateAccountCommand cmd, AccountState isNull) {
return Stream.of(new AccountCreatedEvent(cmd.userId(), cmd.country(), cmd.firstName(), cmd.lastName(), cmd.email()));
⋮----
public AccountState create(@NotNull AccountCreatedEvent event, AccountState isNull) {
return new AccountState(event.userId(), event.country(), event.firstName(), event.lastName(), event.email());

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/AccountState.java
================
@NotNull @PIIData String email) implements AggregateState {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/CreateCryptoMarketCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/PlaceMarketOrderCommand.java
================
BigDecimal size) implements Command {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/data/Side.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/CryptoMarketCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderFilledEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderPlacedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderRejectedErrorEvent.java
================
@NotNull String rejectionReason) implements ErrorEvent {
⋮----
public String getAggregateId() {
return marketId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarket.java
================
public class CryptoMarket implements Aggregate<CryptoMarketState> {
⋮----
private final MathContext mathContext = new MathContext(8);
⋮----
public String getName() {
⋮----
public Class<CryptoMarketState> getStateClass() {
⋮----
public @NotNull Stream<DomainEvent> handle(@NotNull CreateCryptoMarketCommand command, CryptoMarketState isNull) {
return Stream.of(new CryptoMarketCreatedEvent(command.id(),
command.baseCurrency(),
command.quoteCurrency(),
command.baseIncrement(),
command.quoteIncrement(),
command.defaultCounterPartyId()));
⋮----
public @NotNull Stream<DomainEvent> handle(@NotNull PlaceMarketOrderCommand command, CryptoMarketState currentState) {
if (command.side().equals(Side.BUY) && command.funds() == null) {
return Stream.of(new MarketOrderRejectedErrorEvent(command.marketId(),
command.orderId(),
command.ownerId(),
⋮----
} else if (command.side().equals(Side.SELL) && command.size() == null) {
⋮----
Ticker currentTicker = coinbaseService.getTicker(currentState.id());
⋮----
BigDecimal price = command.side().equals(Side.BUY) ? new BigDecimal(currentTicker.ask()) : new BigDecimal(currentTicker.bid());
⋮----
BigDecimal quantity = command.side().equals(Side.BUY) ? command.funds().divide(price, mathContext) : command.size();
MarketOrderFilledEvent marketOrderFilledEvent = new MarketOrderFilledEvent(command.marketId(),
⋮----
currentState.defaultCounterPartyId(),
command.side(),
currentState.baseCrypto(),
currentState.quoteCrypto(),
⋮----
MarketOrderPlacedEvent marketOrderPlacedEvent = new MarketOrderPlacedEvent(command.marketId(),
⋮----
command.funds(),
command.size());
return Stream.of(marketOrderPlacedEvent, marketOrderFilledEvent);
⋮----
public @NotNull CryptoMarketState apply(@NotNull CryptoMarketCreatedEvent event, CryptoMarketState isNull) {
return new CryptoMarketState(event.id(),
event.baseCrypto(),
event.quoteCrypto(),
event.baseIncrement(),
event.quoteIncrement(),
event.defaultCounterPartyId());
⋮----
public @NotNull CryptoMarketState apply(@NotNull MarketOrderPlacedEvent event, CryptoMarketState currentState) {
⋮----
public @NotNull CryptoMarketState apply(@NotNull MarketOrderFilledEvent event, CryptoMarketState currentState) {

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarketState.java
================
) implements AggregateState {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/FillBuyOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/PlaceBuyOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/RejectOrderCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/data/CryptoMarket.java
================
public static CryptoMarket fromId(String id) {
String[] split = id.split("-");
return new CryptoMarket(id, split[0], split[1]);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return orderId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderFilledEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderPlacedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return orderId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderRejectedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/UserOrderProcessesCreatedEvent.java
================
public record UserOrderProcessesCreatedEvent(@NotNull @AggregateIdentifier String userId) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/BuyOrderProcess.java
================
) implements OrderProcess {
⋮----
public String getProcessId() {
return orderId();
⋮----
public BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error) {
return new BuyOrderRejectedEvent(error.walletId(), orderId(), clientReference());
⋮----
public BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error) {
⋮----
public BuyOrderRejectedEvent handle(RejectOrderCommand command) {
return new BuyOrderRejectedEvent(command.userId(), orderId(), clientReference());
⋮----
public OrderProcess withState(OrderProcessState state) {
return new BuyOrderProcess(orderId(), market, size(), amount(), clientReference(), state);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcess.java
================
public sealed interface OrderProcess extends AkcesProcess permits BuyOrderProcess {
String orderId();
⋮----
CryptoMarket market();
⋮----
BigDecimal size();
⋮----
BigDecimal amount();
⋮----
String clientReference();
⋮----
OrderProcessState state();
⋮----
BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error);
⋮----
BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error);
⋮----
BuyOrderRejectedEvent handle(RejectOrderCommand command);
⋮----
OrderProcess withState(OrderProcessState state);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManager.java
================
public class OrderProcessManager implements Aggregate<OrderProcessManagerState> {
⋮----
public String getName() {
⋮----
public Class<OrderProcessManagerState> getStateClass() {
⋮----
public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
⋮----
public OrderProcessManagerState create(UserOrderProcessesCreatedEvent event, OrderProcessManagerState isNull) {
return new OrderProcessManagerState(event.userId());
⋮----
public OrderProcessManagerState handle(BuyOrderCreatedEvent event, OrderProcessManagerState state) {
return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
add(new BuyOrderProcess(
event.orderId(),
event.market(),
event.amount(),
event.clientReference()));
⋮----
public OrderProcessManagerState handle(BuyOrderRejectedEvent event, OrderProcessManagerState state) {
⋮----
removeIf(process -> process.orderId().equals(event.orderId()));
⋮----
public OrderProcessManagerState handle(BuyOrderPlacedEvent event, OrderProcessManagerState state) {
⋮----
replaceAll(process -> process.orderId().equals(event.orderId())
? process.withState(OrderProcessState.PLACED)
⋮----
public OrderProcessManagerState handle(BuyOrderFilledEvent event, OrderProcessManagerState state) {
⋮----
public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
⋮----
String orderId = UUID.randomUUID().toString();
⋮----
getCommandBus().send(new ReserveAmountCommand(
state.userId(),
command.market().quoteCrypto(),
command.amount(),
⋮----
return Stream.of(new BuyOrderCreatedEvent(
⋮----
command.market(),
⋮----
command.clientReference()));
⋮----
public Stream<BuyOrderRejectedEvent> rejectOrder(RejectOrderCommand command, OrderProcessManagerState state) {
if (state.hasAkcesProcess(command.orderId())) {
return Stream.of(state.getAkcesProcess(command.orderId()).handle(command));
⋮----
return Stream.empty();
⋮----
public Stream<BuyOrderFilledEvent> fillOrder(FillBuyOrderCommand command, OrderProcessManagerState state) {
⋮----
return Stream.of(new BuyOrderFilledEvent(
command.userId(),
command.orderId(),
command.counterpartyId(),
command.price(),
command.quantity(),
command.baseCurrency(),
command.quoteCurrency()
⋮----
public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
⋮----
OrderProcess orderProcess = state.getAkcesProcess(event.referenceId());
⋮----
getCommandBus().send(new PlaceMarketOrderCommand(
orderProcess.market().id(),
orderProcess.orderId(),
⋮----
orderProcess.amount(),
⋮----
return Stream.of(new BuyOrderPlacedEvent(state.userId(), orderProcess.orderId(), orderProcess.market(), orderProcess.amount(), null));
⋮----
public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
if (state.hasAkcesProcess(errorEvent.referenceId())) {
return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
⋮----
public Stream<DomainEvent> handle(InvalidCryptoCurrencyErrorEvent errorEvent, OrderProcessManagerState state) {
⋮----
public void handle(MarketOrderRejectedErrorEvent errorEvent, CommandBus commandBus) {
⋮----
commandBus.send(new RejectOrderCommand(errorEvent.ownerId(), errorEvent.orderId()));
⋮----
public void handle(MarketOrderFilledEvent event, CommandBus commandBus) {
switch (event.side()) {
⋮----
commandBus.send(new FillBuyOrderCommand(
event.ownerId(),
⋮----
event.counterpartyId(),
event.price(),
event.quantity(),
event.baseCurrency(),
event.quoteCurrency()

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManagerState.java
================
this(userId, List.of());
⋮----
public String getAggregateId() {
return userId();
⋮----
public OrderProcess getAkcesProcess(String processId) {
return runningProcesses.stream().filter(p -> p.orderId().equals(processId)).findFirst()
.orElseThrow(() -> new UnknownAkcesProcessException("OrderProcessManager", userId(), processId));
⋮----
public boolean hasAkcesProcess(String processId) {
return runningProcesses.stream().anyMatch(p -> p.orderId().equals(processId));

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessState.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateBalanceCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateWalletCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreditWalletCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/ReserveAmountCommand.java
================
) implements Command {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/AmountReservedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return userId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceAlreadyExistsErrorEvent.java
================
@NotNull String currency) implements ErrorEvent {
⋮----
public String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InsufficientFundsErrorEvent.java
================
) implements ErrorEvent {
⋮----
public @NotNull String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidAmountErrorEvent.java
================
) implements ErrorEvent {
⋮----
public @NotNull String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidCryptoCurrencyErrorEvent.java
================
) implements ErrorEvent {
⋮----
public String getAggregateId() {
return walletId();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreatedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreditedEvent.java
================
) implements DomainEvent {
⋮----
public String getAggregateId() {
return id();

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/Wallet.java
================
public final class Wallet implements Aggregate<WalletState> {
⋮----
public String getName() {
⋮----
public Class<WalletState> getStateClass() {
⋮----
public @NotNull Stream<DomainEvent> create(@NotNull CreateWalletCommand cmd, WalletState isNull) {
return Stream.of(new WalletCreatedEvent(cmd.id()), new BalanceCreatedEvent(cmd.id(), cmd.currency()));
⋮----
public @NotNull Stream<DomainEvent> create(@NotNull AccountCreatedEvent event, WalletState isNull) {
return Stream.of(new WalletCreatedEvent(event.getAggregateId()), new BalanceCreatedEvent(event.getAggregateId(), "EUR"));
⋮----
public Stream<DomainEvent> credit(@NotNull CreditWalletCommand cmd, @NotNull WalletState currentState) {
WalletState.Balance balance = currentState.balances().stream().filter(b -> b.currency().equals(cmd.currency())).findFirst().orElse(null);
⋮----
return Stream.of(new InvalidCryptoCurrencyErrorEvent(cmd.id(), cmd.currency()));
⋮----
if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {
⋮----
return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
⋮----
return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), cmd.amount(), balance.amount().add(cmd.amount())));
⋮----
public Stream<DomainEvent> makeReservation(ReserveAmountCommand command, WalletState state) {
WalletState.Balance balance = state.balances().stream().filter(b -> b.currency().equals(command.currency())).findFirst().orElse(null);
⋮----
return Stream.of(new InvalidCryptoCurrencyErrorEvent(command.userId(), command.currency(), command.referenceId()));
⋮----
if (command.amount().compareTo(BigDecimal.ZERO) < 0) {
⋮----
return Stream.of(new InvalidAmountErrorEvent(command.userId(), command.currency()));
⋮----
if (balance.getAvailableAmount().compareTo(command.amount()) >= 0) {
return Stream.of(new AmountReservedEvent(command.userId(), command.currency(), command.amount(), command.referenceId()));
⋮----
return Stream.of(new InsufficientFundsErrorEvent(command.userId(), command.currency(), balance.getAvailableAmount(), command.amount(), command.referenceId()));
⋮----
public @NotNull WalletState create(@NotNull WalletCreatedEvent event, WalletState isNull) {
return new WalletState(event.id(), new ArrayList<>());
⋮----
public @NotNull WalletState createBalance(@NotNull BalanceCreatedEvent event, WalletState state) {
List<WalletState.Balance> balances = new ArrayList<>(state.balances());
balances.add(new WalletState.Balance(event.currency(), BigDecimal.ZERO));
return new WalletState(state.id(), balances);
⋮----
public @NotNull WalletState credit(@NotNull WalletCreditedEvent event, @NotNull WalletState state) {
return new WalletState(state.id(), state.balances().stream().map(b -> {
if (b.currency().equals(event.currency())) {
return new WalletState.Balance(b.currency(), b.amount().add(event.amount()));
⋮----
}).toList());
⋮----
public @NotNull WalletState reserveAmount(@NotNull AmountReservedEvent event, @NotNull WalletState state) {
⋮----
return new WalletState.Balance(b.currency(), b.amount(), b.reservedAmount().add(event.amount()));
⋮----
public @NotNull Stream<DomainEvent> createBalance(@NotNull CreateBalanceCommand cmd, @NotNull WalletState currentState) {
boolean balanceExists = currentState.balances().stream()
.anyMatch(balance -> balance.currency().equals(cmd.currency()));
⋮----
return Stream.of(new BalanceAlreadyExistsErrorEvent(cmd.id(), cmd.currency()));
⋮----
return Stream.of(new BalanceCreatedEvent(cmd.id(), cmd.currency()));

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/WalletState.java
================
) implements AggregateState {
⋮----
public String getAggregateId() {
return id();
⋮----
public BigDecimal getAvailableAmount() {
return amount.subtract(reservedAmount);

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/CoinbaseService.java
================
public class CoinbaseService {
⋮----
public Ticker getTicker(String productId) {
return webClient.get()
.uri("/products/{productId}/ticker", productId)
.retrieve()
.bodyToMono(Ticker.class)
.block();
⋮----
public Product getProduct(String productId) {
⋮----
.uri("/products/{productId}", productId)
⋮----
.bodyToMono(Product.class)
⋮----
public List<Product> getProducts() {
⋮----
.uri("/products")
⋮----
.bodyToFlux(Product.class)
.collectList()

================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Order.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Product.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/services/coinbase/Ticker.java
================


================
File: test-apps/crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/AggregateConfig.java
================
public class AggregateConfig {
⋮----
public WebClient coinbaseWebClient() {
return WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();

================
File: test-apps/crypto-trading/aggregates/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading Command Service
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseMarketDataTest.java
================
public class CoinbaseMarketDataTest {
⋮----
void testCoinbaseGetProducts() {
WebClient webClient = WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();
⋮----
String response = webClient.get()
.uri("/products")
.retrieve()
.bodyToMono(String.class)
.block();
⋮----
System.out.println(response);
⋮----
void testCoinbaseGetSingleProduct() {
⋮----
.uri("/products/BTC-EUR")
⋮----
void testGetCoinbaseTicker() {
⋮----
.uri("/products/BTC-EUR/ticker")

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseServiceTest.java
================
public class CoinbaseServiceTest {
⋮----
public void testGetProductById() {
⋮----
Product product = coinbaseService.getProduct(productId);
assertNotNull(product, "Product should not be null");
⋮----
public void testGetTickerById() {
⋮----
Ticker ticker = coinbaseService.getTicker(productId);
assertNotNull(ticker, "Ticker should not be null");
⋮----
public void testGetProducts() {
List<Product> products = coinbaseService.getProducts();
assertNotNull(products, "Products should not be null");
products.forEach(product -> {
System.out.println(product.id());

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingApplicationTest.java
================
public class CryptoTradingApplicationTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void contextLoads() throws IOException {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(prderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!prderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
try (Consumer<String, AkcesControlRecord> controlConsumer = controlConsumerFactory.createConsumer("Test-AkcesControl", "test-akces-control")) {
TopicPartition controlPartition = new TopicPartition("Akces-Control", 0);
controlConsumer.assign(List.of(controlPartition));
controlConsumer.seekToBeginning(controlConsumer.assignment());
Map<TopicPartition, Long> endOffsets = controlConsumer.endOffsets(controlConsumer.assignment());
⋮----
while (endOffsets.getOrDefault(controlPartition, 0L) > controlConsumer.position(controlPartition)) {
ConsumerRecords<String, AkcesControlRecord> controlRecords = controlConsumer.poll(Duration.ofMillis(1000));
if (!controlRecords.isEmpty()) {
for (ConsumerRecord<String, AkcesControlRecord> record : controlRecords.records(controlPartition)) {
if (record.value() instanceof AggregateServiceRecord aggregateServiceRecord) {
System.out.println(objectMapper.writeValueAsString(aggregateServiceRecord));
serviceRecords.put(record.key(), aggregateServiceRecord);
⋮----
Assertions.assertEquals(4, serviceRecords.size());
⋮----
void testCreateAllEURMarketsAndMakeATrade() {
⋮----
akcesClientController.sendAndForget("TEST",
new CreateAccountCommand(counterPartyId,
⋮----
Product product = coinbaseService.getProduct("BTC-EUR");
akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
Mono.fromCompletionStage(akcesClientController.send("TEST", new CreateAccountCommand(accountId,
⋮----
"john.doe@example.com"))).block();
⋮----
Mono.fromCompletionStage(akcesClientController.send("TEST",
new CreateBalanceCommand(accountId, "BTC"))).block();
⋮----
new CreditWalletCommand(accountId,
⋮----
new BigDecimal("1000")))).block();
⋮----
new PlaceBuyOrderCommand(accountId,
new CryptoMarket("BTC-EUR", "BTC", "EUR"),
new BigDecimal("250"),
clientOrderId))).block();
⋮----
Consumer<String, ProtocolRecord> testConsumer = consumerFactory.createConsumer("Test", "test")
⋮----
testConsumer.subscribe(Pattern.compile(".*-DomainEvents$"), new ConsumerRebalanceListener() {
⋮----
public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
⋮----
public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
testConsumer.seekToBeginning(partitions);
⋮----
for (ConsumerRecord<String, ProtocolRecord> record : testConsumer.poll(Duration.ofMillis(100))) {
Assertions.assertEquals(eventTypes[count],record.value().name());
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: test-apps/crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();

================
File: test-apps/crypto-trading/aggregates/src/test/resources/akces-client.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/aggregates/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/aggregates/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.13-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-aggregates</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Aggregates</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-runtime</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>


    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <id>process-aot</id>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.AggregateConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>






                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <executions>
                    <execution>
                        <id>commands-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>commands</classifier>
                            <includes>
                                <include>**/commands/*</include>
                                <include>**/data/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>events-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>events</classifier>
                            <includes>
                                <include>**/events/*</include>
                                <include>**/data/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>services-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>services</classifier>
                            <includes>
                                <include>**/services/**</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>






        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountInput.java
================
public CreateAccountCommand toCommand(String userId) {
return new CreateAccountCommand(userId, country(), firstName(), lastName(), email());

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountOutput.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BalanceOutput.java
================
public static BalanceOutput from(WalletCreditedEvent event) {
return new BalanceOutput(event.id(), event.currency(), event.amount(), event.balance());
⋮----
public static BalanceOutput from(BalanceCreatedEvent event) {
return new BalanceOutput(event.id(), event.currency(), BigDecimal.ZERO, BigDecimal.ZERO);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BuyOrderInput.java
================
public PlaceBuyOrderCommand toCommand(String accountId) {
return new PlaceBuyOrderCommand(
⋮----
CryptoMarket.fromId(marketId),

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreateBalanceInput.java
================
public CreateBalanceCommand toCommand(String walletId) {
return new CreateBalanceCommand(walletId, this.currency);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreditWalletInput.java
================
public CreditWalletCommand toCommand(String userId, String currency) {
return new CreditWalletCommand(userId, currency, amount);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderInput.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderOutput.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventException.java
================
public class ErrorEventException extends RuntimeException {
⋮----
public ErrorEvent getErrorEvent() {

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventResponse.java
================


================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/GlobalExceptionHandler.java
================
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
⋮----
protected ResponseEntity<ErrorEventResponse> handleErrorEvent(ErrorEventException ex) {
ErrorEvent errorEvent = ex.getErrorEvent();
return ResponseEntity.status(HttpStatus.BAD_REQUEST)
.body(new ErrorEventResponse(errorEvent.getClass().getAnnotation(DomainEventInfo.class).type()));

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/AccountCommandController.java
================
public class AccountCommandController {
⋮----
public Mono<ResponseEntity<AccountOutput>> createAccount(@RequestBody AccountInput input) {
String userId = UUID.randomUUID().toString();
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(userId)))
.map(List::getFirst)
.map(domainEvent -> {
⋮----
AccountOutput output = new AccountOutput(event.userId(), input.country(), input.firstName(), input.lastName(), input.email());
return ResponseEntity.ok(output);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/OrdersCommandController.java
================
public class OrdersCommandController {
⋮----
public Mono<ResponseEntity<OrderOutput>> placeBuyOrder(
⋮----
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(accountId)))
.map(List::getFirst)
.map(domainEvent -> {
⋮----
OrderOutput output = new OrderOutput(
event.orderId(),
event.market(),
⋮----
event.amount(),
event.clientReference()
⋮----
return ResponseEntity.ok(output);

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/WalletCommandController.java
================
public class WalletCommandController {
⋮----
public Mono<ResponseEntity<BalanceOutput>> creditBalance(@PathVariable("walletId") String walletId,
⋮----
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId, currency)))
.map(List::getFirst)
.handle((domainEvent, sink) -> {
⋮----
sink.next(ResponseEntity.ok(BalanceOutput.from((WalletCreditedEvent) domainEvent)));
⋮----
sink.error(new ErrorEventException((ErrorEvent) domainEvent));
⋮----
public Mono<ResponseEntity<BalanceOutput>> createBalance(@PathVariable("walletId") String walletId, @RequestBody CreateBalanceInput input) {
return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId)))
⋮----
sink.next(ResponseEntity.ok(BalanceOutput.from(balanceCreatedEvent)));

================
File: test-apps/crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {

================
File: test-apps/crypto-trading/commands/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/commands/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: test-apps/crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingCommandApiTest.java
================
public class CryptoTradingCommandApiTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void contextLoads() {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(prderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
assertThat(accountWebController).isNotNull();
assertThat(walletWebController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!prderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void testCreateAccount() {
⋮----
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
webTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
⋮----
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
⋮----
void testCreateAccountAndCreditWallet() {
⋮----
CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
.bodyValue(creditInput)
⋮----
.expectBody(BalanceOutput.class)
.value(creditOutput -> {
assertThat(creditOutput).isNotNull();
assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
assertThat(creditOutput.currency()).isEqualTo("EUR");
⋮----
void testCreateAccountAndCreditWalletWithoutBalance() {
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
⋮----
.expectStatus().is4xxClientError()
.expectBody(ErrorEventResponse.class)
.value(response -> {
assertThat(response).isNotNull();
assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
⋮----
void testCreateAccountAndAddBtcBalance() {
⋮----
CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances")
.bodyValue(createBalanceInput)
⋮----
.expectStatus().is2xxSuccessful();
⋮----
void testInvalidApiVersion() {
⋮----
.uri("/v13/accounts/invalid-id")
⋮----
.expectStatus().isNotFound();
⋮----
void testPlaceBuyOrder() {
⋮----
Product product = coinbaseService.getProduct("BTC-EUR");
akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
AccountOutput accountOutput = webTestClient.post()
⋮----
.returnResult()
.getResponseBody();
⋮----
String userId = accountOutput.userId();
⋮----
.uri("/v1/wallets/" + userId + "/balances/EUR/credit")
.bodyValue(new CreditWalletInput(new BigDecimal("10000.0")))
⋮----
.uri("/v1/wallets/" + userId + "/balances")
.bodyValue(new CreateBalanceInput("BTC"))
⋮----
BuyOrderInput buyOrderInput = new BuyOrderInput("BTC-EUR", new BigDecimal("1000"), "client-ref-1");
⋮----
.uri("/v1/accounts/" + userId + "/orders/buy")
.bodyValue(buyOrderInput)
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)

================
File: test-apps/crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();

================
File: test-apps/crypto-trading/commands/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/commands/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.13-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-commands</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Command Services</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>provided</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <executions>
                    <execution>
                        <id>shared-web-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>shared-web</classifier>
                            <includes>
                                <include>**/dto/*</include>
                                <include>**/errors/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/jdbc/CryptoMarket.java
================
public static CryptoMarket createNew(@NotNull String id,
⋮----
return new CryptoMarket(id, baseCrypto, quoteCrypto, baseIncrement, quoteIncrement, defaultCounterPartyId, true);
⋮----
public String getId() {
return id();
⋮----
public boolean createNew() {
⋮----
public boolean isNew() {

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/jdbc/CryptoMarketRepository.java
================
public interface CryptoMarketRepository extends ListCrudRepository<CryptoMarket,String> {

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModel.java
================
public class AccountQueryModel implements QueryModel<AccountQueryModelState> {
⋮----
public String getName() {
⋮----
public Class<AccountQueryModelState> getStateClass() {
⋮----
public String getIndexName() {
⋮----
public AccountQueryModelState create(AccountCreatedEvent event, AccountQueryModelState isNull) {
return new AccountQueryModelState(
event.userId(),
event.country(),
event.firstName(),
event.lastName(),
event.email());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModelState.java
================
@NotNull @PIIData String email) implements QueryModelState {
⋮----
public String getIndexKey() {
return accountId();

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/CryptoMarketModel.java
================
public class CryptoMarketModel extends JdbcDatabaseModel {
⋮----
public void handle(CryptoMarketCreatedEvent event) {
cryptoMarketRepository.save(CryptoMarket.createNew(
event.id(),
event.baseCrypto(),
event.quoteCrypto(),
event.baseIncrement(),
event.quoteIncrement(),
event.defaultCounterPartyId()

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModel.java
================
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
⋮----
public String getName() {
⋮----
public Class<WalletQueryModelState> getStateClass() {
⋮----
public String getIndexName() {
⋮----
public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
return new WalletQueryModelState(event.id(), List.of());
⋮----
public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState currentState) {
WalletQueryModelState.Balance balance = new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO);
List<WalletQueryModelState.Balance> balances = new ArrayList<>(currentState.balances());
balances.add(balance);
return new WalletQueryModelState(currentState.walletId(), balances);
⋮----
public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState currentState) {
return new WalletQueryModelState(
currentState.walletId(),
currentState.balances().stream().map(balance -> {
if (balance.currency().equals(event.currency())) {
⋮----
balance.currency(),
balance.amount().add(event.amount()),
balance.reservedAmount()
⋮----
}).toList());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModelState.java
================
public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
⋮----
public String getIndexKey() {
return walletId();
⋮----
public BigDecimal getAvailableAmount() {
return amount.subtract(reservedAmount);

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/services/CryptoMarketsService.java
================
public class CryptoMarketsService {
⋮----
public void init() {
coinbaseService.getProducts().stream()
.filter(product -> !cryptoMarketRepository.existsById(product.id()))
.forEach(product -> akcesClient.sendAndForget(new CreateCryptoMarketCommand(
product.id(),
product.baseCurrency(),
product.quoteCurrency(),
product.baseIncrement(),
product.quoteIncrement(),
⋮----
public List<CryptoMarket> getAllMarkets() {
return cryptoMarketRepository.findAll();
⋮----
public Optional<CryptoMarket> getMarketById(String id) {
return cryptoMarketRepository.findById(id);

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/AccountQueryController.java
================
public class AccountQueryController {
⋮----
Mono<ResponseEntity<AccountOutput>> getAccount(@PathVariable("accountId") String accountId) {
return Mono.fromCompletionStage(queryModels.getHydratedState(AccountQueryModel.class, accountId))
.map(state -> ResponseEntity.ok(new AccountOutput(state.accountId(),
state.country(),
state.firstName(),
state.lastName(),
state.email()))).onErrorResume(throwable -> {
⋮----
return Mono.just(ResponseEntity.notFound().build());
⋮----
return Mono.just(ResponseEntity.internalServerError().build());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/CryptoMarketsQueryController.java
================
public class CryptoMarketsQueryController {
⋮----
public Flux<CryptoMarket> getAllMarkets() {
return Flux.fromIterable(cryptoMarketsService.getAllMarkets());
⋮----
public Mono<ResponseEntity<CryptoMarket>> getMarketById(@PathVariable String marketId) {
return Mono.justOrEmpty(cryptoMarketsService.getMarketById(marketId))
.map(ResponseEntity::ok)
.defaultIfEmpty(ResponseEntity.notFound().build());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/WalletQueryController.java
================
public class WalletQueryController {
⋮----
Mono<ResponseEntity<WalletQueryModelState>> getWallet(@PathVariable("walletId") String walletId) {
return Mono.fromCompletionStage(queryModels.getHydratedState(WalletQueryModel.class, walletId))
.map(ResponseEntity::ok)
.onErrorResume(throwable -> {
⋮----
return Mono.just(ResponseEntity.notFound().build());
⋮----
return Mono.just(ResponseEntity.internalServerError().build());

================
File: test-apps/crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
public class ClientConfig {
⋮----
public WebClient coinbaseWebClient() {
return WebClient.builder()
.baseUrl("https://api.exchange.coinbase.com")
.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
.codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
.build();

================
File: test-apps/crypto-trading/queries/src/main/resources/db/changelog/db.changelog-master.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

    <changeSet id="create-partition-offsets-table" author="jwijgerd">
        <createTable tableName="partition_offsets">
            <column name="partition_id" type="varchar(255)">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="record_offset" type="bigint">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <rollback>
            <dropTable tableName="partition_offsets"/>
        </rollback>
    </changeSet>

    <changeSet id="1" author="jwijgerd">
        <createTable tableName="crypto_markets">
            <column name="id" type="varchar(255)">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="base_crypto" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="quote_crypto" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="base_increment" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="quote_increment" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
            <column name="default_counter_party_id" type="varchar(255)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

</databaseChangeLog>

================
File: test-apps/crypto-trading/queries/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: test-apps/crypto-trading/queries/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
spring.datasource.url=jdbc:postgresql://akces-postgresql:5432/akces
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true
akces.cryptotrading.counterPartyId=Coinbase
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration
spring.liquibase.change-log=classpath:/db/changelog/db.changelog-master.xml

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingE2ETests.java
================
public class CryptoTradingE2ETests {
private final WebTestClient e2eTestClient = WebTestClient.bindToServer()
.baseUrl(System.getenv("AKCES_CRYPTO_TRADING_BASE_URL"))
.build();
⋮----
public void testCreateAndReadAccount() {
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
String userId = e2eTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
.exchange()
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
}).returnResult().getResponseBody().userId();
⋮----
System.out.println("Created account with userId: " + userId);
⋮----
e2eTestClient.get()
.uri("/v1/accounts/" + userId)
⋮----
.value(retrievedAccount -> {
assertThat(retrievedAccount).isNotNull();
assertThat(retrievedAccount.userId()).isEqualTo(userId);
assertThat(retrievedAccount.country()).isEqualTo("NL");
assertThat(retrievedAccount.firstName()).isEqualTo("John");
assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
⋮----
public void testBuyCrypto() {
AccountInput accountInput = new AccountInput("NL", "Some", "CryptoTrader", "some.cryptotrader@example.com");
⋮----
e2eTestClient.post()
.uri("/v1/wallets/{userId}/balances", userId)
.bodyValue(new CreateBalanceInput("ETH"))
⋮----
.expectBody(BalanceOutput.class)
.value(balanceOutput -> {
assertThat(balanceOutput).isNotNull();
assertThat(balanceOutput.currency()).isEqualTo("ETH");
assertThat(balanceOutput.amount()).isEqualTo(BigDecimal.ZERO);
⋮----
.uri("/v1/wallets/{userId}/balances/EUR/credit", userId)
.bodyValue(new CreditWalletInput(new BigDecimal("1000.00")))
⋮----
assertThat(balanceOutput.currency()).isEqualTo("EUR");
assertThat(balanceOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
assertThat(balanceOutput.balance()).isEqualTo(new BigDecimal("1000.00"));
⋮----
.uri("/v1/accounts/{userId}/orders/buy", userId)
.bodyValue(new BuyOrderInput("ETH-EUR", new BigDecimal("1000.00"), "buy-eth-eur"))
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
assertThat(orderOutput.market()).isNotNull();
assertThat(orderOutput.market().id()).isEqualTo("ETH-EUR");
assertThat(orderOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
assertThat(orderOutput.clientReference()).isEqualTo("buy-eth-eur");
⋮----
Thread.sleep(10000);
⋮----
.uri("/v1/wallets/{userId}", userId)
⋮----
.expectBody(WalletQueryModelState.class)
.value(wallet -> {
assertThat(wallet).isNotNull();
assertThat(wallet.balances()).hasSize(2);
⋮----
var eurBalance = wallet.balances().stream()
.filter(b -> "EUR".equals(b.currency()))
.findFirst().orElseThrow();
assertThat(eurBalance.amount()).isEqualTo(new BigDecimal("0.00"));
⋮----
var ethBalance = wallet.balances().stream()
.filter(b -> "ETH".equals(b.currency()))
⋮----
assertThat(ethBalance.amount()).isNotEqualTo(BigDecimal.ZERO);
⋮----
public void testBtcEurMarket() {
⋮----
.uri("/v1/markets/BTC-EUR")
⋮----
.expectBody()
.jsonPath("$.id").isEqualTo("BTC-EUR")
.jsonPath("$.baseCrypto").isEqualTo("BTC")
.jsonPath("$.quoteCrypto").isEqualTo("EUR")
.jsonPath("$.baseIncrement").exists()
.jsonPath("$.quoteIncrement").exists()
.jsonPath("$.defaultCounterPartyId").exists();

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingQueryApiTest.java
================
public class CryptoTradingQueryApiTest {
⋮----
private static final Network network = Network.newNetwork();
⋮----
new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
.withKraft()
.withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
.withNetwork(network)
.withNetworkAliases("kafka");
⋮----
new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
⋮----
.withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
.withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
.withExposedPorts(8081)
.withNetworkAliases("schema-registry")
.dependsOn(kafka);
⋮----
.withDatabaseName("cryptotrading")
.withUsername("akces")
.withPassword("akces")
⋮----
.withNetworkAliases("postgresql");
⋮----
public static void cleanUp() throws IOException {
if (Files.exists(Paths.get("/tmp/akces"))) {
⋮----
Files.walk(Paths.get("/tmp/akces"))
.sorted(Comparator.reverseOrder())
.map(Path::toFile)
.forEach(File::delete);
⋮----
void contextLoads() {
assertThat(walletController).isNotNull();
assertThat(accountController).isNotNull();
assertThat(prderProcessManagerController).isNotNull();
assertThat(akcesClientController).isNotNull();
assertThat(cryptoMarketController).isNotNull();
⋮----
assertThat(accountWebController).isNotNull();
assertThat(walletWebController).isNotNull();
assertThat(accountQueryController).isNotNull();
assertThat(cryptoMarketsQueryController).isNotNull();
⋮----
while (!walletController.isRunning() ||
!accountController.isRunning() ||
!prderProcessManagerController.isRunning() ||
!cryptoMarketController.isRunning() ||
!akcesClientController.isRunning()) {
Thread.onSpinWait();
⋮----
void healthReadinessEndpointShouldBeEnabled() {
webTestClient.get()
.uri("/actuator/health/readiness")
.exchange()
.expectStatus().isOk()
.expectBody(String.class)
.value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
⋮----
void healthLivenessEndpointShouldBeEnabled() {
⋮----
.uri("/actuator/health/liveness")
⋮----
void testCreateAccount() {
⋮----
AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
webTestClient.post()
.uri("/v1/accounts")
.bodyValue(accountInput)
⋮----
.expectStatus().is2xxSuccessful()
.expectBody(AccountOutput.class)
.value(accountOutput -> {
assertThat(accountOutput).isNotNull();
assertThat(accountOutput.userId()).isNotNull();
assertThat(accountOutput.country()).isEqualTo("NL");
assertThat(accountOutput.firstName()).isEqualTo("John");
assertThat(accountOutput.lastName()).isEqualTo("Doe");
assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
⋮----
void testCreateAccountAndCreditWallet() {
⋮----
CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
.bodyValue(creditInput)
⋮----
.expectBody(BalanceOutput.class)
.value(creditOutput -> {
assertThat(creditOutput).isNotNull();
assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
assertThat(creditOutput.currency()).isEqualTo("EUR");
⋮----
void testCreateAccountAndCreditWalletWithoutBalance() {
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
⋮----
.expectStatus().is4xxClientError()
.expectBody(ErrorEventResponse.class)
.value(response -> {
assertThat(response).isNotNull();
assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
⋮----
void testCreateAccountAndAddBtcBalance() {
⋮----
CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
⋮----
.uri("/v1/wallets/" + accountOutput.userId() + "/balances")
.bodyValue(createBalanceInput)
⋮----
.expectStatus().is2xxSuccessful();
⋮----
void testGetAccount() {
⋮----
AccountInput accountInput = new AccountInput("US", "John", "Doe", "john.doe@example.com");
⋮----
.uri("/v1/accounts/" + accountOutput.userId())
⋮----
.value(retrievedAccount -> {
assertThat(retrievedAccount).isNotNull();
assertThat(retrievedAccount.userId()).isEqualTo(accountOutput.userId());
assertThat(retrievedAccount.country()).isEqualTo("US");
assertThat(retrievedAccount.firstName()).isEqualTo("John");
assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
⋮----
void testInvalidApiVersion() {
⋮----
.uri("/v13/accounts/invalid-id")
⋮----
.expectStatus().isNotFound();
⋮----
void testCryptoMarkets() {
⋮----
while(cryptoMarketRepository.count() == 0) {
⋮----
assertNotNull(cryptoMarketRepository.findById("BTC-EUR").orElse(null));
⋮----
void testCryptoMarket() {
⋮----
.uri("/v1/markets/BTC-EUR")
⋮----
.expectBody()
.jsonPath("$.id").isEqualTo("BTC-EUR")
.jsonPath("$.baseCrypto").isEqualTo("BTC")
.jsonPath("$.quoteCrypto").isEqualTo("EUR");
⋮----
void testPlaceBuyOrder() {
⋮----
AccountOutput accountOutput = webTestClient.post()
⋮----
.returnResult()
.getResponseBody();
⋮----
String userId = accountOutput.userId();
⋮----
.uri("/v1/wallets/" + userId + "/balances/EUR/credit")
.bodyValue(new CreditWalletInput(new BigDecimal("10000.0")))
⋮----
.uri("/v1/wallets/" + userId + "/balances")
.bodyValue(new CreateBalanceInput("BTC"))
⋮----
BuyOrderInput buyOrderInput = new BuyOrderInput("BTC-EUR", new BigDecimal("1000"), "client-ref-1");
⋮----
.uri("/v1/accounts/" + userId + "/orders/buy")
.bodyValue(buyOrderInput)
⋮----
.expectBody(OrderOutput.class)
.value(orderOutput -> {
assertThat(orderOutput).isNotNull();
assertThat(orderOutput.orderId()).isNotNull();
⋮----
public static class Initializer
⋮----
public void initialize(ConfigurableApplicationContext applicationContext) {
⋮----
prepareKafka(kafka.getBootstrapServers());
prepareDomainEventSchemas(
"http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
List.of(
⋮----
prepareCommandSchemas("http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
⋮----
prepareAggregateServiceRecords(kafka.getBootstrapServers());
⋮----
throw new RuntimeException(e);
⋮----
TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
⋮----
"spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
"akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
"spring.datasource.url=" + postgresql.getJdbcUrl(),

================
File: test-apps/crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
public class TestUtils {
public static void prepareKafka(String bootstrapServers) {
KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
kafkaAdmin.createOrModifyTopics(
createCompactedTopic("Akces-Control", 3),
createTopic("Akces-CommandResponses", 3, 604800000L),
createCompactedTopic("Akces-GDPRKeys", 3),
createTopic("Wallet-Commands", 3),
createTopic("Wallet-DomainEvents", 3),
createTopic("Account-Commands", 3),
createTopic("Account-DomainEvents", 3),
createTopic("OrderProcessManager-Commands", 3),
createTopic("OrderProcessManager-DomainEvents", 3),
createTopic("CryptoMarket-Commands", 3),
createTopic("CryptoMarket-DomainEvents", 3),
createCompactedTopic("Wallet-AggregateState", 3),
createCompactedTopic("Account-AggregateState", 3),
createCompactedTopic("OrderProcessManager-AggregateState", 3),
createCompactedTopic("CryptoMarket-AggregateState", 3));
⋮----
private static NewTopic createTopic(String name, int numPartitions) {
return createTopic(name, numPartitions, -1L);
⋮----
private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
return topic.configs(Map.of(
⋮----
"retention.ms", Long.toString(retentionMs),
⋮----
private static NewTopic createCompactedTopic(String name, int numPartitions) {
⋮----
public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
builder.modulesToInstall(new AkcesGDPRModule());
builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
ObjectMapper objectMapper = builder.build();
AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
Map<String, Object> controlProducerProps = Map.of(
⋮----
try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
controlProducer.initTransactions();
AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"FillBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.FillBuyOrder\"},{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"BuyOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderFilled\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderFilled\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);controlProducer.beginTransaction();
⋮----
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
⋮----
controlProducer.commitTransaction();
⋮----
public static void prepareDomainEventSchemas(String url, List<Class<? extends DomainEvent>> domainEventClasses) {
SchemaRegistryClient src = new CachedSchemaRegistryClient(url, 100);
Jackson2ObjectMapperBuilder objectMapperBuilder = new Jackson2ObjectMapperBuilder();
objectMapperBuilder.modulesToInstall(new AkcesGDPRModule());
objectMapperBuilder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
SchemaGeneratorConfigBuilder configBuilder = new SchemaGeneratorConfigBuilder(objectMapperBuilder.build(),
⋮----
configBuilder.with(new JakartaValidationModule(JakartaValidationOption.INCLUDE_PATTERN_EXPRESSIONS,
⋮----
configBuilder.with(new JacksonModule());
configBuilder.with(Option.FORBIDDEN_ADDITIONAL_PROPERTIES_BY_DEFAULT);
configBuilder.with(Option.NULLABLE_FIELDS_BY_DEFAULT);
configBuilder.with(Option.NULLABLE_METHOD_RETURN_VALUES_BY_DEFAULT);
⋮----
configBuilder.forTypesInGeneral().withTypeAttributeOverride((collectedTypeAttributes, scope, context) -> {
if (scope.getType().getTypeName().equals("java.math.BigDecimal")) {
JsonNode typeNode = collectedTypeAttributes.get("type");
if (typeNode.isArray()) {
((ArrayNode) collectedTypeAttributes.get("type")).set(0, "string");
⋮----
collectedTypeAttributes.put("type", "string");
⋮----
SchemaGeneratorConfig config = configBuilder.build();
SchemaGenerator jsonSchemaGenerator = new SchemaGenerator(config);
⋮----
DomainEventInfo info = domainEventClass.getAnnotation(DomainEventInfo.class);
src.register("domainevents." + info.type(),
new JsonSchema(jsonSchemaGenerator.generateSchema(domainEventClass), List.of(), Map.of(), info.version()),
info.version(),
⋮----
throw new ApplicationContextException("Problem populating SchemaRegistry", e);
⋮----
public static <C extends Command> void prepareCommandSchemas(String url, List<Class<C>> commandClasses) {
⋮----
CommandInfo info = commandClass.getAnnotation(CommandInfo.class);
src.register("commands." + info.type(),
new JsonSchema(jsonSchemaGenerator.generateSchema(commandClass), List.of(), Map.of(), info.version()),

================
File: test-apps/crypto-trading/queries/src/test/resources/application-test.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates
spring.main.allow-bean-definition-overriding=true

================
File: test-apps/crypto-trading/queries/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: test-apps/crypto-trading/queries/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.8.13-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-queries</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Query Services</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-query-support</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>services</classifier>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <classifier>shared-web</classifier>
            <version>${project.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.elasticsoftwarefoundation.akces</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jdbc</artifactId>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>

        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: test-apps/crypto-trading/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-test-apps</artifactId>
        <version>0.8.13-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-parent</artifactId>
    <packaging>pom</packaging>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <modules>
        <module>aggregates</module>
        <module>commands</module>
        <module>queries</module>
    </modules>

    <build>
        <plugins>

        </plugins>
    </build>

</project>

================
File: test-apps/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-parent</artifactId>
        <version>0.8.13-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>akces-framework-test-apps</artifactId>
    <packaging>pom</packaging>

    <name>Elastic Software Foundation :: Akces :: Test Apps</name>
    <url>https://github.com/elasticsoftwarefoundation/akces-framework</url>

    <properties>
        <akces-framework.version>${project.version}</akces-framework.version>
    </properties>

    <repositories>
        <repository>
            <id>github</id>
            <name>Akces Github Packages Repository</name>
            <url>https://github.com/elasticsoftwarefoundation/akces-framework/packages</url>
        </repository>
        <repository>
            <id>central</id>
            <name>Maven Central</name>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
    </repositories>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-api</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-shared</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-runtime</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-client</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-query-support</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.checkerframework</groupId>
                <artifactId>checker-qual</artifactId>
                <version>3.48.3</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-text</artifactId>
                <version>1.12.0</version>
            </dependency>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava-bom</artifactId>
                <version>${guava.version}</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>com.github.ben-manes.caffeine</groupId>
                <artifactId>caffeine</artifactId>
                <version>${caffeine.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>com.google.errorprone</groupId>
                        <artifactId>error_prone_annotations</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <modules>
        <module>crypto-trading</module>
    </modules>
    <build>
        <plugins>
            <plugin>

                <artifactId>maven-deploy-plugin</artifactId>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <profile>
            <id>maven-release</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <configuration>
                            <docker>
                                <publishRegistry>
                                    <username>${env.GITHUB_ACTOR}</username>
                                    <password>${env.GITHUB_TOKEN}</password>
                                    <url>docker://ghcr.io</url>
                                </publishRegistry>
                            </docker>
                            <image>
                                <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}</name>
                                <publish>true</publish>
                                <env>
                                    <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                    <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    <BP_SPRING_AOT_ENABLED>true</BP_SPRING_AOT_ENABLED>
                                    <BP_JVM_CDS_ENABLED>false</BP_JVM_CDS_ENABLED>
                                    <JAVA_TOOL_OPTIONS>-XX:+UseZGC -XX:+ZGenerational</JAVA_TOOL_OPTIONS>
                                </env>
                                <buildpacks>
                                    <buildpack>gcr.io/paketo-buildpacks/ca-certificates</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/adoptium:latest</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/syft</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/executable-jar</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/spring-boot</buildpack>
                                </buildpacks>
                            </image>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>process-aot</goal>
                                </goals>
                                <configuration>

                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>native</id>
            <build>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-jar-plugin</artifactId>
                            <configuration>
                                <archive>
                                    <manifestEntries>
                                        <Spring-Boot-Native-Processed>true</Spring-Boot-Native-Processed>
                                    </manifestEntries>
                                </archive>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                            <executions>
                                <execution>
                                    <id>process-aot</id>
                                    <goals>
                                        <goal>process-aot</goal>
                                    </goals>
                                </execution>
                            </executions>
                            <configuration>
                                <docker>
                                    <publishRegistry>
                                        <username>${env.GITHUB_ACTOR}</username>
                                        <password>${env.GITHUB_TOKEN}</password>
                                        <url>docker://ghcr.io</url>
                                    </publishRegistry>
                                </docker>
                                <image>
                                    <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                    <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                    <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}
                                    </name>
                                    <publish>true</publish>
                                    <env>
                                        <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                        <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    </env>
                                </image>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.graalvm.buildtools</groupId>
                            <artifactId>native-maven-plugin</artifactId>
                            <configuration>
                                <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                                <requiredVersion>22.3</requiredVersion>
                            </configuration>
                            <executions>
                                <execution>
                                    <id>add-reachability-metadata</id>
                                    <goals>
                                        <goal>add-reachability-metadata</goal>
                                    </goals>
                                </execution>
                                <execution>
                                    <id>build-native</id>
                                    <goals>
                                        <goal>compile-no-fork</goal>
                                    </goals>
                                    <phase>package</phase>
                                </execution>
                            </executions>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
        <profile>
            <id>nativeTest</id>
            <dependencies>
                <dependency>
                    <groupId>org.junit.platform</groupId>
                    <artifactId>junit-platform-launcher</artifactId>
                    <scope>test</scope>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>process-test-aot</id>
                                <goals>
                                    <goal>process-test-aot</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <configuration>
                            <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                            <requiredVersion>22.3</requiredVersion>
                        </configuration>
                        <executions>
                            <execution>
                                <id>native-test</id>
                                <goals>
                                    <goal>test</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>

================
File: FRAMEWORK_OVERVIEW.md
================
# Comprehensive Review of Akces Framework

After carefully analyzing the codebase, I can provide an updated comprehensive overview of the Akces Framework, building upon and refining the existing FRAMEWORK_OVERVIEW.md.

## Main Purpose

Akces is a sophisticated event-sourcing and CQRS (Command Query Responsibility Segregation) framework built on Apache Kafka. Its primary purpose is to provide developers with a structured approach to building distributed, event-driven applications with a clear separation between write and read concerns. The framework handles the complex infrastructure required for event-sourcing while allowing developers to focus on domain logic.

Key goals of the framework include:
- Simplifying the implementation of event-sourced applications
- Providing a scalable architecture for distributed processing
- Enforcing clean separation between command and query responsibilities
- Supporting privacy-by-design through GDPR-compliant data handling
- Enabling schema evolution with backward compatibility checks

## Core Architectural Components

Akces is organized around several key architectural components that work together:

### 1. Aggregate Module

The aggregate module is responsible for handling commands and maintaining state through event sourcing. Key components include:

- **Aggregates**: Domain entities that encapsulate business logic and respond to commands
- **Aggregate States**: Immutable representations of aggregate state
- **Command Handlers**: Process commands and emit domain events
- **Event Sourcing Handlers**: Apply events to update aggregate state
- **Event Handlers**: React to events to produce further events
- **Event Bridge Handlers**: Connect events from one aggregate to commands on another

The runtime leverages Kafka partitioning for horizontal scaling, with each partition handling a subset of aggregates based on their IDs.

### 2. Command Processing

The command processing pipeline includes:

- **Command Bus**: Routes commands to appropriate aggregates
- **Command Validation**: Schema-based validation using JSON Schema
- **Command Execution**: Transactional processing that produces events
- **Command Response Handling**: Collects and returns resulting events

### 3. Query Model System

For the read side, Akces provides:

- **Query Models**: Domain-specific projections optimized for reading
- **Query Model States**: Immutable state representations 
- **Query Model Event Handlers**: Update query models based on domain events
- **Database Models**: Persistent storage models updated from events
- **JDBC/JPA Integration**: Support for different database technologies

### 4. Process Managers

To orchestrate complex workflows:

- **Process Managers**: Coordinate interactions between multiple aggregates
- **Process States**: Track the status of long-running processes
- **AkcesProcess**: Domain-specific process representation

### 5. GDPR Compliance Layer

For handling sensitive data:

- **PIIData Annotation**: Mark fields containing personal data
- **GDPR Context**: Encryption/decryption context for an aggregate
- **Transparent Serialization**: Automatic encryption/decryption during serialization
- **Key Management**: Secure handling of encryption keys

## Technical Implementation Details

### Event Sourcing Implementation

The event sourcing mechanism in Akces follows these principles:

1. **Immutable Events**: All domain events are immutable records of facts
2. **Event Storage**: Events are stored in Kafka topics, partitioned by aggregate ID
3. **State Reconstruction**: Aggregate state is derived by replaying events
4. **State Snapshots**: RocksDB is used to maintain efficient state snapshots

The `KafkaAggregateRuntime` class manages the event sourcing logic, handling:
- Command processing and validation
- Event application to state
- State persistence
- Event publishing

### Partitioning and Scalability

Akces achieves scalability through:

1. **Partition-based Processing**: Each instance processes specific partitions
2. **Consistent Hashing**: Aggregate IDs are consistently hashed to partitions
3. **Parallel Processing**: Multiple partitions can be processed concurrently
4. **Atomic Transactions**: Kafka transactions ensure atomicity of operations

The `AggregatePartition` class handles partition-specific processing, managing:
- Command handling for a partition
- Event processing for a partition
- State management for a partition

### Schema Evolution

Akces provides sophisticated schema evolution through:

1. **Schema Registry Integration**: Works with Confluent Schema Registry
2. **Schema Versioning**: Clear versioning of all commands and events
3. **Compatibility Checking**: Ensures backward compatibility
4. **JSON Schema Generation**: Automatic schema generation from classes

The `KafkaSchemaRegistry` class handles schema management, providing:
- Schema registration and validation
- Compatibility checking
- Schema versioning support

### GDPR Compliance Implementation

The GDPR compliance layer uses:

1. **AES Encryption**: For sensitive data fields
2. **Jackson Serialization Integration**: Custom serializers/deserializers
3. **Key Management**: Secure storage of encryption keys in Kafka
4. **Annotation-based Marking**: Easy identification of sensitive fields

### Query Model Implementation

The query model system provides:

1. **Event-driven Updates**: Query models updated via events
2. **State Hydration**: Efficient state loading and caching
3. **Database Integration**: Support for JDBC and JPA databases
4. **Partition-aware Processing**: Scalable across nodes

## Module Structure

Akces is organized into several Maven modules:

1. **api**: Core interfaces and annotations defining the programming model
   - Aggregate, Command, and Event interfaces
   - Handler annotations for commands and events
   - Query model and database model interfaces

2. **runtime**: Implements the core event sourcing runtime
   - Aggregate runtime for command/event handling
   - State repositories (RocksDB/in-memory)
   - Kafka integration
   - Command handling pipeline

3. **shared**: Common utilities and shared functionality
   - Protocol records for communication
   - GDPR compliance utilities
   - Serialization/deserialization support
   - Schema registry integration

4. **client**: Client-side library for interacting with aggregates
   - Command sending
   - Response handling
   - Discovery of available aggregates

5. **query-support**: Support for query models and database models
   - Query model runtime 
   - Database model support
   - Event handling for models
   - State hydration

## Programming Model

Akces provides a clean, annotation-based programming model:

### Defining Aggregates

```java
@AggregateInfo(value = "Wallet", version = 1)
public class Wallet implements Aggregate<WalletState> {
    @CommandHandler(create = true)
    public Stream<DomainEvent> create(CreateWalletCommand cmd, WalletState isNull) {
        // Command handling logic
    }
    
    @EventSourcingHandler(create = true)
    public WalletState create(WalletCreatedEvent event, WalletState isNull) {
        // Event application logic
    }
}
```

### Defining Commands and Events

```java
@CommandInfo(type = "CreateWallet", version = 1)
public record CreateWalletCommand(@AggregateIdentifier String id, String currency) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@DomainEventInfo(type = "WalletCreated", version = 1)
public record WalletCreatedEvent(@AggregateIdentifier String id) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Defining Query Models

```java
@QueryModelInfo(value = "WalletQuery", version = 1, indexName = "Wallets")
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    @QueryModelEventHandler(create = true)
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        // Create logic
    }
}
```

### GDPR Annotation

```java
public record UserInfo(
    @AggregateIdentifier String userId,
    @PIIData String firstName,
    @PIIData String lastName,
    @PIIData String email
) implements AggregateState {
    // ...
}
```

## Runtime Components

The key runtime components include:

1. **AkcesAggregateController**: Manages aggregate partitions and lifecycle
2. **AkcesClientController**: Handles command sending and response processing
3. **AkcesQueryModelController**: Manages query model state hydration
4. **AkcesDatabaseModelController**: Handles database model updates
5. **AggregatePartition**: Processes commands and events for a partition

## Enhanced Features Not Fully Captured in Original Overview

### 1. Robust Partition Management

The framework provides sophisticated partition management with:
- Automatic rebalancing when nodes join/leave
- Coordinated partition shutdown and cleanup
- Atomic transaction processing within partitions
- Optimized state loading from RocksDB

### 2. Advanced Schema Handling

Schema management is more sophisticated than initially described:
- Diff-based compatibility checking 
- Schema evolution with strict version checking
- Automatic schema registration with configurable validation
- Support for external schemas with relaxed validation

### 3. Transaction Support

The transactional model provides:
- Exactly-once processing semantics
- Atomic command handling with consistent state updates
- Transaction isolation for command processing
- Consistent offset management

### 4. Optimized State Handling

State management is highly optimized:
- Efficient RocksDB storage with custom serialization
- In-memory caching for high-performance scenarios
- Partition-aware state access patterns
- Transactional state updates coordinated with events

### 5. Flexible Deployment Models

The framework supports different deployment topologies:
- Separate command and query services
- Combined services for smaller applications
- Scalable partitioning across multiple nodes
- Stream processing integration

### 6. Process Manager Capabilities

Process managers provide orchestration capabilities:
- Coordination of multi-step processes
- State tracking for long-running operations
- Event-driven process advancement
- Error handling and compensation

## Conclusion

Akces Framework provides a comprehensive solution for building event-sourced, CQRS-based applications with a focus on scalability, resilience, and privacy. Its clean programming model, combined with a robust runtime implementation, makes it well-suited for complex domain problems requiring sophisticated state management and high scalability.

The framework's integration with Kafka provides a reliable foundation for distributed processing, while its schema management and GDPR compliance features address important enterprise concerns. The separation between command handling and query models follows best practices for complex domain modeling while maintaining high performance for read operations.

================
File: README.md
================
# Akces Framework

## Overview

Akces Framework is a robust CQRS (Command Query Responsibility Segregation) and Event Sourcing framework built on Apache Kafka. The framework provides a comprehensive infrastructure for building distributed, event-driven applications with a clean separation between command and query operations.

At its core, Akces implements the full event sourcing pattern, capturing all changes to application state as a sequence of events. These events can be replayed to reconstruct the state at any point in time, providing a complete audit trail and enabling powerful temporal queries.

The framework leverages Kafka's distributed architecture for reliable event storage and processing, making it highly scalable and resilient. It also provides built-in support for personal data protection (GDPR compliance), schema evolution, and efficient state management.

## Core Concepts

- **Aggregates**: Domain entities that encapsulate business logic and maintain state through events
- **Commands**: Requests to change the state of an aggregate
- **Domain Events**: Facts that have occurred, representing state changes
- **Command Handlers**: Process commands and produce events
- **Event Sourcing Handlers**: Apply events to update aggregate state
- **Query Models**: Read-optimized projections of aggregate state
- **Database Models**: Persistent storage of aggregate data

## Main Features

### Command Handling
- **Command Bus**: A distributed command bus for routing commands to appropriate aggregates
- **Command Validation**: Automatic schema validation using JSON Schema
- **Command Handlers**: Annotation-based command handling with automatic event publishing
- **Transaction Support**: Transactional processing of commands

### Event Sourcing
- **Event Store**: Kafka-based event store for persisting all domain events
- **Event Handlers**: Annotation-based event handling for processing domain events
- **Event Sourcing Handlers**: Automatic state reconstruction from domain events
- **Event Bridging**: Bridge events between different aggregates

### Aggregate Management
- **Aggregate Runtimes**: Lifecycle management for aggregates
- **State Management**: Efficient state storage using RocksDB
- **Partitioning**: Automatic partitioning of aggregates across nodes for scalability
- **Event Indexing**: Automatic indexing of events for efficient querying

### Query Support
- **Query Models**: Build specialized read models from domain events
- **Database Models**: Automatically sync data to databases for efficient querying
- **Materialized Views**: Build and maintain materialized views of aggregate state
- **State Hydration**: Efficiently load and cache query model state

### Privacy & GDPR Support
- **PII Data Handling**: Built-in support for Personal Identifiable Information (PII)
- **Data Encryption**: Transparent encryption/decryption of sensitive data
- **Annotation-based PII Marking**: Easy identification of sensitive fields
- **Key Management**: Secure management of encryption keys

### Schema Management
- **Schema Evolution**: Support for evolving schemas with backward compatibility
- **Schema Registry Integration**: Works with Confluent Schema Registry for schema management
- **Schema Validation**: Automatic validation of commands and events against their schemas
- **Schema Compatibility Checks**: Ensure backward compatibility of schema changes

## Architecture

The framework consists of several modules:

- **api**: Core interfaces and annotations defining the framework's programming model
- **shared**: Common utilities, serialization, and GDPR support
- **runtime**: The runtime environment for aggregates, including command handling and event sourcing
- **client**: Client library for interacting with aggregate services
- **query-support**: Support for query models and database models

## Setup Instructions

### Prerequisites

- Java 17 or higher
- Apache Kafka 3.x
- Confluent Schema Registry
- Maven 3.6+

### Maven Dependencies

Add the following to your `pom.xml`:

```xml
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-api</artifactId>
    <version>0.8.1</version>
</dependency>

<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-client</artifactId>
    <version>0.8.1</version>
</dependency>

<!-- For running aggregates -->
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-runtime</artifactId>
    <version>0.8.1</version>
</dependency>

<!-- For query models -->
<dependency>
    <groupId>org.elasticsoftwarefoundation.akces</groupId>
    <artifactId>akces-query-support</artifactId>
    <version>0.8.1</version>
</dependency>
```

### Configuration

Create an `application.yaml` file with the following configuration:

```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      enable-auto-commit: false
      isolation-level: read_committed
      max-poll-records: 500
      heartbeat-interval: 2000
      auto-offset-reset: latest
      properties:
        max.poll.interval.ms: 10000
        session.timeout.ms: 30000
        partition.assignment.strategy: org.apache.kafka.clients.consumer.CooperativeStickyAssignor
    producer:
      acks: all
      retries: 2147483647
      properties:
        enable.idempotence: true
        max.in.flight.requests.per.connection: 1

akces:
  schemaregistry:
    url: http://localhost:8081
  rocksdb:
    baseDir: /tmp/akces
```

## Usage Examples

### Define an Aggregate

```java
@AggregateInfo(value = "Wallet", version = 1, generateGDPRKeyOnCreate = true, indexed = true, indexName = "Wallets")
public final class Wallet implements Aggregate<WalletState> {
    @Override
    public Class<WalletState> getStateClass() {
        return WalletState.class;
    }

    @CommandHandler(create = true, produces = {WalletCreatedEvent.class, BalanceCreatedEvent.class})
    public Stream<DomainEvent> create(CreateWalletCommand cmd, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(cmd.id()), new BalanceCreatedEvent(cmd.id(), cmd.currency()));
    }

    @EventSourcingHandler(create = true)
    public WalletState create(WalletCreatedEvent event, WalletState isNull) {
        return new WalletState(event.id(), new ArrayList<>());
    }
    
    @EventSourcingHandler
    public WalletState createBalance(BalanceCreatedEvent event, WalletState state) {
        List<WalletState.Balance> balances = new ArrayList<>(state.balances());
        balances.add(new WalletState.Balance(event.currency(), BigDecimal.ZERO));
        return new WalletState(state.id(), balances);
    }
    
    @CommandHandler(produces = {WalletCreditedEvent.class, InvalidAmountErrorEvent.class, InvalidCurrencyErrorEvent.class})
    public Stream<DomainEvent> credit(CreditWalletCommand cmd, WalletState currentState) {
        WalletState.Balance balance = currentState.balances().stream()
                .filter(b -> b.currency().equals(cmd.currency()))
                .findFirst().orElse(null);
                
        if (balance == null) {
            return Stream.of(new InvalidCurrencyErrorEvent(cmd.id(), cmd.currency()));
        }
        
        if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {
            return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
        }
        
        return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), cmd.amount(), 
                balance.amount().add(cmd.amount())));
    }
}
```

### Define an Aggregate State

```java
public record WalletState(String id, List<Balance> balances) implements AggregateState {
    @Override
    public String getAggregateId() {
        return id();
    }

    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(String currency, BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }

        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}
```

### Create Commands

```java
@CommandInfo(type = "CreateWallet", version = 1)
public record CreateWalletCommand(@AggregateIdentifier @NotNull String id, 
                                  @NotNull String currency) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@CommandInfo(type = "CreditWallet", version = 1)
public record CreditWalletCommand(@AggregateIdentifier @NotNull String id,
                                 @NotNull String currency,
                                 @NotNull BigDecimal amount) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Create Events

```java
@DomainEventInfo(type = "WalletCreated", version = 1)
public record WalletCreatedEvent(@AggregateIdentifier @NotNull String id) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@DomainEventInfo(type = "BalanceCreated", version = 1)
public record BalanceCreatedEvent(@AggregateIdentifier @NotNull String id, 
                                 @NotNull String currency) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

@DomainEventInfo(type = "WalletCredited", version = 1)
public record WalletCreditedEvent(@AggregateIdentifier @NotNull String id,
                                 @NotNull String currency,
                                 @NotNull BigDecimal amount,
                                 @NotNull BigDecimal newBalance) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}
```

### Error Events

```java
@DomainEventInfo(type = "InvalidCurrencyError", version = 1)
public record InvalidCurrencyErrorEvent(@AggregateIdentifier @NotNull String walletId,
                                       @NotNull String currency) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return walletId();
    }
}

@DomainEventInfo(type = "InvalidAmountError", version = 1)
public record InvalidAmountErrorEvent(@AggregateIdentifier @NotNull String walletId,
                                     @NotNull String currency) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return walletId();
    }
}
```

### Sending Commands

```java
@Autowired
private AkcesClient akcesClient;

public void createWallet() {
    String walletId = UUID.randomUUID().toString();
    CreateWalletCommand command = new CreateWalletCommand(walletId, "USD");
    
    // Send command and get events synchronously
    List<DomainEvent> events = akcesClient.send("DEFAULT_TENANT", command)
        .toCompletableFuture()
        .join();
    
    // Or send command asynchronously
    akcesClient.sendAndForget("DEFAULT_TENANT", command);
}

public void creditWallet(String walletId, String currency, BigDecimal amount) {
    CreditWalletCommand command = new CreditWalletCommand(walletId, currency, amount);
    
    try {
        List<DomainEvent> events = akcesClient.send("DEFAULT_TENANT", command)
            .toCompletableFuture()
            .join();
            
        // Check if we received an error event
        if (events.stream().anyMatch(event -> event instanceof ErrorEvent)) {
            ErrorEvent error = (ErrorEvent) events.stream()
                .filter(event -> event instanceof ErrorEvent)
                .findFirst()
                .orElse(null);
            // Handle error
        }
    } catch (Exception e) {
        // Handle exceptions (validation errors, connectivity issues, etc.)
    }
}
```

### Create a Query Model

```java
@QueryModelInfo(value = "WalletQuery", version = 1, indexName = "Wallets")
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    @Override
    public Class<WalletQueryModelState> getStateClass() {
        return WalletQueryModelState.class;
    }
    
    @Override
    public String getIndexName() {
        return "Wallets";
    }

    @QueryModelEventHandler(create = true)
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        return new WalletQueryModelState(event.id(), List.of());
    }
    
    @QueryModelEventHandler
    public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState currentState) {
        WalletQueryModelState.Balance balance = new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO);
        List<WalletQueryModelState.Balance> balances = new ArrayList<>(currentState.balances());
        balances.add(balance);
        return new WalletQueryModelState(currentState.walletId(), balances);
    }
    
    @QueryModelEventHandler
    public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState currentState) {
        return new WalletQueryModelState(
                currentState.walletId(),
                currentState.balances().stream().map(balance -> {
                    if (balance.currency().equals(event.currency())) {
                        return new WalletQueryModelState.Balance(
                                balance.currency(),
                                balance.amount().add(event.amount()),
                                balance.reservedAmount()
                        );
                    }
                    return balance;
                }).toList());
    }
}

public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
    @Override
    public String getIndexKey() {
        return walletId();
    }
    
    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(String currency, BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }
        
        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}
```

### Query a Model

```java
@Autowired
private QueryModels queryModels;

public WalletQueryModelState getWallet(String walletId) {
    return queryModels.getHydratedState(WalletQueryModel.class, walletId)
        .toCompletableFuture()
        .join();
}

public void displayWalletBalances(String walletId) {
    try {
        WalletQueryModelState wallet = queryModels.getHydratedState(WalletQueryModel.class, walletId)
            .toCompletableFuture()
            .get(5, TimeUnit.SECONDS);
            
        wallet.balances().forEach(balance -> {
            System.out.printf("Currency: %s, Amount: %s, Available: %s%n", 
                balance.currency(), 
                balance.amount().toPlainString(), 
                balance.getAvailableAmount().toPlainString());
        });
    } catch (QueryModelIdNotFoundException e) {
        System.out.println("Wallet not found: " + e.getModelId());
    } catch (Exception e) {
        System.out.println("Error retrieving wallet: " + e.getMessage());
    }
}
```

### Create a Database Model

```java
@DatabaseModelInfo(value = "WalletDatabase", version = 1)
public class WalletDatabaseModel extends JdbcDatabaseModel {
    @DatabaseModelEventHandler
    public void handle(WalletCreatedEvent event) {
        jdbcTemplate.update("""
            INSERT INTO wallets (wallet_id, created_date) 
            VALUES (?, NOW())
            """, 
            event.id());
    }
    
    @DatabaseModelEventHandler
    public void handle(BalanceCreatedEvent event) {
        jdbcTemplate.update("""
            INSERT INTO wallet_balances (wallet_id, currency, amount) 
            VALUES (?, ?, ?)
            """, 
            event.id(), event.currency(), 0.00);
    }
    
    @DatabaseModelEventHandler
    public void handle(WalletCreditedEvent event) {
        jdbcTemplate.update("""
            UPDATE wallet_balances
            SET amount = ?
            WHERE wallet_id = ? AND currency = ?
            """,
            event.newBalance(), event.id(), event.currency());
    }
}
```

## GDPR and PII Data

The framework provides built-in support for Personal Identifiable Information (PII):

```java
@AggregateStateInfo(value = "AccountState", version = 1)
public record AccountState(@AggregateIdentifier String userId, 
                          String country, 
                          @PIIData String firstName, 
                          @PIIData String lastName, 
                          @PIIData String email) implements AggregateState {
    @Override
    public String getAggregateId() {
        return userId();
    }
}
```

PII data is automatically encrypted when stored and decrypted when retrieved. The encryption is transparent to the application code.

## Process Managers

Akces also supports process managers for coordinating complex workflows across multiple aggregates:

```java
@AggregateInfo(value = "OrderProcessManager", version = 1)
public class OrderProcessManager implements ProcessManager<OrderProcessManagerState, OrderProcess> {
    @Override
    public Class<OrderProcessManagerState> getStateClass() {
        return OrderProcessManagerState.class;
    }
    
    @EventHandler(create = true)
    public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
        return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
    }
    
    @CommandHandler
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {
        String orderId = UUID.randomUUID().toString();
        // Start a multi-step process
        getCommandBus().send(new ReserveAmountCommand(
                state.userId(),
                command.market().quoteCurrency(),
                command.quantity().multiply(command.limitPrice()),
                orderId));
        
        return Stream.of(new BuyOrderCreatedEvent(
                state.userId(),
                orderId,
                command.market(),
                command.quantity(),
                command.limitPrice(),
                command.clientReference()));
    }
    
    @EventHandler
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {
        OrderProcess orderProcess = state.getAkcesProcess(event.referenceId());
        
        if (orderProcess instanceof BuyOrderProcess) {
            return Stream.of(new BuyOrderPlacedEvent(
                    state.userId(), 
                    orderProcess.orderId(), 
                    orderProcess.market(), 
                    orderProcess.quantity(), 
                    orderProcess.limitPrice()));
        }
        
        return Stream.empty();
    }
    
    @EventHandler
    public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
        return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
    }
}
```

## Running the Framework

### Aggregate Service

```java
@SpringBootApplication
public class AggregateServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AggregateServiceApplication.class, args);
    }
}
```

### Query Service

```java
@SpringBootApplication
public class QueryServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(QueryServiceApplication.class, args);
    }
}
```

### Client Application

```java
@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
    
    @Bean
    public CommandLineRunner commandLineRunner(AkcesClient akcesClient) {
        return args -> {
            // Create a new wallet
            String walletId = UUID.randomUUID().toString();
            CreateWalletCommand createCommand = new CreateWalletCommand(walletId, "USD");
            
            List<DomainEvent> createEvents = akcesClient.send(createCommand)
                .toCompletableFuture()
                .join();
                
            System.out.println("Wallet created: " + walletId);
            
            // Credit the wallet
            CreditWalletCommand creditCommand = new CreditWalletCommand(walletId, "USD", new BigDecimal("1000.00"));
            
            List<DomainEvent> creditEvents = akcesClient.send(creditCommand)
                .toCompletableFuture()
                .join();
                
            System.out.println("Wallet credited: " + walletId);
        };
    }
}
```

## Benefits of Using Akces Framework

- **Scalability**: Built on Kafka for horizontal scalability across distributed nodes
- **Reliability**: Event sourcing ensures data integrity and provides complete audit trails
- **Flexibility**: Clean separation of commands and queries following CQRS principles
- **Performance**: Efficient state management with RocksDB and optimized query models
- **Security**: Built-in support for data privacy and GDPR compliance
- **Evolution**: Schema evolution with backward compatibility checks
- **Developer Experience**: Intuitive annotation-based programming model
- **Observability**: Transparent view of all commands and events flowing through the system
- **Temporal Queries**: Ability to reconstruct state at any point in time

## License

Apache License 2.0

================
File: RELEASE.md
================
## Release process

This project uses the Maven Release Plugin and GitHub Actions to create releases.\
Just run `mvn release:prepare release:perform && git push` in the root to select the version to be released and create a
VCS tag.

GitHub Actions will
start [the build process](https://github.com/elasticsoftwarefoundation/akces-framework/actions/workflows/maven-publish.yml).

If successful, the build will be automatically published
to [Github Packages](https://maven.pkg.github.com/elasticsoftwarefoundation/akces-framework/).



================================================================
End of Codebase
================================================================
