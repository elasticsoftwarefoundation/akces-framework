This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix. The content has been processed where comments have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.java, **/*.xml, **/*.properties, **/*.proto, **/*.imports, **/*.yaml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types

Additional Info:
----------------

================================================================
Directory Structure
================================================================
crypto-trading/
  aggregates/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                aggregates/
                  account/
                    commands/
                      CreateAccountCommand.java
                    events/
                      AccountCreatedEvent.java
                    Account.java
                    AccountState.java
                  cryptomarket/
                    commands/
                      CreateCryptoMarketCommand.java
                      PlaceMarketOrderCommand.java
                    events/
                      CryptoMarketCreatedEvent.java
                      MarketOrderFilledEvent.java
                      MarketOrderPlacedEvent.java
                      MarketOrderRejectedErrorEvent.java
                    CoinbaseService.java
                    CryptoMarket.java
                    CryptoMarketState.java
                    Order.java
                    Product.java
                    Side.java
                    Ticker.java
                  orders/
                    commands/
                      PlaceBuyOrderCommand.java
                      RejectOrderCommand.java
                    events/
                      BuyOrderCreatedEvent.java
                      BuyOrderPlacedEvent.java
                      BuyOrderRejectedEvent.java
                      UserOrderProcessesCreatedEvent.java
                    BuyOrderProcess.java
                    CryptoMarket.java
                    OrderProcess.java
                    OrderProcessManager.java
                    OrderProcessManagerState.java
                  wallet/
                    commands/
                      CreateBalanceCommand.java
                      CreateWalletCommand.java
                      CreditWalletCommand.java
                      ReserveAmountCommand.java
                    events/
                      AmountReservedEvent.java
                      BalanceAlreadyExistsErrorEvent.java
                      BalanceCreatedEvent.java
                      InsufficientFundsErrorEvent.java
                      InvalidAmountErrorEvent.java
                      InvalidCryptoCurrencyErrorEvent.java
                      WalletCreatedEvent.java
                      WalletCreditedEvent.java
                    Wallet.java
                    WalletState.java
                AggregateConfig.java
        resources/
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CoinbaseMarketDataTest.java
                CoinbaseServiceTest.java
                CryptoTradingApplicationTest.java
                TestUtils.java
        resources/
          akces-client.properties
          logback-test.xml
    pom.xml
  commands/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                web/
                  dto/
                    AccountInput.java
                    AccountOutput.java
                    BalanceOutput.java
                    CreateBalanceInput.java
                    CreditWalletInput.java
                    OrderInput.java
                  errors/
                    ErrorEventException.java
                    ErrorEventResponse.java
                    GlobalExceptionHandler.java
                  AccountCommandController.java
                  OrdersCommandController.java
                  WalletCommandController.java
                ClientConfig.java
        resources/
          akces-framework.properties
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CryptoTradingCommandApiTest.java
                TestUtils.java
        resources/
          logback-test.xml
    pom.xml
  queries/
    src/
      main/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                query/
                  AccountQueryModel.java
                  AccountQueryModelState.java
                  WalletQueryModel.java
                  WalletQueryModelState.java
                web/
                  AccountQueryController.java
                  WalletQueryController.java
                ClientConfig.java
        resources/
          application.properties
      test/
        java/
          org/
            elasticsoftware/
              cryptotrading/
                CryptoTradingE2ETests.java
                CryptoTradingQueryApiTest.java
                TestUtils.java
        resources/
          application-test.properties
          logback-test.xml
    pom.xml
  pom.xml
pom.xml

================================================================
Files
================================================================

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/commands/CreateAccountCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.account.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

@CommandInfo(type = "CreateAccount")
public record CreateAccountCommand(
        @AggregateIdentifier @NotNull String userId,
        @NotNull String country,
        @NotNull String firstName,
        @NotNull String lastName,
        @NotNull String email
) implements Command {
    @Override
    @NotNull
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/events/AccountCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.account.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.annotations.PIIData;
import org.elasticsoftware.akces.events.DomainEvent;


@DomainEventInfo(type = "AccountCreated")
public record AccountCreatedEvent(
        @AggregateIdentifier @NotNull String userId,
        @NotNull String country,
        @NotNull @PIIData String firstName,
        @NotNull @PIIData String lastName,
        @NotNull @PIIData String email
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/Account.java
================
package org.elasticsoftware.cryptotrading.aggregates.account;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.Aggregate;
import org.elasticsoftware.akces.annotations.AggregateInfo;
import org.elasticsoftware.akces.annotations.CommandHandler;
import org.elasticsoftware.akces.annotations.EventSourcingHandler;
import org.elasticsoftware.cryptotrading.aggregates.account.commands.CreateAccountCommand;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;

import java.util.stream.Stream;

@AggregateInfo(value = "Account", generateGDPRKeyOnCreate = true, indexed = true, indexName = "Users")
@SuppressWarnings("unused")
public final class Account implements Aggregate<AccountState> {
    @Override
    public String getName() {
        return "Account";
    }

    @Override
    public Class<AccountState> getStateClass() {
        return AccountState.class;
    }

    @CommandHandler(create = true, produces = AccountCreatedEvent.class, errors = {})
    public Stream<AccountCreatedEvent> create(CreateAccountCommand cmd, AccountState isNull) {
        return Stream.of(new AccountCreatedEvent(cmd.userId(), cmd.country(), cmd.firstName(), cmd.lastName(), cmd.email()));
    }

    @EventSourcingHandler(create = true)
    @NotNull
    public AccountState create(@NotNull AccountCreatedEvent event, AccountState isNull) {
        return new AccountState(event.userId(), event.country(), event.firstName(), event.lastName(), event.email());
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/account/AccountState.java
================
package org.elasticsoftware.cryptotrading.aggregates.account;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.AggregateState;
import org.elasticsoftware.akces.annotations.AggregateStateInfo;
import org.elasticsoftware.akces.annotations.PIIData;

@AggregateStateInfo(type = "Account", version = 1)
public record AccountState(@NotNull String userId,
                           @NotNull String country,
                           @NotNull @PIIData String firstName,
                           @NotNull @PIIData String lastName,
                           @NotNull @PIIData String email) implements AggregateState {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/CreateCryptoMarketCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

@CommandInfo(type = "CreateCryptoMarket", version = 1)
public record CreateCryptoMarketCommand(
        @NotNull String id,
        @NotNull String baseCurrency,
        @NotNull String quoteCurrency,
        @NotNull String baseIncrement,
        @NotNull String quoteIncrement,
        @NotNull String defaultCounterPartyId
) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/commands/PlaceMarketOrderCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Side;

import java.math.BigDecimal;

@CommandInfo(type = "PlaceMarketOrder", version = 1)
public record PlaceMarketOrderCommand(@NotNull String marketId,
                                      @NotNull String orderId,
                                      @NotNull String ownerId,
                                      @NotNull Side side,
                                      BigDecimal funds,
                                      BigDecimal size) implements Command {
    @Override
    public String getAggregateId() {
        return marketId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/CryptoMarketCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events;


import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

@DomainEventInfo(type = "CryptoMarketCreated", version = 1)
public record CryptoMarketCreatedEvent(
        @NotNull String id,
        @NotNull String baseCrypto,
        @NotNull String quoteCrypto,
        @NotNull String baseIncrement,
        @NotNull String quoteIncrement,
        @NotNull String defaultCounterPartyId
) implements DomainEvent {

    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderFilledEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Side;

import java.math.BigDecimal;

@DomainEventInfo(type = "MarketOrderFilled", version = 1)
public record MarketOrderFilledEvent(
        @NotNull String marketId,
        @NotNull String orderId,
        @NotNull String ownerId,
        @NotNull String counterpartyId,
        @NotNull Side side,
        @NotNull String baseCurrency,
        @NotNull String quoteCurrency,
        @NotNull BigDecimal price,
        @NotNull BigDecimal quantity
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return marketId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderPlacedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Side;

import java.math.BigDecimal;

@DomainEventInfo(type = "MarketOrderPlaced", version = 1)
public record MarketOrderPlacedEvent(
        @NotNull String marketId,
        @NotNull String orderId,
        @NotNull String ownerId,
        @NotNull Side side,
        BigDecimal funds,
        BigDecimal size
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return marketId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/events/MarketOrderRejectedErrorEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;

@DomainEventInfo(type = "MarketOrderRejected", version = 1)
public record MarketOrderRejectedErrorEvent(@NotNull String marketId,
                                            @NotNull String orderId,
                                            @NotNull String ownerId,
                                            @NotNull String rejectionReason) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return marketId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CoinbaseService.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;

@Service
public class CoinbaseService {
    private final WebClient webClient;

    public CoinbaseService(@Qualifier("coinbaseWebClient") WebClient webClient) {
        this.webClient = webClient;
    }

    public Ticker getTicker(String productId) {
        return webClient.get()
                .uri("/products/{productId}/ticker", productId)
                .retrieve()
                .bodyToMono(Ticker.class)
                .block();
    }

    public Product getProduct(String productId) {
        return webClient.get()
                .uri("/products/{productId}", productId)
                .retrieve()
                .bodyToMono(Product.class)
                .block();
    }

    public List<Product> getProducts() {
        return webClient.get()
                .uri("/products")
                .retrieve()
                .bodyToFlux(Product.class)
                .collectList()
                .block();
    }


}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarket.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.Aggregate;
import org.elasticsoftware.akces.annotations.AggregateInfo;
import org.elasticsoftware.akces.annotations.CommandHandler;
import org.elasticsoftware.akces.annotations.EventSourcingHandler;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands.CreateCryptoMarketCommand;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands.PlaceMarketOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events.CryptoMarketCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events.MarketOrderFilledEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events.MarketOrderPlacedEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events.MarketOrderRejectedErrorEvent;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.stream.Stream;

@AggregateInfo(value = "CryptoMarket")
public class CryptoMarket implements Aggregate<CryptoMarketState> {
    private final CoinbaseService coinbaseService;
    private final MathContext mathContext = new MathContext(8);

    public CryptoMarket(CoinbaseService coinbaseService) {
        this.coinbaseService = coinbaseService;
    }

    @Override
    public String getName() {
        return "CryptoMarket";
    }

    @Override
    public Class<CryptoMarketState> getStateClass() {
        return CryptoMarketState.class;
    }

    @CommandHandler(create = true, produces = CryptoMarketCreatedEvent.class, errors = {})
    public @NotNull Stream<DomainEvent> handle(@NotNull CreateCryptoMarketCommand command, CryptoMarketState isNull) {
        return Stream.of(new CryptoMarketCreatedEvent(command.id(),
                command.baseCurrency(),
                command.quoteCurrency(),
                command.baseIncrement(),
                command.quoteIncrement(),
                command.defaultCounterPartyId()));
    }

    @CommandHandler(produces = {MarketOrderPlacedEvent.class, MarketOrderFilledEvent.class}, errors = {MarketOrderRejectedErrorEvent.class})
    public @NotNull Stream<DomainEvent> handle(@NotNull PlaceMarketOrderCommand command, CryptoMarketState currentState) {
        if (command.side().equals(Side.BUY) && command.funds() == null) {
            return Stream.of(new MarketOrderRejectedErrorEvent(command.marketId(),
                    command.orderId(),
                    command.ownerId(),
                    "Funds are required for a BUY order"));
        } else if (command.side().equals(Side.SELL) && command.size() == null) {
            return Stream.of(new MarketOrderRejectedErrorEvent(command.marketId(),
                    command.orderId(),
                    command.ownerId(),
                    "Size is required for a SELL order"));
        } else {

            Ticker currentTicker = coinbaseService.getTicker(currentState.id());

            BigDecimal price = command.side().equals(Side.BUY) ? new BigDecimal(currentTicker.ask()) : new BigDecimal(currentTicker.bid());

            BigDecimal quantity = command.side().equals(Side.BUY) ? command.funds().divide(price, mathContext) : command.size();
            MarketOrderFilledEvent marketOrderFilledEvent = new MarketOrderFilledEvent(command.marketId(),
                    command.orderId(),
                    command.ownerId(),
                    currentState.defaultCounterPartyId(),
                    command.side(),
                    currentState.baseCrypto(),
                    currentState.quoteCrypto(),
                    price,
                    quantity);
            MarketOrderPlacedEvent marketOrderPlacedEvent = new MarketOrderPlacedEvent(command.marketId(),
                    command.orderId(),
                    command.ownerId(),
                    command.side(),
                    command.funds(),
                    command.size());
            return Stream.of(marketOrderPlacedEvent, marketOrderFilledEvent);
        }
    }

    @EventSourcingHandler(create = true)
    public @NotNull CryptoMarketState apply(@NotNull CryptoMarketCreatedEvent event, CryptoMarketState isNull) {
        return new CryptoMarketState(event.id(),
                event.baseCrypto(),
                event.quoteCrypto(),
                event.baseIncrement(),
                event.quoteIncrement(),
                event.defaultCounterPartyId());
    }

    @EventSourcingHandler
    public @NotNull CryptoMarketState apply(@NotNull MarketOrderPlacedEvent event, CryptoMarketState currentState) {

        return currentState;
    }

    @EventSourcingHandler
    public @NotNull CryptoMarketState apply(@NotNull MarketOrderFilledEvent event, CryptoMarketState currentState) {

        return currentState;
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/CryptoMarketState.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.AggregateState;
import org.elasticsoftware.akces.annotations.AggregateStateInfo;

@AggregateStateInfo(type = "CryptoMarket", version = 1)
public record CryptoMarketState(
        @NotNull String id,
        @NotNull String baseCrypto,
        @NotNull String quoteCrypto,
        @NotNull String baseIncrement,
        @NotNull String quoteIncrement,
        @NotNull String defaultCounterPartyId
) implements AggregateState {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Order.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotNull;

import java.time.ZonedDateTime;

public record Order(
        @NotNull @JsonProperty("id") String id,
        @JsonProperty("price") String price,
        @JsonProperty("size") String size,
        @NotNull @JsonProperty("product_id") String productId,
        @JsonProperty("profile_id") String profileId,
        @NotNull @JsonProperty("side") String side,
        @JsonProperty("funds") String funds,
        @JsonProperty("specified_funds") String specifiedFunds,
        @NotNull @JsonProperty("type") String type,
        @JsonProperty("time_in_force") String timeInForce,
        @JsonProperty("expire_time") ZonedDateTime expireTime,
        @NotNull @JsonProperty("post_only") Boolean postOnly,
        @NotNull @JsonProperty("created_at") ZonedDateTime createdAt,
        @JsonProperty("done_at") ZonedDateTime doneAt,
        @JsonProperty("done_reason") String doneReason,
        @JsonProperty("reject_reason") String rejectReason,
        @NotNull @JsonProperty("fill_fees") String fillFees,
        @NotNull @JsonProperty("filled_size") String filledSize,
        @JsonProperty("executed_value") String executedValue,
        @NotNull @JsonProperty("status") String status,
        @NotNull @JsonProperty("settled") Boolean settled,
        @JsonProperty("stop") String stop,
        @JsonProperty("stop_price") String stopPrice,
        @JsonProperty("funding_amount") String fundingAmount,
        @JsonProperty("client_oid") String clientOid,
        @JsonProperty("market_type") String marketType,
        @JsonProperty("max_floor") String maxFloor,
        @JsonProperty("secondary_order_id") String secondaryOrderId,
        @JsonProperty("stop_limit_price") String stopLimitPrice
) {
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Product.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;


import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotNull;

public record Product(
        @NotNull @JsonProperty("id") String id,
        @NotNull @JsonProperty("base_currency") String baseCurrency,
        @NotNull @JsonProperty("quote_currency") String quoteCurrency,
        @NotNull @JsonProperty("quote_increment") String quoteIncrement,
        @NotNull @JsonProperty("base_increment") String baseIncrement,
        @NotNull @JsonProperty("display_name") String displayName,
        @NotNull @JsonProperty("min_market_funds") String minMarketFunds,
        @NotNull @JsonProperty("margin_enabled") Boolean marginEnabled,
        @NotNull @JsonProperty("post_only") Boolean postOnly,
        @NotNull @JsonProperty("limit_only") Boolean limitOnly,
        @NotNull @JsonProperty("cancel_only") Boolean cancelOnly,
        @NotNull @JsonProperty("status") String status,
        @NotNull @JsonProperty("status_message") String statusMessage,
        @JsonProperty("trading_disabled") Boolean tradingDisabled,
        @JsonProperty("fx_stablecoin") Boolean fxStablecoin,
        @JsonProperty("max_slippage_percentage") String maxSlippagePercentage,
        @NotNull @JsonProperty("auction_mode") Boolean auctionMode,
        @JsonProperty("high_bid_limit_percentage") String highBidLimitPercentage
) {
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Side.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

public enum Side {
    BUY, SELL
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/cryptomarket/Ticker.java
================
package org.elasticsoftware.cryptotrading.aggregates.cryptomarket;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotNull;

public record Ticker(
        @NotNull @JsonProperty("trade_id") Integer tradeId,
        @NotNull @JsonProperty("price") String price,
        @NotNull @JsonProperty("size") String size,
        @NotNull @JsonProperty("time") String time,
        @NotNull @JsonProperty("bid") String bid,
        @NotNull @JsonProperty("ask") String ask,
        @NotNull @JsonProperty("volume") String volume,
        @JsonProperty("rfq_volume") String rfqVolume,
        @JsonProperty("conversions_volume") String conversionsVolume
) {
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/PlaceBuyOrderCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;
import org.elasticsoftware.cryptotrading.aggregates.orders.CryptoMarket;

import java.math.BigDecimal;

@CommandInfo(type = "PlaceBuyOrder", version = 1)
public record PlaceBuyOrderCommand(
        @NotNull @AggregateIdentifier String userId,
        @NotNull CryptoMarket market,
        @NotNull BigDecimal amount,
        @NotNull String clientReference
) implements Command {
    @Override
    @NotNull
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/commands/RejectOrderCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

@CommandInfo(type = "RejectOrder", version = 1)
public record RejectOrderCommand(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String orderId
) implements Command {
    @Override
    @NotNull
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.CryptoMarket;

import java.math.BigDecimal;

@DomainEventInfo(type = "BuyOrderCreated", version = 1)
public record BuyOrderCreatedEvent(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String orderId,
        @NotNull CryptoMarket market,
        @NotNull BigDecimal amount,
        @NotNull String clientReference
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return orderId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderPlacedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.CryptoMarket;

import java.math.BigDecimal;

@DomainEventInfo(type = "BuyOrderPlaced", version = 1)
public record BuyOrderPlacedEvent(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String orderId,
        @NotNull CryptoMarket market,
        @NotNull BigDecimal amount,
        BigDecimal limitPrice
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return orderId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/BuyOrderRejectedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

@DomainEventInfo(type = "BuyOrderRejected", version = 1)
public record BuyOrderRejectedEvent(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String orderId,
        @NotNull String clientReference
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/events/UserOrderProcessesCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

@DomainEventInfo(type = "UserOrderProcessesCreated", version = 1)
public record UserOrderProcessesCreatedEvent(@NotNull @AggregateIdentifier String userId) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/BuyOrderProcess.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders;

import org.elasticsoftware.cryptotrading.aggregates.orders.commands.RejectOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.BuyOrderRejectedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InsufficientFundsErrorEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InvalidCryptoCurrencyErrorEvent;

import java.math.BigDecimal;

public record BuyOrderProcess(
        String orderId,
        CryptoMarket market,
        BigDecimal size,
        BigDecimal amount,
        String clientReference
) implements OrderProcess {
    public BuyOrderProcess(String orderId,
                           CryptoMarket market,
                           BigDecimal amount,
                           String clientReference) {
        this(orderId, market, null, amount, clientReference);
    }

    @Override
    public String getProcessId() {
        return orderId();
    }

    @Override
    public BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error) {
        return new BuyOrderRejectedEvent(error.walletId(), orderId(), clientReference());
    }

    @Override
    public BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error) {
        return new BuyOrderRejectedEvent(error.walletId(), orderId(), clientReference());
    }

    @Override
    public BuyOrderRejectedEvent handle(RejectOrderCommand command) {
        return new BuyOrderRejectedEvent(command.userId(), orderId(), clientReference());
    }

}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/CryptoMarket.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders;

public record CryptoMarket(String id, String baseCrypto, String quoteCrypto) {
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcess.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import org.elasticsoftware.akces.processmanager.AkcesProcess;
import org.elasticsoftware.cryptotrading.aggregates.orders.commands.RejectOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.BuyOrderRejectedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InsufficientFundsErrorEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InvalidCryptoCurrencyErrorEvent;

import java.math.BigDecimal;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonSubTypes({
        @JsonSubTypes.Type(value = BuyOrderProcess.class, name = "BUY")
})
public sealed interface OrderProcess extends AkcesProcess permits BuyOrderProcess {
    String orderId();

    CryptoMarket market();

    BigDecimal size();

    BigDecimal amount();

    String clientReference();

    BuyOrderRejectedEvent handle(InsufficientFundsErrorEvent error);

    BuyOrderRejectedEvent handle(InvalidCryptoCurrencyErrorEvent error);

    BuyOrderRejectedEvent handle(RejectOrderCommand command);
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManager.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders;

import org.elasticsoftware.akces.aggregate.Aggregate;
import org.elasticsoftware.akces.annotations.AggregateInfo;
import org.elasticsoftware.akces.annotations.CommandHandler;
import org.elasticsoftware.akces.annotations.EventHandler;
import org.elasticsoftware.akces.annotations.EventSourcingHandler;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Side;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands.PlaceMarketOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.events.MarketOrderRejectedErrorEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.commands.PlaceBuyOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.orders.commands.RejectOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.BuyOrderCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.BuyOrderPlacedEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.BuyOrderRejectedEvent;
import org.elasticsoftware.cryptotrading.aggregates.orders.events.UserOrderProcessesCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.ReserveAmountCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.AmountReservedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InsufficientFundsErrorEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.InvalidCryptoCurrencyErrorEvent;

import java.util.ArrayList;
import java.util.UUID;
import java.util.stream.Stream;

@AggregateInfo(value = "OrderProcessManager", indexed = true, indexName = "Users")
public class OrderProcessManager implements Aggregate<OrderProcessManagerState> {
    @Override
    public String getName() {
        return "OrderProcessManager";
    }

    @Override
    public Class<OrderProcessManagerState> getStateClass() {
        return OrderProcessManagerState.class;
    }

    @EventHandler(create = true, produces = UserOrderProcessesCreatedEvent.class, errors = {})
    public Stream<UserOrderProcessesCreatedEvent> create(AccountCreatedEvent event, OrderProcessManagerState isNull) {
        return Stream.of(new UserOrderProcessesCreatedEvent(event.userId()));
    }

    @EventSourcingHandler(create = true)
    public OrderProcessManagerState create(UserOrderProcessesCreatedEvent event, OrderProcessManagerState isNull) {
        return new OrderProcessManagerState(event.userId());
    }

    @EventSourcingHandler
    public OrderProcessManagerState handle(BuyOrderCreatedEvent event, OrderProcessManagerState state) {
        return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
            add(new BuyOrderProcess(
                    event.orderId(),
                    event.market(),
                    event.amount(),
                    event.clientReference()));
        }});
    }

    @EventSourcingHandler
    public OrderProcessManagerState handle(BuyOrderRejectedEvent event, OrderProcessManagerState state) {
        return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
            removeIf(process -> process.orderId().equals(event.orderId()));
        }});
    }

    @EventSourcingHandler
    public OrderProcessManagerState handle(BuyOrderPlacedEvent event, OrderProcessManagerState state) {

        return new OrderProcessManagerState(state.userId(), new ArrayList<>(state.runningProcesses()) {{
            removeIf(process -> process.orderId().equals(event.orderId()));
        }});
    }








    @CommandHandler(produces = BuyOrderCreatedEvent.class, errors = {})
    public Stream<BuyOrderCreatedEvent> placeBuyOrder(PlaceBuyOrderCommand command, OrderProcessManagerState state) {

        String orderId = UUID.randomUUID().toString();

        getCommandBus().send(new ReserveAmountCommand(
                state.userId(),
                command.market().quoteCrypto(),
                command.amount(),
                orderId));

        return Stream.of(new BuyOrderCreatedEvent(
                state.userId(),
                orderId,
                command.market(),
                command.amount(),
                command.clientReference()));
    }

    @CommandHandler(produces = BuyOrderRejectedEvent.class, errors = {})
    public Stream<BuyOrderRejectedEvent> rejectOrder(RejectOrderCommand command, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(command.orderId())) {
            return Stream.of(state.getAkcesProcess(command.orderId()).handle(command));
        } else {
            return Stream.empty();
        }
    }

    @EventHandler(produces = BuyOrderPlacedEvent.class, errors = {})
    public Stream<DomainEvent> handle(AmountReservedEvent event, OrderProcessManagerState state) {

        OrderProcess orderProcess = state.getAkcesProcess(event.referenceId());
        if (orderProcess != null) {
            getCommandBus().send(new PlaceMarketOrderCommand(
                    orderProcess.market().id(),
                    orderProcess.orderId(),
                    state.userId(),
                    Side.BUY,
                    orderProcess.amount(),
                    null));
            return Stream.of(new BuyOrderPlacedEvent(state.userId(), orderProcess.orderId(), orderProcess.market(), orderProcess.amount(), null));
        } else {

            return Stream.empty();
        }
    }

    @EventHandler(produces = BuyOrderRejectedEvent.class, errors = {})
    public Stream<DomainEvent> handle(InsufficientFundsErrorEvent errorEvent, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(errorEvent.referenceId())) {
            return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
        } else {
            return Stream.empty();
        }
    }

    @EventHandler(produces = BuyOrderRejectedEvent.class, errors = {})
    public Stream<DomainEvent> handle(InvalidCryptoCurrencyErrorEvent errorEvent, OrderProcessManagerState state) {
        if (state.hasAkcesProcess(errorEvent.referenceId())) {
            return Stream.of(state.getAkcesProcess(errorEvent.referenceId()).handle(errorEvent));
        } else {
            return Stream.empty();
        }
    }

    @EventHandler(produces = {}, errors = {})
    public Stream<DomainEvent> handle(MarketOrderRejectedErrorEvent errorEvent, OrderProcessManagerState state) {

        getCommandBus().send(new RejectOrderCommand(state.userId(), errorEvent.orderId()));
        return Stream.empty();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/orders/OrderProcessManagerState.java
================
package org.elasticsoftware.cryptotrading.aggregates.orders;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.processmanager.ProcessManagerState;
import org.elasticsoftware.akces.processmanager.UnknownAkcesProcessException;

import java.util.List;

public record OrderProcessManagerState(
        @NotNull @AggregateIdentifier String userId,
        List<BuyOrderProcess> runningProcesses
) implements ProcessManagerState<OrderProcess> {
    public OrderProcessManagerState(@NotNull String userId) {
        this(userId, List.of());
    }

    @Override
    public String getAggregateId() {
        return userId();
    }

    @Override
    public OrderProcess getAkcesProcess(String processId) {
        return runningProcesses.stream().filter(p -> p.orderId().equals(processId)).findFirst()
                .orElseThrow(() -> new UnknownAkcesProcessException("OrderProcessManager", userId(), processId));
    }

    @Override
    public boolean hasAkcesProcess(String processId) {
        return runningProcesses.stream().anyMatch(p -> p.orderId().equals(processId));
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateBalanceCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

@CommandInfo(type = "CreateBalance", version = 1)
public record CreateBalanceCommand(
        @NotNull @AggregateIdentifier String id,
        @NotNull String currency
) implements Command {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreateWalletCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

@CommandInfo(type = "CreateWallet", version = 1)
public record CreateWalletCommand(
        @NotNull @AggregateIdentifier String id,
        @NotNull String currency
) implements Command {
    @NotNull
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/CreditWalletCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

import java.math.BigDecimal;

@CommandInfo(type = "CreditWallet", version = 1)
public record CreditWalletCommand(
        @NotNull @AggregateIdentifier String id,
        @NotNull String currency,
        @NotNull BigDecimal amount
) implements Command {
    @NotNull
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/commands/ReserveAmountCommand.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.commands;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.CommandInfo;
import org.elasticsoftware.akces.commands.Command;

import java.math.BigDecimal;

@CommandInfo(type = "ReserveAmount", version = 1)
public record ReserveAmountCommand(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String currency,
        @NotNull BigDecimal amount,
        @NotNull String referenceId
) implements Command {
    @Override
    @NotNull
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/AmountReservedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

import java.math.BigDecimal;

@DomainEventInfo(type = "AmountReserved", version = 1)
public record AmountReservedEvent(
        @NotNull @AggregateIdentifier String userId,
        @NotNull String currency,
        @NotNull BigDecimal amount,
        @NotNull String referenceId
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return userId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceAlreadyExistsErrorEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;

@DomainEventInfo(type = "BalanceAlreadyExistsError")
public record BalanceAlreadyExistsErrorEvent(@AggregateIdentifier @NotNull String walletId,
                                             @NotNull String currency) implements ErrorEvent {
    @Override
    public String getAggregateId() {
        return walletId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/BalanceCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

@DomainEventInfo(type = "BalanceCreated")
public record BalanceCreatedEvent(
        @AggregateIdentifier @NotNull String id,
        @NotNull String currency
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InsufficientFundsErrorEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.annotation.Nullable;
import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;

import java.math.BigDecimal;

@DomainEventInfo(type = "InsufficientFundsError")
public record InsufficientFundsErrorEvent(
        @NotNull @AggregateIdentifier String walletId,
        @NotNull String currency,
        @NotNull BigDecimal availableAmount,
        @NotNull BigDecimal requestedAmount,
        @Nullable String referenceId
) implements ErrorEvent {
    @Override
    public @NotNull String getAggregateId() {
        return walletId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidAmountErrorEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;

@DomainEventInfo(type = "InvalidAmountError")
public record InvalidAmountErrorEvent(
        @NotNull @AggregateIdentifier String walletId,
        @NotNull String currency,
        String referenceId
) implements ErrorEvent {
    public InvalidAmountErrorEvent(@NotNull String walletId, @NotNull String currency) {
        this(walletId, currency, null);
    }

    @Override
    public @NotNull String getAggregateId() {
        return walletId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/InvalidCryptoCurrencyErrorEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.annotation.Nullable;
import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;

@DomainEventInfo(type = "InvalidCryptoCurrencyError")
public record InvalidCryptoCurrencyErrorEvent(
        @NotNull @AggregateIdentifier String walletId,
        @NotNull String cryptoCurrency,
        @Nullable String referenceId
) implements ErrorEvent {
    public InvalidCryptoCurrencyErrorEvent(@NotNull String walletId, @NotNull String cryptoCurrency) {
        this(walletId, cryptoCurrency, null);
    }

    @NotNull
    @Override
    public String getAggregateId() {
        return walletId();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreatedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

@DomainEventInfo(type = "WalletCreated")
public record WalletCreatedEvent(
        @AggregateIdentifier @NotNull String id
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/events/WalletCreditedEvent.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet.events;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.DomainEvent;

import java.math.BigDecimal;

@DomainEventInfo(type = "WalletCredited")
public record WalletCreditedEvent(
        @AggregateIdentifier @NotNull String id,
        @NotNull String currency,
        @NotNull BigDecimal amount,
        @NotNull BigDecimal balance
) implements DomainEvent {
    @Override
    public String getAggregateId() {
        return id();
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/Wallet.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.Aggregate;
import org.elasticsoftware.akces.annotations.AggregateInfo;
import org.elasticsoftware.akces.annotations.CommandHandler;
import org.elasticsoftware.akces.annotations.EventHandler;
import org.elasticsoftware.akces.annotations.EventSourcingHandler;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreateBalanceCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreateWalletCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreditWalletCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.ReserveAmountCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;


@AggregateInfo(value = "Wallet", version = 1, indexed = true, indexName = "Users")
@SuppressWarnings("unused")
public final class Wallet implements Aggregate<WalletState> {
    @Override
    public String getName() {
        return "Wallet";
    }

    @Override
    public Class<WalletState> getStateClass() {
        return WalletState.class;
    }

    @CommandHandler(create = true, produces = WalletCreatedEvent.class, errors = {})
    public @NotNull Stream<DomainEvent> create(@NotNull CreateWalletCommand cmd, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(cmd.id()), new BalanceCreatedEvent(cmd.id(), cmd.currency()));
    }

    @EventHandler(create = true, produces = WalletCreatedEvent.class, errors = {})
    public @NotNull Stream<DomainEvent> create(@NotNull AccountCreatedEvent event, WalletState isNull) {
        return Stream.of(new WalletCreatedEvent(event.getAggregateId()), new BalanceCreatedEvent(event.getAggregateId(), "EUR"));
    }

    @CommandHandler(produces = WalletCreditedEvent.class, errors = {InvalidCryptoCurrencyErrorEvent.class, InvalidAmountErrorEvent.class})
    @NotNull
    public Stream<DomainEvent> credit(@NotNull CreditWalletCommand cmd, @NotNull WalletState currentState) {
        WalletState.Balance balance = currentState.balances().stream().filter(b -> b.currency().equals(cmd.currency())).findFirst().orElse(null);
        if (balance == null) {

            return Stream.of(new InvalidCryptoCurrencyErrorEvent(cmd.id(), cmd.currency()));
        }
        if (cmd.amount().compareTo(BigDecimal.ZERO) < 0) {

            return Stream.of(new InvalidAmountErrorEvent(cmd.id(), cmd.currency()));
        }
        return Stream.of(new WalletCreditedEvent(currentState.id(), cmd.currency(), cmd.amount(), balance.amount().add(cmd.amount())));
    }

    @CommandHandler(produces = AmountReservedEvent.class, errors = {InvalidCryptoCurrencyErrorEvent.class, InvalidAmountErrorEvent.class, InsufficientFundsErrorEvent.class})
    public Stream<DomainEvent> makeReservation(ReserveAmountCommand command, WalletState state) {
        WalletState.Balance balance = state.balances().stream().filter(b -> b.currency().equals(command.currency())).findFirst().orElse(null);
        if (balance == null) {

            return Stream.of(new InvalidCryptoCurrencyErrorEvent(command.userId(), command.currency(), command.referenceId()));
        }
        if (command.amount().compareTo(BigDecimal.ZERO) < 0) {

            return Stream.of(new InvalidAmountErrorEvent(command.userId(), command.currency()));
        }

        if (balance.getAvailableAmount().compareTo(command.amount()) >= 0) {
            return Stream.of(new AmountReservedEvent(command.userId(), command.currency(), command.amount(), command.referenceId()));
        } else {
            return Stream.of(new InsufficientFundsErrorEvent(command.userId(), command.currency(), balance.getAvailableAmount(), command.amount(), command.referenceId()));
        }
    }

    @EventSourcingHandler(create = true)
    public @NotNull WalletState create(@NotNull WalletCreatedEvent event, WalletState isNull) {
        return new WalletState(event.id(), new ArrayList<>());
    }

    @EventSourcingHandler
    public @NotNull WalletState createBalance(@NotNull BalanceCreatedEvent event, WalletState state) {
        List<WalletState.Balance> balances = new ArrayList<>(state.balances());
        balances.add(new WalletState.Balance(event.currency(), BigDecimal.ZERO));
        return new WalletState(state.id(), balances);
    }

    @EventSourcingHandler
    public @NotNull WalletState credit(@NotNull WalletCreditedEvent event, @NotNull WalletState state) {
        return new WalletState(state.id(), state.balances().stream().map(b -> {
            if (b.currency().equals(event.currency())) {
                return new WalletState.Balance(b.currency(), b.amount().add(event.amount()));
            } else {
                return b;
            }
        }).toList());
    }

    @EventSourcingHandler
    public @NotNull WalletState reserveAmount(@NotNull AmountReservedEvent event, @NotNull WalletState state) {
        return new WalletState(state.id(), state.balances().stream().map(b -> {
            if (b.currency().equals(event.currency())) {
                return new WalletState.Balance(b.currency(), b.amount(), b.reservedAmount().add(event.amount()));
            } else {
                return b;
            }
        }).toList());
    }

    @CommandHandler(produces = BalanceCreatedEvent.class, errors = {BalanceAlreadyExistsErrorEvent.class})
    public @NotNull Stream<DomainEvent> createBalance(@NotNull CreateBalanceCommand cmd, @NotNull WalletState currentState) {
        boolean balanceExists = currentState.balances().stream()
                .anyMatch(balance -> balance.currency().equals(cmd.currency()));
        if (balanceExists) {
            return Stream.of(new BalanceAlreadyExistsErrorEvent(cmd.id(), cmd.currency()));
        }
        return Stream.of(new BalanceCreatedEvent(cmd.id(), cmd.currency()));
    }

}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/aggregates/wallet/WalletState.java
================
package org.elasticsoftware.cryptotrading.aggregates.wallet;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.aggregate.AggregateState;
import org.elasticsoftware.akces.annotations.AggregateIdentifier;
import org.elasticsoftware.akces.annotations.AggregateStateInfo;

import java.math.BigDecimal;
import java.util.List;

@AggregateStateInfo(type = "Wallet", version = 1)
public record WalletState(
        @AggregateIdentifier @NotNull String id,
        List<Balance> balances
) implements AggregateState {
    @Override
    public String getAggregateId() {
        return id();
    }

    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(@NotNull String currency) {
            this(currency, BigDecimal.ZERO, BigDecimal.ZERO);
        }

        public Balance(@NotNull String currency, @NotNull BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }

        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}

================
File: crypto-trading/aggregates/src/main/java/org/elasticsoftware/cryptotrading/AggregateConfig.java
================
package org.elasticsoftware.cryptotrading;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
@ComponentScan(basePackages = {
        "org.elasticsoftware.cryptotrading.aggregates",
})
public class AggregateConfig {
    @Bean("coinbaseWebClient")
    public WebClient coinbaseWebClient() {
        return WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
    }
}

================
File: crypto-trading/aggregates/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading Command Service
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseMarketDataTest.java
================
package org.elasticsoftware.cryptotrading;

import org.junit.jupiter.api.Test;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;


public class CoinbaseMarketDataTest {

    @Test
    void testCoinbaseGetProducts() {
        WebClient webClient = WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        String response = webClient.get()
                .uri("/products")
                .retrieve()
                .bodyToMono(String.class)
                .block();

        System.out.println(response);
    }

    @Test
    void testCoinbaseGetSingleProduct() {
        WebClient webClient = WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        String response = webClient.get()
                .uri("/products/BTC-EUR")
                .retrieve()
                .bodyToMono(String.class)
                .block();

        System.out.println(response);
    }

    @Test
    void testGetCoinbaseTicker() {
        WebClient webClient = WebClient.builder()
                .baseUrl("https://api.exchange.coinbase.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        String response = webClient.get()
                .uri("/products/BTC-EUR/ticker")
                .retrieve()
                .bodyToMono(String.class)
                .block();

        System.out.println(response);
    }
}

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CoinbaseServiceTest.java
================
package org.elasticsoftware.cryptotrading;

import jakarta.inject.Inject;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.CoinbaseService;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Product;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Ticker;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest(classes = {AggregateConfig.class})
public class CoinbaseServiceTest {
    @Inject
    private CoinbaseService coinbaseService;

    @Test
    public void testGetProductById() {
        String productId = "BTC-USD";
        Product product = coinbaseService.getProduct(productId);
        assertNotNull(product, "Product should not be null");

    }

    @Test
    public void testGetTickerById() {
        String productId = "BTC-USD";
        Ticker ticker = coinbaseService.getTicker(productId);
        assertNotNull(ticker, "Ticker should not be null");

    }

    @Test
    public void testGetProducts() {
        List<Product> products = coinbaseService.getProducts();
        assertNotNull(products, "Products should not be null");
        products.forEach(product -> {
            System.out.println(product.id());
        });
    }

}

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingApplicationTest.java
================
package org.elasticsoftware.cryptotrading;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.inject.Inject;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.ConsumerRebalanceListener;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.common.TopicPartition;
import org.elasticsoftware.akces.AggregateServiceApplication;
import org.elasticsoftware.akces.AkcesAggregateController;
import org.elasticsoftware.akces.client.AkcesClientController;
import org.elasticsoftware.akces.control.AggregateServiceRecord;
import org.elasticsoftware.akces.control.AkcesControlRecord;
import org.elasticsoftware.akces.protocol.ProtocolRecord;
import org.elasticsoftware.cryptotrading.aggregates.account.commands.CreateAccountCommand;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.CoinbaseService;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.Product;
import org.elasticsoftware.cryptotrading.aggregates.cryptomarket.commands.CreateCryptoMarketCommand;
import org.elasticsoftware.cryptotrading.aggregates.orders.CryptoMarket;
import org.elasticsoftware.cryptotrading.aggregates.orders.commands.PlaceBuyOrderCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreateBalanceCommand;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreditWalletCommand;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.support.TestPropertySourceUtils;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.KafkaContainer;
import org.testcontainers.containers.Network;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;
import reactor.core.publisher.Mono;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.*;
import java.util.regex.Pattern;

import static org.assertj.core.api.Assertions.assertThat;
import static org.elasticsoftware.cryptotrading.TestUtils.prepareAggregateServiceRecords;
import static org.elasticsoftware.cryptotrading.TestUtils.prepareKafka;

@SpringBootTest(
        classes = AggregateServiceApplication.class,
        args = "org.elasticsoftware.cryptotrading.AggregateConfig",
        useMainMethod = SpringBootTest.UseMainMethod.ALWAYS,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ContextConfiguration(initializers = CryptoTradingApplicationTest.Initializer.class)
@Testcontainers
@DirtiesContext
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class CryptoTradingApplicationTest {
    private static final String CONFLUENT_PLATFORM_VERSION = "7.8.1";

    private static final Network network = Network.newNetwork();

    @Container
    private static final KafkaContainer kafka =
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");

    @Container
    private static final GenericContainer<?> schemaRegistry =
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withNetwork(network)
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    private final static String counterPartyId = "337f335d-caf1-4f85-9440-6bc3c0ebbb77";
    @Inject
    @Qualifier("WalletAkcesController")
    AkcesAggregateController walletController;
    @Inject
    @Qualifier("AccountAkcesController")
    AkcesAggregateController accountController;
    @Inject
    @Qualifier("OrderProcessManagerAkcesController")
    AkcesAggregateController prderProcessManagerController;
    @Inject
    @Qualifier("CryptoMarketAkcesController")
    AkcesAggregateController cryptoMarketController;
    @Inject
    AkcesClientController akcesClientController;
    @Inject
    CoinbaseService coinbaseService;
    @Inject
    @Qualifier("aggregateServiceConsumerFactory")
    ConsumerFactory<String, ProtocolRecord> consumerFactory;
    @Inject
    @Qualifier("aggregateServiceControlConsumerFactory")
    ConsumerFactory<String, AkcesControlRecord> controlConsumerFactory;
    @LocalServerPort
    private int port;
    @Inject
    private WebTestClient webTestClient;
    @Inject
    private ObjectMapper objectMapper;

    @AfterAll
    @BeforeAll
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {

            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        }
    }

    @Test
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    void healthLivenessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/liveness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    @Order(1)
    void contextLoads() throws IOException {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();

        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        try (Consumer<String, AkcesControlRecord> controlConsumer = controlConsumerFactory.createConsumer("Test-AkcesControl", "test-akces-control")) {
            TopicPartition controlPartition = new TopicPartition("Akces-Control", 0);
            controlConsumer.assign(List.of(controlPartition));
            controlConsumer.seekToBeginning(controlConsumer.assignment());
            Map<TopicPartition, Long> endOffsets = controlConsumer.endOffsets(controlConsumer.assignment());

            Map<String, AggregateServiceRecord> serviceRecords = new HashMap<>();

            while (endOffsets.getOrDefault(controlPartition, 0L) > controlConsumer.position(controlPartition)) {
                ConsumerRecords<String, AkcesControlRecord> controlRecords = controlConsumer.poll(Duration.ofMillis(1000));
                if (!controlRecords.isEmpty()) {
                    for (ConsumerRecord<String, AkcesControlRecord> record : controlRecords.records(controlPartition)) {
                        if (record.value() instanceof AggregateServiceRecord aggregateServiceRecord) {
                            System.out.println(objectMapper.writeValueAsString(aggregateServiceRecord));
                            serviceRecords.put(record.key(), aggregateServiceRecord);
                        }
                    }
                }
            }

            Assertions.assertEquals(4, serviceRecords.size());

        }
    }

    @Test
    @Order(2)
    void testCreateAllEURMarketsAndMakeATrade() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }


        akcesClientController.sendAndForget("TEST",
                new CreateAccountCommand(counterPartyId,
                        "EU",
                        "Coinbase",
                        "Limited",
                        "no-reply@coinbase.com"));












        Product product = coinbaseService.getProduct("BTC-EUR");
        akcesClientController.sendAndForget("TEST", new CreateCryptoMarketCommand(
                product.id(),
                product.baseCurrency(),
                product.quoteCurrency(),
                product.baseIncrement(),
                product.quoteIncrement(),
                counterPartyId));


        String accountId = "2254b8cb-f272-4695-82cf-306ba0149829";
        Mono.fromCompletionStage(akcesClientController.send("TEST", new CreateAccountCommand(accountId,
                "NL",
                "John",
                "Doe",
                "john.doe@example.com"))).block();


        Mono.fromCompletionStage(akcesClientController.send("TEST",
                new CreateBalanceCommand(accountId, "BTC"))).block();

        Mono.fromCompletionStage(akcesClientController.send("TEST",
                new CreditWalletCommand(accountId,
                        "EUR",
                        new BigDecimal("1000")))).block();
        ;


        String clientOrderId = "479ab2a4-d19e-4116-9f7e-cf13dca5763a";
        Mono.fromCompletionStage(akcesClientController.send("TEST",
                new PlaceBuyOrderCommand(accountId,
                        new CryptoMarket("BTC-EUR", "BTC", "EUR"),
                        new BigDecimal("250"),
                        clientOrderId))).block();


        try (
                Consumer<String, ProtocolRecord> testConsumer = consumerFactory.createConsumer("Test", "test")
        ) {
            testConsumer.subscribe(Pattern.compile(".*-DomainEvents$"), new ConsumerRebalanceListener() {
                @Override
                public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                }

                @Override
                public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                    testConsumer.seekToBeginning(partitions);
                }
            });
            int count = 0;
            while (count < 16) {
                for (ConsumerRecord<String, ProtocolRecord> record : testConsumer.poll(Duration.ofMillis(100))) {
                    System.out.println(record.topic() + " : " + record.value().name() + "=" + new String(record.value().payload()));
                    count++;
                }
            }
        }
    }

    public static class Initializer
            implements ApplicationContextInitializer<ConfigurableApplicationContext> {

        @Override
        public void initialize(ConfigurableApplicationContext applicationContext) {

            prepareKafka(kafka.getBootstrapServers());
            try {
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    applicationContext,
                    "akces.rocksdb.baseDir=/tmp/akces",
                    "spring.kafka.enabled=true",
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)
            );
        }
    }

}

================
File: crypto-trading/aggregates/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
package org.elasticsoftware.cryptotrading;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;
import org.elasticsoftware.akces.control.AggregateServiceRecord;
import org.elasticsoftware.akces.control.AkcesControlRecord;
import org.elasticsoftware.akces.gdpr.jackson.AkcesGDPRModule;
import org.elasticsoftware.akces.serialization.AkcesControlRecordSerde;
import org.elasticsoftware.akces.serialization.BigDecimalSerializer;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.kafka.core.KafkaAdmin;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;

public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    }

    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    }

    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "delete",
                "max.message.bytes", "20971520",
                "retention.ms", Long.toString(retentionMs),
                "segment.ms", "604800000"));
    }

    private static NewTopic createCompactedTopic(String name, int numPartitions) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "compact",
                "max.message.bytes", "20971520",
                "retention.ms", "-1",
                "segment.ms", "604800000",
                "min.cleanable.dirty.ratio", "0.1",
                "delete.retention.ms", "604800000",
                "compression.type", "lz4"));
    }

    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers,
                ProducerConfig.ACKS_CONFIG, "all",
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, "true",
                ProducerConfig.LINGER_MS_CONFIG, "0",
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, "1",
                ProducerConfig.RETRIES_CONFIG, "2147483647",
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG, "0",
                ProducerConfig.TRANSACTIONAL_ID_CONFIG, "Test-AkcesControllerProducer",
                ProducerConfig.CLIENT_ID_CONFIG, "Test-AkcesControllerProducer");
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
            for (int partition = 0; partition < 3; partition++) {
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            }
            controlProducer.commitTransaction();
        }
    }
}

================
File: crypto-trading/aggregates/src/test/resources/akces-client.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/aggregates/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/aggregates/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.7.21-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-aggregates</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Aggregates</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-runtime</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>


    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <id>process-aot</id>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.AggregateServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.AggregateConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>






                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.4.2</version>
                <executions>
                    <execution>
                        <id>commands-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>commands</classifier>
                            <includes>
                                <include>**/commands/*</include>
                            </includes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>events-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>events</classifier>
                            <includes>
                                <include>**/events/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>






        </plugins>
    </build>

</project>

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountInput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.cryptotrading.aggregates.account.commands.CreateAccountCommand;

public record AccountInput(@NotNull String country,
                           @NotNull String firstName,
                           @NotNull String lastName,
                           @NotNull String email) {
    public CreateAccountCommand toCommand(String userId) {
        return new CreateAccountCommand(userId, country(), firstName(), lastName(), email());
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/AccountOutput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import jakarta.validation.constraints.NotNull;

public record AccountOutput(@NotNull String userId,
                            @NotNull String country,
                            @NotNull String firstName,
                            @NotNull String lastName,
                            @NotNull String email) {
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/BalanceOutput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import org.elasticsoftware.cryptotrading.aggregates.wallet.events.BalanceCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.WalletCreditedEvent;

import java.math.BigDecimal;

public record BalanceOutput(String id,
                            String currency,
                            BigDecimal amount,
                            BigDecimal balance) {
    public static BalanceOutput from(WalletCreditedEvent event) {
        return new BalanceOutput(event.id(), event.currency(), event.amount(), event.balance());
    }

    public static BalanceOutput from(BalanceCreatedEvent event) {
        return new BalanceOutput(event.id(), event.currency(), BigDecimal.ZERO, BigDecimal.ZERO);
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreateBalanceInput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreateBalanceCommand;

public record CreateBalanceInput(@NotNull String currency) {
    public CreateBalanceCommand toCommand(String walletId) {
        return new CreateBalanceCommand(walletId, this.currency);
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/CreditWalletInput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import org.elasticsoftware.cryptotrading.aggregates.wallet.commands.CreditWalletCommand;

import java.math.BigDecimal;

public record CreditWalletInput(BigDecimal amount) {
    public CreditWalletCommand toCommand(String userId, String currency) {
        return new CreditWalletCommand(userId, currency, amount);
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/dto/OrderInput.java
================
package org.elasticsoftware.cryptotrading.web.dto;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.cryptotrading.aggregates.orders.CryptoMarket;

import java.math.BigDecimal;

public record OrderInput(@NotNull CryptoMarket market,
                         @NotNull BigDecimal amount,
                         @NotNull String clientReference) {
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventException.java
================
package org.elasticsoftware.cryptotrading.web.errors;

import org.elasticsoftware.akces.events.ErrorEvent;

public class ErrorEventException extends RuntimeException {
    private final ErrorEvent errorEvent;

    public ErrorEventException(ErrorEvent errorEvent) {
        super();
        this.errorEvent = errorEvent;
    }

    public ErrorEvent getErrorEvent() {
        return errorEvent;
    }

}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/ErrorEventResponse.java
================
package org.elasticsoftware.cryptotrading.web.errors;

public record ErrorEventResponse(String eventType) {
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/errors/GlobalExceptionHandler.java
================
package org.elasticsoftware.cryptotrading.web.errors;

import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.events.ErrorEvent;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler;

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    @ExceptionHandler(ErrorEventException.class)
    protected ResponseEntity<ErrorEventResponse> handleErrorEvent(ErrorEventException ex) {
        ErrorEvent errorEvent = ex.getErrorEvent();
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorEventResponse(errorEvent.getClass().getAnnotation(DomainEventInfo.class).type()));
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/AccountCommandController.java
================
package org.elasticsoftware.cryptotrading.web;

import org.elasticsoftware.akces.client.AkcesClient;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;
import org.elasticsoftware.cryptotrading.web.dto.AccountInput;
import org.elasticsoftware.cryptotrading.web.dto.AccountOutput;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/v{version:1}/accounts")
public class AccountCommandController {
    private final AkcesClient akcesClient;

    public AccountCommandController(AkcesClient akcesClient) {
        this.akcesClient = akcesClient;
    }

    @PostMapping
    public Mono<ResponseEntity<AccountOutput>> createAccount(@RequestBody AccountInput input) {
        String userId = UUID.randomUUID().toString();
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(userId)))
                .map(List::getFirst)
                .map(domainEvent -> {
                    AccountCreatedEvent event = (AccountCreatedEvent) domainEvent;
                    AccountOutput output = new AccountOutput(event.userId(), input.country(), input.firstName(), input.lastName(), input.email());
                    return ResponseEntity.ok(output);
                });
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/OrdersCommandController.java
================
package org.elasticsoftware.cryptotrading.web;

import org.elasticsoftware.akces.client.AkcesClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.List;

@RestController
@RequestMapping("/v{version:1}/accounts/{accountId}/orders")
public class OrdersCommandController {
    private final AkcesClient akcesClient;

    public OrdersCommandController(AkcesClient akcesClient) {
        this.akcesClient = akcesClient;
    }











}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/web/WalletCommandController.java
================
package org.elasticsoftware.cryptotrading.web;

import org.elasticsoftware.akces.client.AkcesClient;
import org.elasticsoftware.akces.events.ErrorEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.BalanceCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.WalletCreditedEvent;
import org.elasticsoftware.cryptotrading.web.dto.BalanceOutput;
import org.elasticsoftware.cryptotrading.web.dto.CreateBalanceInput;
import org.elasticsoftware.cryptotrading.web.dto.CreditWalletInput;
import org.elasticsoftware.cryptotrading.web.errors.ErrorEventException;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;

@RestController
@RequestMapping("/v{version:1}/wallets")
public class WalletCommandController {
    private final AkcesClient akcesClient;

    public WalletCommandController(AkcesClient akcesClient) {
        this.akcesClient = akcesClient;
    }

    @PostMapping("/{walletId}/balances/{currency}/credit")
    public Mono<ResponseEntity<BalanceOutput>> creditBalance(@PathVariable("walletId") String walletId,
                                                             @PathVariable("currency") String currency,
                                                             @RequestBody CreditWalletInput input) {
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId, currency)))
                .map(List::getFirst)
                .handle((domainEvent, sink) -> {
                    if (domainEvent instanceof WalletCreditedEvent) {
                        sink.next(ResponseEntity.ok(BalanceOutput.from((WalletCreditedEvent) domainEvent)));
                    } else {
                        sink.error(new ErrorEventException((ErrorEvent) domainEvent));
                    }
                });
    }

    @PostMapping("/{walletId}/balances")
    public Mono<ResponseEntity<BalanceOutput>> createBalance(@PathVariable("walletId") String walletId, @RequestBody CreateBalanceInput input) {
        return Mono.fromCompletionStage(akcesClient.send("TEST", input.toCommand(walletId)))
                .map(List::getFirst)
                .handle((domainEvent, sink) -> {
                    if (domainEvent instanceof BalanceCreatedEvent balanceCreatedEvent) {
                        sink.next(ResponseEntity.ok(BalanceOutput.from(balanceCreatedEvent)));
                    } else if (domainEvent instanceof ErrorEvent) {
                        sink.error(new ErrorEventException((ErrorEvent) domainEvent));
                    } else {


                    }
                });
    }
}

================
File: crypto-trading/commands/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
package org.elasticsoftware.cryptotrading;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@ComponentScan(basePackages = {
        "org.elasticsoftware.cryptotrading.web"
})
@PropertySource("classpath:akces-framework.properties")
public class ClientConfig {
}

================
File: crypto-trading/commands/src/main/resources/akces-framework.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/commands/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingCommandApiTest.java
================
package org.elasticsoftware.cryptotrading;

import jakarta.inject.Inject;
import org.elasticsoftware.akces.AggregateServiceApplication;
import org.elasticsoftware.akces.AkcesAggregateController;
import org.elasticsoftware.akces.client.AkcesClientController;
import org.elasticsoftware.cryptotrading.web.AccountCommandController;
import org.elasticsoftware.cryptotrading.web.WalletCommandController;
import org.elasticsoftware.cryptotrading.web.dto.*;
import org.elasticsoftware.cryptotrading.web.errors.ErrorEventResponse;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.PropertySource;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.support.TestPropertySourceUtils;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.KafkaContainer;
import org.testcontainers.containers.Network;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;

import static org.assertj.core.api.Assertions.assertThat;
import static org.elasticsoftware.cryptotrading.TestUtils.prepareAggregateServiceRecords;
import static org.elasticsoftware.cryptotrading.TestUtils.prepareKafka;

@SpringBootTest(
        classes = AggregateServiceApplication.class,
        args = {
                "org.elasticsoftware.cryptotrading.AggregateConfig",
                "org.elasticsoftware.cryptotrading.ClientConfig"
        },
        useMainMethod = SpringBootTest.UseMainMethod.ALWAYS,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@PropertySource("classpath:akces-aggregateservice.properties")
@ContextConfiguration(initializers = CryptoTradingCommandApiTest.Initializer.class)
@Testcontainers
@DirtiesContext
public class CryptoTradingCommandApiTest {
    private static final String CONFLUENT_PLATFORM_VERSION = "7.8.1";

    private static final Network network = Network.newNetwork();

    @Container
    private static final KafkaContainer kafka =
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");

    @Container
    private static final GenericContainer<?> schemaRegistry =
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withNetwork(network)
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    @Inject
    @Qualifier("WalletAkcesController")
    AkcesAggregateController walletController;
    @Inject
    @Qualifier("AccountAkcesController")
    AkcesAggregateController accountController;
    @Inject
    @Qualifier("OrderProcessManagerAkcesController")
    AkcesAggregateController prderProcessManagerController;
    @Inject
    @Qualifier("CryptoMarketAkcesController")
    AkcesAggregateController cryptoMarketController;
    @Inject
    AkcesClientController akcesClientController;
    @Inject
    AccountCommandController accountWebController;
    @Inject
    WalletCommandController walletWebController;
    @LocalServerPort
    private int port;
    @Inject
    private WebTestClient webTestClient;

    @AfterAll
    @BeforeAll
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {

            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        }
    }

    @Test
    void contextLoads() {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();

        assertThat(accountWebController).isNotNull();
        assertThat(walletWebController).isNotNull();

        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }
    }

    @Test
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    void healthLivenessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/liveness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    void testCreateAccount() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
                });
    }

    @Test
    void testCreateAccountAndCreditWallet() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
                            .bodyValue(creditInput)
                            .exchange()
                            .expectStatus().is2xxSuccessful()
                            .expectBody(BalanceOutput.class)
                            .value(creditOutput -> {
                                assertThat(creditOutput).isNotNull();
                                assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
                                assertThat(creditOutput.currency()).isEqualTo("EUR");
                            });
                });
    }

    @Test
    void testCreateAccountAndCreditWalletWithoutBalance() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
                            .bodyValue(creditInput)
                            .exchange()
                            .expectStatus().is4xxClientError()
                            .expectBody(ErrorEventResponse.class)
                            .value(response -> {
                                assertThat(response).isNotNull();
                                assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
                            });
                });
    }

    @Test
    void testCreateAccountAndAddBtcBalance() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances")
                            .bodyValue(createBalanceInput)
                            .exchange()
                            .expectStatus().is2xxSuccessful();
                });
    }

    @Test
    void testInvalidApiVersion() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }
        webTestClient.get()
                .uri("/v13/accounts/invalid-id")
                .exchange()
                .expectStatus().isNotFound();
    }

    public static class Initializer
            implements ApplicationContextInitializer<ConfigurableApplicationContext> {

        @Override
        public void initialize(ConfigurableApplicationContext applicationContext) {

            prepareKafka(kafka.getBootstrapServers());
            try {
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    applicationContext,
                    "akces.rocksdb.baseDir=/tmp/akces",
                    "spring.kafka.enabled=true",
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)
            );
        }
    }
}

================
File: crypto-trading/commands/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
package org.elasticsoftware.cryptotrading;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;
import org.elasticsoftware.akces.control.AggregateServiceRecord;
import org.elasticsoftware.akces.control.AkcesControlRecord;
import org.elasticsoftware.akces.gdpr.jackson.AkcesGDPRModule;
import org.elasticsoftware.akces.serialization.AkcesControlRecordSerde;
import org.elasticsoftware.akces.serialization.BigDecimalSerializer;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.kafka.core.KafkaAdmin;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;

public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    }

    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    }

    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "delete",
                "max.message.bytes", "20971520",
                "retention.ms", Long.toString(retentionMs),
                "segment.ms", "604800000"));
    }

    private static NewTopic createCompactedTopic(String name, int numPartitions) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "compact",
                "max.message.bytes", "20971520",
                "retention.ms", "-1",
                "segment.ms", "604800000",
                "min.cleanable.dirty.ratio", "0.1",
                "delete.retention.ms", "604800000",
                "compression.type", "lz4"));
    }

    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers,
                ProducerConfig.ACKS_CONFIG, "all",
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, "true",
                ProducerConfig.LINGER_MS_CONFIG, "0",
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, "1",
                ProducerConfig.RETRIES_CONFIG, "2147483647",
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG, "0",
                ProducerConfig.TRANSACTIONAL_ID_CONFIG, "Test-AkcesControllerProducer",
                ProducerConfig.CLIENT_ID_CONFIG, "Test-AkcesControllerProducer");
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
            for (int partition = 0; partition < 3; partition++) {
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            }
            controlProducer.commitTransaction();
        }
    }
}

================
File: crypto-trading/commands/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/commands/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.7.21-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-commands</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Command Service</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>provided</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>commands</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.client.CommandServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.4.2</version>
                <executions>
                    <execution>
                        <id>shared-web-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                        <configuration>
                            <classifier>shared-web</classifier>
                            <includes>
                                <include>**/dto/*</include>
                                <include>**/errors/*</include>
                            </includes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModel.java
================
package org.elasticsoftware.cryptotrading.query;

import org.elasticsoftware.akces.annotations.QueryModelEventHandler;
import org.elasticsoftware.akces.annotations.QueryModelInfo;
import org.elasticsoftware.akces.query.QueryModel;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;


@QueryModelInfo(value = "AccountQueryModel", version = 1, indexName = "Users")
public class AccountQueryModel implements QueryModel<AccountQueryModelState> {
    @Override
    public String getName() {
        return "Account";
    }

    @Override
    public Class<AccountQueryModelState> getStateClass() {
        return AccountQueryModelState.class;
    }

    @Override
    public String getIndexName() {
        return "Users";
    }

    @QueryModelEventHandler(create = true)
    public AccountQueryModelState create(AccountCreatedEvent event, AccountQueryModelState isNull) {
        return new AccountQueryModelState(
                event.userId(),
                event.country(),
                event.firstName(),
                event.lastName(),
                event.email());
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/AccountQueryModelState.java
================
package org.elasticsoftware.cryptotrading.query;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.PIIData;
import org.elasticsoftware.akces.annotations.QueryModelStateInfo;
import org.elasticsoftware.akces.query.QueryModelState;

@QueryModelStateInfo(type = "AccountQueryModel")
public record AccountQueryModelState(@NotNull String accountId,
                                     @NotNull String country,
                                     @NotNull @PIIData String firstName,
                                     @NotNull @PIIData String lastName,
                                     @NotNull @PIIData String email) implements QueryModelState {
    @Override
    public String getIndexKey() {
        return accountId();
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModel.java
================
package org.elasticsoftware.cryptotrading.query;

import org.elasticsoftware.akces.annotations.QueryModelEventHandler;
import org.elasticsoftware.akces.annotations.QueryModelInfo;
import org.elasticsoftware.akces.query.QueryModel;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.BalanceCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.WalletCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.WalletCreditedEvent;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@QueryModelInfo(value = "WalletQueryModel", version = 1, indexName = "Users")
public class WalletQueryModel implements QueryModel<WalletQueryModelState> {
    @Override
    public String getName() {
        return "WalletQueryModel";
    }

    @Override
    public Class<WalletQueryModelState> getStateClass() {
        return WalletQueryModelState.class;
    }

    @Override
    public String getIndexName() {
        return "Users";
    }

    @QueryModelEventHandler(create = true)
    public WalletQueryModelState create(WalletCreatedEvent event, WalletQueryModelState isNull) {
        return new WalletQueryModelState(event.id(), List.of());
    }

    @QueryModelEventHandler(create = false)
    public WalletQueryModelState createBalance(BalanceCreatedEvent event, WalletQueryModelState currentState) {
        WalletQueryModelState.Balance balance = new WalletQueryModelState.Balance(event.currency(), BigDecimal.ZERO);
        List<WalletQueryModelState.Balance> balances = new ArrayList<>(currentState.balances());
        balances.add(balance);
        return new WalletQueryModelState(currentState.walletId(), balances);
    }

    @QueryModelEventHandler(create = false)
    public WalletQueryModelState creditWallet(WalletCreditedEvent event, WalletQueryModelState currentState) {
        return new WalletQueryModelState(
                currentState.walletId(),
                currentState.balances().stream().map(balance -> {
                    if (balance.currency().equals(event.currency())) {
                        return new WalletQueryModelState.Balance(
                                balance.currency(),
                                balance.amount().add(event.amount()),
                                balance.reservedAmount()
                        );
                    } else {
                        return balance;
                    }
                }).toList());
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/query/WalletQueryModelState.java
================
package org.elasticsoftware.cryptotrading.query;

import jakarta.validation.constraints.NotNull;
import org.elasticsoftware.akces.annotations.QueryModelStateInfo;
import org.elasticsoftware.akces.query.QueryModelState;

import java.math.BigDecimal;
import java.util.List;

@QueryModelStateInfo(type = "Wallet")
public record WalletQueryModelState(String walletId, List<Balance> balances) implements QueryModelState {
    @Override
    public String getIndexKey() {
        return walletId();
    }

    public record Balance(String currency, BigDecimal amount, BigDecimal reservedAmount) {
        public Balance(@NotNull String currency) {
            this(currency, BigDecimal.ZERO, BigDecimal.ZERO);
        }

        public Balance(@NotNull String currency, @NotNull BigDecimal amount) {
            this(currency, amount, BigDecimal.ZERO);
        }

        public BigDecimal getAvailableAmount() {
            return amount.subtract(reservedAmount);
        }
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/AccountQueryController.java
================
package org.elasticsoftware.cryptotrading.web;

import org.elasticsoftware.akces.query.models.QueryModelIdNotFoundException;
import org.elasticsoftware.akces.query.models.QueryModelNotFoundException;
import org.elasticsoftware.akces.query.models.QueryModels;
import org.elasticsoftware.cryptotrading.query.AccountQueryModel;
import org.elasticsoftware.cryptotrading.web.dto.AccountOutput;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/v{version:1}/accounts")
public class AccountQueryController {
    private final QueryModels queryModels;

    public AccountQueryController(QueryModels queryModels) {
        this.queryModels = queryModels;
    }

    @GetMapping("/{accountId}")
    Mono<ResponseEntity<AccountOutput>> getAccount(@PathVariable("accountId") String accountId) {
        return Mono.fromCompletionStage(queryModels.getHydratedState(AccountQueryModel.class, accountId))
            .map(state -> ResponseEntity.ok(new AccountOutput(state.accountId(),
                    state.country(),
                    state.firstName(),
                    state.lastName(),
                    state.email()))).onErrorResume(throwable -> {
                        if(throwable instanceof QueryModelNotFoundException || throwable instanceof QueryModelIdNotFoundException) {
                            return Mono.just(ResponseEntity.notFound().build());
                        } else {
                            return Mono.just(ResponseEntity.internalServerError().build());
                        }
                    });
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/web/WalletQueryController.java
================
package org.elasticsoftware.cryptotrading.web;

import org.elasticsoftware.akces.query.models.QueryModelIdNotFoundException;
import org.elasticsoftware.akces.query.models.QueryModelNotFoundException;
import org.elasticsoftware.akces.query.models.QueryModels;
import org.elasticsoftware.cryptotrading.query.WalletQueryModel;
import org.elasticsoftware.cryptotrading.query.WalletQueryModelState;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/v{version:1}/wallets")
public class WalletQueryController {
    private final QueryModels queryModels;

    public WalletQueryController(QueryModels queryModels) {
        this.queryModels = queryModels;
    }

    @GetMapping("/{walletId}")
    Mono<ResponseEntity<WalletQueryModelState>> getWallet(@PathVariable("walletId") String walletId) {
        return Mono.fromCompletionStage(queryModels.getHydratedState(WalletQueryModel.class, walletId))
            .map(ResponseEntity::ok)
            .onErrorResume(throwable -> {
                if (throwable instanceof QueryModelNotFoundException || throwable instanceof QueryModelIdNotFoundException) {
                    return Mono.just(ResponseEntity.notFound().build());
                } else {
                    return Mono.just(ResponseEntity.internalServerError().build());
                }
            });
    }
}

================
File: crypto-trading/queries/src/main/java/org/elasticsoftware/cryptotrading/ClientConfig.java
================
package org.elasticsoftware.cryptotrading;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = {
        "org.elasticsoftware.cryptotrading.web",
        "org.elasticsoftware.cryptotrading.query"
})
public class ClientConfig {
}

================
File: crypto-trading/queries/src/main/resources/application.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
spring.application.name=Akces Crypto Trading
spring.kafka.bootstrap-servers=akces-kafka-bootstrap.kafka:9092
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
server.shutdown=graceful
spring.mvc.problemdetails.enabled=true

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingE2ETests.java
================
package org.elasticsoftware.cryptotrading;

import org.elasticsoftware.cryptotrading.web.dto.*;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.test.web.reactive.server.WebTestClient;

import java.math.BigDecimal;

import static org.assertj.core.api.Assertions.assertThat;

public class CryptoTradingE2ETests {
    private final WebTestClient e2eTestClient = WebTestClient.bindToServer()
            .baseUrl(System.getenv("AKCES_CRYPTO_TRADING_BASE_URL"))
            .build();

    @Test
    @EnabledIfEnvironmentVariable(named = "AKCES_CRYPTO_TRADING_BASE_URL", matches = ".*")
    public void testCreateAndReadAccount() {
        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        String userId = e2eTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
                }).returnResult().getResponseBody().userId();

        System.out.println("Created account with userId: " + userId);

        e2eTestClient.get()
                .uri("/v1/accounts/" + userId)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(retrievedAccount -> {
                    assertThat(retrievedAccount).isNotNull();
                    assertThat(retrievedAccount.userId()).isEqualTo(userId);
                    assertThat(retrievedAccount.country()).isEqualTo("NL");
                    assertThat(retrievedAccount.firstName()).isEqualTo("John");
                    assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
                    assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
                });

    }

    @Test
    @EnabledIfEnvironmentVariable(named = "AKCES_CRYPTO_TRADING_BASE_URL", matches = ".*")
    public void testBuyCrypto() {
        AccountInput accountInput = new AccountInput("NL", "Some", "CryptoTrader", "some.cryptotrader@example.com");
        String userId = e2eTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                }).returnResult().getResponseBody().userId();

        System.out.println("Created account with userId: " + userId);


        e2eTestClient.post()
                .uri("/v1/wallets/{userId}/balances", userId)
                .bodyValue(new CreateBalanceInput("ETH"))
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(BalanceOutput.class)
                .value(balanceOutput -> {
                    assertThat(balanceOutput).isNotNull();
                    assertThat(balanceOutput.currency()).isEqualTo("ETH");
                    assertThat(balanceOutput.amount()).isEqualTo(BigDecimal.ZERO);
                });


        e2eTestClient.post()
                .uri("/v1/wallets/{userId}/balances/EUR/credit", userId)
                .bodyValue(new CreditWalletInput(new BigDecimal("1000.00")))
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(BalanceOutput.class)
                .value(balanceOutput -> {
                    assertThat(balanceOutput).isNotNull();
                    assertThat(balanceOutput.currency()).isEqualTo("EUR");
                    assertThat(balanceOutput.amount()).isEqualTo(new BigDecimal("1000.00"));
                    assertThat(balanceOutput.balance()).isEqualTo(new BigDecimal("1000.00"));
                });




    }
}

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/CryptoTradingQueryApiTest.java
================
package org.elasticsoftware.cryptotrading;

import jakarta.inject.Inject;
import org.elasticsoftware.akces.AggregateServiceApplication;
import org.elasticsoftware.akces.AkcesAggregateController;
import org.elasticsoftware.akces.client.AkcesClientController;
import org.elasticsoftware.cryptotrading.aggregates.account.events.AccountCreatedEvent;
import org.elasticsoftware.cryptotrading.aggregates.wallet.events.WalletCreatedEvent;
import org.elasticsoftware.cryptotrading.web.AccountCommandController;
import org.elasticsoftware.cryptotrading.web.AccountQueryController;
import org.elasticsoftware.cryptotrading.web.WalletCommandController;
import org.elasticsoftware.cryptotrading.web.dto.*;
import org.elasticsoftware.cryptotrading.web.errors.ErrorEventResponse;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.PropertySource;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.support.TestPropertySourceUtils;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.KafkaContainer;
import org.testcontainers.containers.Network;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.elasticsoftware.cryptotrading.TestUtils.*;

@SpringBootTest(
        classes = AggregateServiceApplication.class,
        args = {
                "org.elasticsoftware.cryptotrading.AggregateConfig",
                "org.elasticsoftware.cryptotrading.ClientConfig"
        },
        useMainMethod = SpringBootTest.UseMainMethod.ALWAYS,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = {"akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates"})
@PropertySource("classpath:akces-aggregateservice.properties")
@ContextConfiguration(initializers = CryptoTradingQueryApiTest.Initializer.class)
@Testcontainers
@DirtiesContext
public class CryptoTradingQueryApiTest {
    private static final String CONFLUENT_PLATFORM_VERSION = "7.8.1";

    private static final Network network = Network.newNetwork();

    @Container
    private static final KafkaContainer kafka =
            new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
                    .withKraft()
                    .withEnv("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "false")
                    .withNetwork(network)
                    .withNetworkAliases("kafka");

    @Container
    private static final GenericContainer<?> schemaRegistry =
            new GenericContainer<>(DockerImageName.parse("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION))
                    .withNetwork(network)
                    .withEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", "kafka:9092")
                    .withEnv("SCHEMA_REGISTRY_HOST_NAME", "localhost")
                    .withExposedPorts(8081)
                    .withNetworkAliases("schema-registry")
                    .dependsOn(kafka);
    @Inject
    @Qualifier("WalletAkcesController")
    AkcesAggregateController walletController;
    @Inject
    @Qualifier("AccountAkcesController")
    AkcesAggregateController accountController;
    @Inject
    @Qualifier("OrderProcessManagerAkcesController")
    AkcesAggregateController prderProcessManagerController;
    @Inject
    @Qualifier("CryptoMarketAkcesController")
    AkcesAggregateController cryptoMarketController;
    @Inject
    AkcesClientController akcesClientController;
    @Inject
    AccountCommandController accountWebController;
    @Inject
    WalletCommandController walletWebController;
    @Inject
    AccountQueryController accountQueryController;
    @LocalServerPort
    private int port;
    @Inject
    private WebTestClient webTestClient;

    @AfterAll
    @BeforeAll
    public static void cleanUp() throws IOException {
        if (Files.exists(Paths.get("/tmp/akces"))) {

            Files.walk(Paths.get("/tmp/akces"))
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        }
    }

    @Test
    void contextLoads() {
        assertThat(walletController).isNotNull();
        assertThat(accountController).isNotNull();
        assertThat(prderProcessManagerController).isNotNull();
        assertThat(akcesClientController).isNotNull();
        assertThat(cryptoMarketController).isNotNull();

        assertThat(accountWebController).isNotNull();
        assertThat(walletWebController).isNotNull();
        assertThat(accountQueryController).isNotNull();

        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }
    }

    @Test
    void healthReadinessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/readiness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    void healthLivenessEndpointShouldBeEnabled() {
        webTestClient.get()
                .uri("/actuator/health/liveness")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(response -> assertThat(response).contains("{\"status\":\"UP\"}"));
    }

    @Test
    void testCreateAccount() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput).isNotNull();
                    assertThat(accountOutput.userId()).isNotNull();
                    assertThat(accountOutput.country()).isEqualTo("NL");
                    assertThat(accountOutput.firstName()).isEqualTo("John");
                    assertThat(accountOutput.lastName()).isEqualTo("Doe");
                    assertThat(accountOutput.email()).isEqualTo("john.doe@example.com");
                });
    }

    @Test
    void testCreateAccountAndCreditWallet() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/EUR/credit")
                            .bodyValue(creditInput)
                            .exchange()
                            .expectStatus().is2xxSuccessful()
                            .expectBody(BalanceOutput.class)
                            .value(creditOutput -> {
                                assertThat(creditOutput).isNotNull();
                                assertThat(creditOutput.amount()).isEqualByComparingTo("1.0");
                                assertThat(creditOutput.currency()).isEqualTo("EUR");
                            });
                });
    }

    @Test
    void testCreateAccountAndCreditWalletWithoutBalance() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreditWalletInput creditInput = new CreditWalletInput(new BigDecimal("1.0"));
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances/ETH/credit")
                            .bodyValue(creditInput)
                            .exchange()
                            .expectStatus().is4xxClientError()
                            .expectBody(ErrorEventResponse.class)
                            .value(response -> {
                                assertThat(response).isNotNull();
                                assertThat(response.eventType()).isEqualTo("InvalidCryptoCurrencyError");
                            });
                });
    }

    @Test
    void testCreateAccountAndAddBtcBalance() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("NL", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    CreateBalanceInput createBalanceInput = new CreateBalanceInput("BTC");
                    webTestClient.post()
                            .uri("/v1/wallets/" + accountOutput.userId() + "/balances")
                            .bodyValue(createBalanceInput)
                            .exchange()
                            .expectStatus().is2xxSuccessful();
                });
    }

    @Test
    void testGetAccount() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }

        AccountInput accountInput = new AccountInput("US", "John", "Doe", "john.doe@example.com");
        webTestClient.post()
                .uri("/v1/accounts")
                .bodyValue(accountInput)
                .exchange()
                .expectStatus().is2xxSuccessful()
                .expectBody(AccountOutput.class)
                .value(accountOutput -> {
                    assertThat(accountOutput.userId()).isNotNull();


                    webTestClient.get()
                            .uri("/v1/accounts/" + accountOutput.userId())
                            .exchange()
                            .expectStatus().is2xxSuccessful()
                            .expectBody(AccountOutput.class)
                            .value(retrievedAccount -> {
                                assertThat(retrievedAccount).isNotNull();
                                assertThat(retrievedAccount.userId()).isEqualTo(accountOutput.userId());
                                assertThat(retrievedAccount.country()).isEqualTo("US");
                                assertThat(retrievedAccount.firstName()).isEqualTo("John");
                                assertThat(retrievedAccount.lastName()).isEqualTo("Doe");
                                assertThat(retrievedAccount.email()).isEqualTo("john.doe@example.com");
                            });
                });
    }

    @Test
    void testInvalidApiVersion() {
        while (!walletController.isRunning() ||
                !accountController.isRunning() ||
                !prderProcessManagerController.isRunning() ||
                !cryptoMarketController.isRunning() ||
                !akcesClientController.isRunning()) {
            Thread.onSpinWait();
        }
        webTestClient.get()
                .uri("/v13/accounts/invalid-id")
                .exchange()
                .expectStatus().isNotFound();
    }

    public static class Initializer
            implements ApplicationContextInitializer<ConfigurableApplicationContext> {

        @Override
        public void initialize(ConfigurableApplicationContext applicationContext) {

            prepareKafka(kafka.getBootstrapServers());
            prepareDomainEventSchemas(
                    "http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081),
                    List.of(AccountCreatedEvent.class,
                            WalletCreatedEvent.class));
            try {
                prepareAggregateServiceRecords(kafka.getBootstrapServers());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            TestPropertySourceUtils.addInlinedPropertiesToEnvironment(
                    applicationContext,
                    "akces.rocksdb.baseDir=/tmp/akces",
                    "spring.kafka.enabled=true",
                    "spring.kafka.bootstrap-servers=" + kafka.getBootstrapServers(),
                    "akces.schemaregistry.url=http://" + schemaRegistry.getHost() + ":" + schemaRegistry.getMappedPort(8081)
            );
        }
    }
}

================
File: crypto-trading/queries/src/test/java/org/elasticsoftware/cryptotrading/TestUtils.java
================
package org.elasticsoftware.cryptotrading;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.github.victools.jsonschema.generator.*;
import com.github.victools.jsonschema.module.jackson.JacksonModule;
import com.github.victools.jsonschema.module.jakarta.validation.JakartaValidationModule;
import com.github.victools.jsonschema.module.jakarta.validation.JakartaValidationOption;
import io.confluent.kafka.schemaregistry.client.CachedSchemaRegistryClient;
import io.confluent.kafka.schemaregistry.client.SchemaRegistryClient;
import io.confluent.kafka.schemaregistry.client.rest.exceptions.RestClientException;
import io.confluent.kafka.schemaregistry.json.JsonSchema;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;
import org.elasticsoftware.akces.annotations.DomainEventInfo;
import org.elasticsoftware.akces.control.AggregateServiceRecord;
import org.elasticsoftware.akces.control.AkcesControlRecord;
import org.elasticsoftware.akces.events.DomainEvent;
import org.elasticsoftware.akces.gdpr.jackson.AkcesGDPRModule;
import org.elasticsoftware.akces.serialization.AkcesControlRecordSerde;
import org.elasticsoftware.akces.serialization.BigDecimalSerializer;
import org.springframework.context.ApplicationContextException;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.kafka.core.KafkaAdmin;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;

public class TestUtils {
    public static void prepareKafka(String bootstrapServers) {
        KafkaAdmin kafkaAdmin = new KafkaAdmin(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers));
        kafkaAdmin.createOrModifyTopics(
                createCompactedTopic("Akces-Control", 3),
                createTopic("Akces-CommandResponses", 3, 604800000L),
                createCompactedTopic("Akces-GDPRKeys", 3),
                createTopic("Wallet-Commands", 3),
                createTopic("Wallet-DomainEvents", 3),
                createTopic("Account-Commands", 3),
                createTopic("Account-DomainEvents", 3),
                createTopic("OrderProcessManager-Commands", 3),
                createTopic("OrderProcessManager-DomainEvents", 3),
                createTopic("CryptoMarket-Commands", 3),
                createTopic("CryptoMarket-DomainEvents", 3),
                createCompactedTopic("Wallet-AggregateState", 3),
                createCompactedTopic("Account-AggregateState", 3),
                createCompactedTopic("OrderProcessManager-AggregateState", 3),
                createCompactedTopic("CryptoMarket-AggregateState", 3));
    }

    private static NewTopic createTopic(String name, int numPartitions) {
        return createTopic(name, numPartitions, -1L);
    }

    private static NewTopic createTopic(String name, int numPartitions, long retentionMs) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "delete",
                "max.message.bytes", "20971520",
                "retention.ms", Long.toString(retentionMs),
                "segment.ms", "604800000"));
    }

    private static NewTopic createCompactedTopic(String name, int numPartitions) {
        NewTopic topic = new NewTopic(name, numPartitions, Short.parseShort("1"));
        return topic.configs(Map.of(
                "cleanup.policy", "compact",
                "max.message.bytes", "20971520",
                "retention.ms", "-1",
                "segment.ms", "604800000",
                "min.cleanable.dirty.ratio", "0.1",
                "delete.retention.ms", "604800000",
                "compression.type", "lz4"));
    }

    public static void prepareAggregateServiceRecords(String bootstrapServers) throws IOException {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modulesToInstall(new AkcesGDPRModule());
        builder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        ObjectMapper objectMapper = builder.build();
        AkcesControlRecordSerde controlSerde = new AkcesControlRecordSerde(objectMapper);
        Map<String, Object> controlProducerProps = Map.of(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers,
                ProducerConfig.ACKS_CONFIG, "all",
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, "true",
                ProducerConfig.LINGER_MS_CONFIG, "0",
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, "1",
                ProducerConfig.RETRIES_CONFIG, "2147483647",
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG, "0",
                ProducerConfig.TRANSACTIONAL_ID_CONFIG, "Test-AkcesControllerProducer",
                ProducerConfig.CLIENT_ID_CONFIG, "Test-AkcesControllerProducer");
        try (Producer<String, AkcesControlRecord> controlProducer = new KafkaProducer<>(controlProducerProps, new StringSerializer(), controlSerde.serializer())) {
            controlProducer.initTransactions();
            AggregateServiceRecord accountServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Account\",\"commandTopic\":\"Account-Commands\",\"domainEventTopic\":\"Account-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateAccount\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateAccount\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            AggregateServiceRecord orderProcessManagerServiceRecord = objectMapper.readValue("{\"aggregateName\":\"OrderProcessManager\",\"commandTopic\":\"OrderProcessManager-Commands\",\"domainEventTopic\":\"OrderProcessManager-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"RejectOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.RejectOrder\"},{\"typeName\":\"PlaceBuyOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceBuyOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"UserOrderProcessesCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.UserOrderProcessesCreated\"},{\"typeName\":\"BuyOrderCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderCreated\"},{\"typeName\":\"BuyOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderRejected\"},{\"typeName\":\"BuyOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BuyOrderPlaced\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":true,\"schemaName\":\"domainevents.InsufficientFundsError\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord walletServiceRecord = objectMapper.readValue("{\"aggregateName\":\"Wallet\",\"commandTopic\":\"Wallet-Commands\",\"domainEventTopic\":\"Wallet-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreditWallet\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreditWallet\"},{\"typeName\":\"CreateWallet\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateWallet\"},{\"typeName\":\"ReserveAmount\",\"version\":1,\"create\":false,\"schemaName\":\"commands.ReserveAmount\"},{\"typeName\":\"CreateBalance\",\"version\":1,\"create\":false,\"schemaName\":\"commands.CreateBalance\"}],\"producedEvents\":[{\"typeName\":\"InvalidAmountError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidAmountError\"},{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"BalanceAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceAlreadyExistsError\"},{\"typeName\":\"WalletCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.WalletCreated\"},{\"typeName\":\"InvalidCryptoCurrencyError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InvalidCryptoCurrencyError\"},{\"typeName\":\"BalanceCreated\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.BalanceCreated\"},{\"typeName\":\"InsufficientFundsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.InsufficientFundsError\"},{\"typeName\":\"AmountReserved\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AmountReserved\"},{\"typeName\":\"WalletCredited\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.WalletCredited\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"}],\"consumedEvents\":[{\"typeName\":\"AccountCreated\",\"version\":1,\"create\":true,\"external\":true,\"schemaName\":\"domainevents.AccountCreated\"}]}", AggregateServiceRecord.class);
            AggregateServiceRecord cryptoMarketServiceRecord = objectMapper.readValue("{\"aggregateName\":\"CryptoMarket\",\"commandTopic\":\"CryptoMarket-Commands\",\"domainEventTopic\":\"CryptoMarket-DomainEvents\",\"supportedCommands\":[{\"typeName\":\"CreateCryptoMarket\",\"version\":1,\"create\":true,\"schemaName\":\"commands.CreateCryptoMarket\"},{\"typeName\":\"PlaceMarketOrder\",\"version\":1,\"create\":false,\"schemaName\":\"commands.PlaceMarketOrder\"}],\"producedEvents\":[{\"typeName\":\"CommandExecutionError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.CommandExecutionError\"},{\"typeName\":\"MarketOrderPlaced\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderPlaced\"},{\"typeName\":\"CryptoMarketCreated\",\"version\":1,\"create\":true,\"external\":false,\"schemaName\":\"domainevents.CryptoMarketCreated\"},{\"typeName\":\"AggregateAlreadyExistsError\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.AggregateAlreadyExistsError\"},{\"typeName\":\"MarketOrderRejected\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderRejected\"},{\"typeName\":\"MarketOrderFilled\",\"version\":1,\"create\":false,\"external\":false,\"schemaName\":\"domainevents.MarketOrderFilled\"}],\"consumedEvents\":[]}", AggregateServiceRecord.class);
            controlProducer.beginTransaction();
            for (int partition = 0; partition < 3; partition++) {
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Account", accountServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "OrderProcessManager", orderProcessManagerServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "Wallet", walletServiceRecord));
                controlProducer.send(new ProducerRecord<>("Akces-Control", partition, "CryptoMarket", cryptoMarketServiceRecord));
            }
            controlProducer.commitTransaction();
        }
    }

    public static void prepareDomainEventSchemas(String url, List<Class<? extends DomainEvent>> domainEventClasses) {
        SchemaRegistryClient src = new CachedSchemaRegistryClient(url, 100);
        Jackson2ObjectMapperBuilder objectMapperBuilder = new Jackson2ObjectMapperBuilder();
        objectMapperBuilder.modulesToInstall(new AkcesGDPRModule());
        objectMapperBuilder.serializerByType(BigDecimal.class, new BigDecimalSerializer());
        SchemaGeneratorConfigBuilder configBuilder = new SchemaGeneratorConfigBuilder(objectMapperBuilder.build(),
                SchemaVersion.DRAFT_7,
                OptionPreset.PLAIN_JSON);
        configBuilder.with(new JakartaValidationModule(JakartaValidationOption.INCLUDE_PATTERN_EXPRESSIONS,
                JakartaValidationOption.NOT_NULLABLE_FIELD_IS_REQUIRED));
        configBuilder.with(new JacksonModule());
        configBuilder.with(Option.FORBIDDEN_ADDITIONAL_PROPERTIES_BY_DEFAULT);
        configBuilder.with(Option.NULLABLE_FIELDS_BY_DEFAULT);
        configBuilder.with(Option.NULLABLE_METHOD_RETURN_VALUES_BY_DEFAULT);

        configBuilder.forTypesInGeneral().withTypeAttributeOverride((collectedTypeAttributes, scope, context) -> {
            if (scope.getType().getTypeName().equals("java.math.BigDecimal")) {
                JsonNode typeNode = collectedTypeAttributes.get("type");
                if (typeNode.isArray()) {
                    ((ArrayNode) collectedTypeAttributes.get("type")).set(0, "string");
                } else
                    collectedTypeAttributes.put("type", "string");
            }
        });
        SchemaGeneratorConfig config = configBuilder.build();
        SchemaGenerator jsonSchemaGenerator = new SchemaGenerator(config);
        try {
            for (Class<?> domainEventClass : domainEventClasses) {
                DomainEventInfo info = domainEventClass.getAnnotation(DomainEventInfo.class);
                src.register("domainevents." + info.type(),
                        new JsonSchema(jsonSchemaGenerator.generateSchema(domainEventClass), List.of(), Map.of(), info.version()),
                        info.version(),
                        -1);
            }
        } catch (IOException | RestClientException e) {
            throw new ApplicationContextException("Problem populating SchemaRegistry", e);
        }
    }
}

================
File: crypto-trading/queries/src/test/resources/application-test.properties
================
#
# Copyright 2022 - 2025 The Original Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
akces.client.domainEventsPackage=org.elasticsoftware.cryptotrading.aggregates

================
File: crypto-trading/queries/src/test/resources/logback-test.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<configuration>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>
                %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
            </Pattern>
        </layout>
    </appender>

    <logger name="org.apache.kafka" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.producer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.apache.kafka.clients.consumer" level="warn" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.kafka" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.gdpr" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <logger name="org.elasticsoftware.akces.state" level="trace" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>

================
File: crypto-trading/queries/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-crypto-trading-parent</artifactId>
        <version>0.7.21-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-queries</artifactId>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading :: Query Service</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-query-support</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <classifier>events</classifier>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <classifier>shared-web</classifier>
            <version>${project.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.elasticsoftwarefoundation.akces</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-client</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-commands</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsoftwarefoundation.akces</groupId>
            <artifactId>akces-crypto-trading-aggregates</artifactId>
            <scope>test</scope>
            <version>${project.version}</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>process-aot</goal>
                        </goals>
                        <configuration>
                            <mainClass>org.elasticsoftware.akces.query.QueryServiceApplication</mainClass>
                            <arguments>
                                <argument>org.elasticsoftware.cryptotrading.ClientConfig</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

================
File: crypto-trading/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-test-apps</artifactId>
        <version>0.7.21-SNAPSHOT</version>
    </parent>
    <artifactId>akces-crypto-trading-parent</artifactId>
    <packaging>pom</packaging>
    <name>Elastic Software Foundation :: Akces :: Test Apps :: Crypto Trading</name>
    <description>Crypto Trading Akces Test Application</description>
    <properties>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <modules>
        <module>aggregates</module>
        <module>commands</module>
        <module>queries</module>
    </modules>

    <build>
        <plugins>

        </plugins>
    </build>

</project>

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>

















<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.elasticsoftwarefoundation.akces</groupId>
        <artifactId>akces-framework-parent</artifactId>
        <version>0.7.21-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>akces-framework-test-apps</artifactId>
    <packaging>pom</packaging>

    <name>Elastic Software Foundation :: Akces :: Test Apps</name>
    <url>https://github.com/elasticsoftwarefoundation/akces-framework</url>

    <properties>
        <akces-framework.version>${project.version}</akces-framework.version>
    </properties>

    <repositories>
        <repository>
            <id>github</id>
            <name>Akces Github Packages Repository</name>
            <url>https://github.com/elasticsoftwarefoundation/akces-framework/packages</url>
        </repository>
        <repository>
            <id>central</id>
            <name>Maven Central</name>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
    </repositories>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-api</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-runtime</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-client</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>org.elasticsoftwarefoundation.akces</groupId>
                <artifactId>akces-query-support</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava-bom</artifactId>
                <version>${guava.version}</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>com.github.ben-manes.caffeine</groupId>
                <artifactId>caffeine</artifactId>
                <version>${caffeine.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>com.google.errorprone</groupId>
                        <artifactId>error_prone_annotations</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <modules>
        <module>crypto-trading</module>
    </modules>
    <build>
        <plugins>
            <plugin>

                <artifactId>maven-deploy-plugin</artifactId>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <profile>
            <id>maven-release</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <configuration>
                            <docker>
                                <publishRegistry>
                                    <username>${env.GITHUB_ACTOR}</username>
                                    <password>${env.GITHUB_TOKEN}</password>
                                    <url>docker://ghcr.io</url>
                                </publishRegistry>
                            </docker>
                            <image>
                                <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}</name>
                                <publish>true</publish>
                                <env>
                                    <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                    <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    <BP_SPRING_AOT_ENABLED>true</BP_SPRING_AOT_ENABLED>
                                    <BP_JVM_CDS_ENABLED>true</BP_JVM_CDS_ENABLED>
                                    <JAVA_TOOL_OPTIONS>-XX:+UseZGC -XX:+ZGenerational</JAVA_TOOL_OPTIONS>
                                </env>
                                <buildpacks>
                                    <buildpack>gcr.io/paketo-buildpacks/ca-certificates</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/adoptium:latest</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/syft</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/executable-jar</buildpack>
                                    <buildpack>gcr.io/paketo-buildpacks/spring-boot</buildpack>
                                </buildpacks>
                            </image>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>process-aot</goal>
                                </goals>
                                <configuration>

                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>native</id>
            <build>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-jar-plugin</artifactId>
                            <configuration>
                                <archive>
                                    <manifestEntries>
                                        <Spring-Boot-Native-Processed>true</Spring-Boot-Native-Processed>
                                    </manifestEntries>
                                </archive>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                            <executions>
                                <execution>
                                    <id>process-aot</id>
                                    <goals>
                                        <goal>process-aot</goal>
                                    </goals>
                                </execution>
                            </executions>
                            <configuration>
                                <docker>
                                    <publishRegistry>
                                        <username>${env.GITHUB_ACTOR}</username>
                                        <password>${env.GITHUB_TOKEN}</password>
                                        <url>docker://ghcr.io</url>
                                    </publishRegistry>
                                </docker>
                                <image>
                                    <builder>paketobuildpacks/builder-jammy-buildpackless-base:latest</builder>
                                    <runImage>docker.io/paketobuildpacks/run-jammy-base:latest</runImage>
                                    <name>ghcr.io/elasticsoftwarefoundation/${project.artifactId}:${project.version}
                                    </name>
                                    <publish>true</publish>
                                    <env>
                                        <BP_JVM_VERSION>${java.version}</BP_JVM_VERSION>
                                        <BP_JVM_JLINK_ENABLED>false</BP_JVM_JLINK_ENABLED>
                                    </env>
                                </image>
                            </configuration>
                        </plugin>
                        <plugin>
                            <groupId>org.graalvm.buildtools</groupId>
                            <artifactId>native-maven-plugin</artifactId>
                            <configuration>
                                <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                                <requiredVersion>22.3</requiredVersion>
                            </configuration>
                            <executions>
                                <execution>
                                    <id>add-reachability-metadata</id>
                                    <goals>
                                        <goal>add-reachability-metadata</goal>
                                    </goals>
                                </execution>
                                <execution>
                                    <id>build-native</id>
                                    <goals>
                                        <goal>compile-no-fork</goal>
                                    </goals>
                                    <phase>package</phase>
                                </execution>
                            </executions>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
        <profile>
            <id>nativeTest</id>
            <dependencies>
                <dependency>
                    <groupId>org.junit.platform</groupId>
                    <artifactId>junit-platform-launcher</artifactId>
                    <scope>test</scope>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>process-test-aot</id>
                                <goals>
                                    <goal>process-test-aot</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    <plugin>
                        <groupId>org.graalvm.buildtools</groupId>
                        <artifactId>native-maven-plugin</artifactId>
                        <configuration>
                            <classesDirectory>${project.build.outputDirectory}</classesDirectory>
                            <requiredVersion>22.3</requiredVersion>
                        </configuration>
                        <executions>
                            <execution>
                                <id>native-test</id>
                                <goals>
                                    <goal>test</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>



================================================================
End of Codebase
================================================================
